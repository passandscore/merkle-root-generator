"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/merkletreejs";
exports.ids = ["vendor-chunks/merkletreejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/merkletreejs/dist/Base.js":
/*!************************************************!*\
  !*** ./node_modules/merkletreejs/dist/Base.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Base = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst crypto_js_1 = __importDefault(__webpack_require__(/*! crypto-js */ \"(ssr)/./node_modules/crypto-js/index.js\"));\nclass Base {\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */ print() {\n        Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */ bufferIndexOf(array, element, isSorted = false) {\n        if (isSorted) {\n            return this.binarySearch(array, element, buffer_1.Buffer.compare);\n        }\n        const eqChecker = (buffer1, buffer2)=>buffer1.equals(buffer2);\n        return this.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n     *```\n     */ static binarySearch(array, element, compareFunction) {\n        let start = 0;\n        let end = array.length - 1;\n        // Iterate while start not meets end\n        while(start <= end){\n            // Find the mid index\n            const mid = Math.floor((start + end) / 2);\n            // Check if the mid value is greater than, equal to, or less than search element.\n            const ordering = compareFunction(array[mid], element);\n            // If element is present at mid, start iterating for searching first appearance.\n            if (ordering === 0) {\n                // Linear reverse iteration until the first matching item index is found.\n                for(let i = mid - 1; i >= 0; i--){\n                    if (compareFunction(array[i], element) === 0) continue;\n                    return i + 1;\n                }\n                return 0;\n            } else if (ordering < 0) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.binarySearch(array, element, Buffer.compare)\n     *```\n     */ binarySearch(array, element, compareFunction) {\n        return Base.binarySearch(array, element, compareFunction);\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */ static linearSearch(array, element, eqChecker) {\n        for(let i = 0; i < array.length; i++){\n            if (eqChecker(array[i], element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */ linearSearch(array, element, eqChecker) {\n        return Base.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */ static bufferify(value) {\n        if (!buffer_1.Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === \"object\" && value.words) {\n                return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), \"hex\");\n            } else if (Base.isHexString(value)) {\n                return buffer_1.Buffer.from(value.replace(/^0x/, \"\"), \"hex\");\n            } else if (typeof value === \"string\") {\n                return buffer_1.Buffer.from(value);\n            } else if (typeof value === \"bigint\") {\n                return buffer_1.Buffer.from(value.toString(16), \"hex\");\n            } else if (value instanceof Uint8Array) {\n                return buffer_1.Buffer.from(value.buffer);\n            } else if (typeof value === \"number\") {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return buffer_1.Buffer.from(s, \"hex\");\n            } else if (ArrayBuffer.isView(value)) {\n                return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    bigNumberify(value) {\n        return Base.bigNumberify(value);\n    }\n    static bigNumberify(value) {\n        if (typeof value === \"bigint\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            if (value.startsWith(\"0x\") && Base.isHexString(value)) {\n                return BigInt(\"0x\" + value.replace(\"0x\", \"\").toString());\n            }\n            return BigInt(value);\n        }\n        if (buffer_1.Buffer.isBuffer(value)) {\n            return BigInt(\"0x\" + value.toString(\"hex\"));\n        }\n        if (value instanceof Uint8Array) {\n            return BigInt(value);\n        }\n        if (typeof value === \"number\") {\n            return BigInt(value);\n        }\n        throw new Error(\"cannot bigNumberify\");\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */ static isHexString(v) {\n        return typeof v === \"string\" && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */ static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */ bufferToHex(value, withPrefix = true) {\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */ static bufferToHex(value, withPrefix = true) {\n        return `${withPrefix ? \"0x\" : \"\"}${(value || buffer_1.Buffer.alloc(0)).toString(\"hex\")}`;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */ bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */ bufferifyFn(f) {\n        return (value)=>{\n            const v = f(value);\n            if (buffer_1.Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this.isHexString(v)) {\n                return buffer_1.Buffer.from(v.replace(\"0x\", \"\"), \"hex\");\n            }\n            if (typeof v === \"string\") {\n                return buffer_1.Buffer.from(v);\n            }\n            if (typeof v === \"bigint\") {\n                return buffer_1.Buffer.from(value.toString(16), \"hex\");\n            }\n            if (ArrayBuffer.isView(v)) {\n                return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString(\"hex\"))).toString(crypto_js_1.default.enc.Hex), \"hex\");\n        };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */ isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */ log2(n) {\n        return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */ zip(a, b) {\n        return a.map((e, i)=>[\n                e,\n                b[i]\n            ]);\n    }\n    static hexZeroPad(hexStr, length) {\n        return \"0x\" + hexStr.replace(\"0x\", \"\").padStart(length, \"0\");\n    }\n}\nexports.Base = Base;\nexports[\"default\"] = Base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvQmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBRyxLQUFLO0FBQ3BCLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLGNBQWNWLGdCQUFnQlMsbUJBQU9BLENBQUMsMERBQVc7QUFDdkQsTUFBTUY7SUFDRjs7Ozs7OztLQU9DLEdBQ0RJLFFBQVE7UUFDSkosS0FBS0ksS0FBSyxDQUFDLElBQUk7SUFDbkI7SUFDQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNEQyxjQUFjQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxLQUFLLEVBQUU7UUFDNUMsSUFBSUEsVUFBVTtZQUNWLE9BQU8sSUFBSSxDQUFDQyxZQUFZLENBQUNILE9BQU9DLFNBQVNOLFNBQVNTLE1BQU0sQ0FBQ0MsT0FBTztRQUNwRTtRQUNBLE1BQU1DLFlBQVksQ0FBQ0MsU0FBU0MsVUFBWUQsUUFBUUUsTUFBTSxDQUFDRDtRQUN2RCxPQUFPLElBQUksQ0FBQ0UsWUFBWSxDQUFDVixPQUFPQyxTQUFTSztJQUM3QztJQUNBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE9BQU9ILGFBQWFILEtBQUssRUFBRUMsT0FBTyxFQUFFVSxlQUFlLEVBQUU7UUFDakQsSUFBSUMsUUFBUTtRQUNaLElBQUlDLE1BQU1iLE1BQU1jLE1BQU0sR0FBRztRQUN6QixvQ0FBb0M7UUFDcEMsTUFBT0YsU0FBU0MsSUFBSztZQUNqQixxQkFBcUI7WUFDckIsTUFBTUUsTUFBTUMsS0FBS0MsS0FBSyxDQUFDLENBQUNMLFFBQVFDLEdBQUUs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QUFPLENBQUNDLEdBQUcsQ0FBQ0MsR0FBRyxHQUFHO1FBQ25JO0lBQ0o7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0RDLFlBQVluQyxLQUFLLEVBQUU7UUFDZixPQUFPQyxLQUFLa0MsV0FBVyxDQUFDbkM7SUFDNUI7SUFDQTs7Ozs7S0FLQyxHQUNEMkQsS0FBS0MsQ0FBQyxFQUFFO1FBQ0osT0FBT0EsTUFBTSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUNELElBQUksQ0FBQyxJQUFLLElBQUs7SUFDakQ7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREUsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDTixPQUFPRCxFQUFFRSxHQUFHLENBQUMsQ0FBQ0MsR0FBR3ZDLElBQU07Z0JBQUN1QztnQkFBR0YsQ0FBQyxDQUFDckMsRUFBRTthQUFDO0lBQ3BDO0lBQ0EsT0FBT3dDLFdBQVdDLE1BQU0sRUFBRTlDLE1BQU0sRUFBRTtRQUM5QixPQUFPLE9BQU84QyxPQUFPL0IsT0FBTyxDQUFDLE1BQU0sSUFBSWdDLFFBQVEsQ0FBQy9DLFFBQVE7SUFDNUQ7QUFDSjtBQUNBdEIsWUFBWSxHQUFHRTtBQUNmRixrQkFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL21lcmtsZS8uL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9CYXNlLmpzP2I0MmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2UgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCBjcnlwdG9fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvLWpzXCIpKTtcbmNsYXNzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIHByaW50XG4gICAgICogQGRlc2MgUHJpbnRzIG91dCBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVya2xlIHRyZWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICp0cmVlLnByaW50KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHByaW50KCkge1xuICAgICAgICBCYXNlLnByaW50KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWZmZXJJbmRleE9mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gYnVmZmVyIGlzIGZvdW5kIGluIGFycmF5LlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGhheXN0YWNrIC0gQXJyYXkgb2YgYnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gbmVlZGxlIC0gQnVmZmVyIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSB0cmVlLmJ1ZmZlckluZGV4T2YoaGF5c3RhY2ssIG5lZWRsZSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJ1ZmZlckluZGV4T2YoYXJyYXksIGVsZW1lbnQsIGlzU29ydGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTZWFyY2goYXJyYXksIGVsZW1lbnQsIGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcUNoZWNrZXIgPSAoYnVmZmVyMSwgYnVmZmVyMikgPT4gYnVmZmVyMS5lcXVhbHMoYnVmZmVyMik7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgZXFDaGVja2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYmluYXJ5U2VhcmNoXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGFycmF5IC0gQXJyYXkgb2YgaXRlbXMuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGVsZW1lbnQgLSBJdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZUZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSBNZXJrbGVUcmVlLmJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgQnVmZmVyLmNvbXBhcmUpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIC8vIEl0ZXJhdGUgd2hpbGUgc3RhcnQgbm90IG1lZXRzIGVuZFxuICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBtaWQgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1pZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4sIGVxdWFsIHRvLCBvciBsZXNzIHRoYW4gc2VhcmNoIGVsZW1lbnQuXG4gICAgICAgICAgICBjb25zdCBvcmRlcmluZyA9IGNvbXBhcmVGdW5jdGlvbihhcnJheVttaWRdLCBlbGVtZW50KTtcbiAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaXMgcHJlc2VudCBhdCBtaWQsIHN0YXJ0IGl0ZXJhdGluZyBmb3Igc2VhcmNoaW5nIGZpcnN0IGFwcGVhcmFuY2UuXG4gICAgICAgICAgICBpZiAob3JkZXJpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5lYXIgcmV2ZXJzZSBpdGVyYXRpb24gdW50aWwgdGhlIGZpcnN0IG1hdGNoaW5nIGl0ZW0gaW5kZXggaXMgZm91bmQuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1pZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24oYXJyYXlbaV0sIGVsZW1lbnQpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IC8qIEVsc2UgbG9vayBpbiBsZWZ0IG9yIHJpZ2h0IGhhbGYgYWNjb3JkaW5nbHkgKi9cbiAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyaW5nIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBiaW5hcnlTZWFyY2hcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBpdGVtIGlzIGZvdW5kIGluIGFycmF5IHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gYXJyYXkgLSBBcnJheSBvZiBpdGVtcy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZWxlbWVudCAtIEl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRleCA9IHRyZWUuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBCdWZmZXIuY29tcGFyZSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgY29tcGFyZUZ1bmN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbGluZWFyU2VhcmNoXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBsaW5lYXIgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGFycmF5IC0gQXJyYXkgb2YgaXRlbXMuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGVsZW1lbnQgLSBJdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXFDaGVja2VyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSBNZXJrbGVUcmVlLmxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgKGEsIGIpID0+IGEgPT09IGIpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgbGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVxQ2hlY2tlcihhcnJheVtpXSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGxpbmVhclNlYXJjaFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9mIHdoaWNoIGdpdmVuIGl0ZW0gaXMgZm91bmQgaW4gYXJyYXkgdXNpbmcgbGluZWFyIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBhcnJheSAtIEFycmF5IG9mIGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBlbGVtZW50IC0gSXRlbSB0byBmaW5kLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxQ2hlY2tlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSBJbmRleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGluZGV4ID0gdHJlZS5saW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIChhLCBiKSA9PiBhID09PSBiKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgbGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UubGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWZmZXJpZnlcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgYnVmZmVyIHR5cGUgZm9yIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBidWYgPSBNZXJrbGVUcmVlLmJ1ZmZlcmlmeSgnMHgxMjM0JylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBidWZmZXJpZnkodmFsdWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBjcnlwdG8tanMgc3VwcG9ydFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUud29yZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoY3J5cHRvX2pzXzEuZGVmYXVsdC5lbmMuSGV4KSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQmFzZS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUucmVwbGFjZSgvXjB4LywgJycpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoMTYpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICBzID0gYDAke3N9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHMsICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUuYnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGJpZ051bWJlcmlmeSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQmFzZS5iaWdOdW1iZXJpZnkodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgYmlnTnVtYmVyaWZ5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpICYmIEJhc2UuaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgdmFsdWUucmVwbGFjZSgnMHgnLCAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgdmFsdWUudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYmlnTnVtYmVyaWZ5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlzSGV4U3RyaW5nXG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgaGV4IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc29sZS5sb2coTWVya2xlVHJlZS5pc0hleFN0cmluZygnMHgxMjM0JykpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNIZXhTdHJpbmcodikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIC9eKDB4KT9bMC05QS1GYS1mXSokLy50ZXN0KHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcmludFxuICAgICAqIEBkZXNjIFByaW50cyBvdXQgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIG1lcmtsZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlIC0gTWVya2xlIHRyZWUgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqTWVya2xlVHJlZS5wcmludCh0cmVlKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIHByaW50KHRyZWUpIHtcbiAgICAgICAgY29uc29sZS5sb2codHJlZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYnVmZmVyVG9IZXhcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgaGV4IHN0cmluZyB3aXRoIDB4IHByZWZpeCBmb3IgZ2l2ZW4gYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGhleFN0ciA9IHRyZWUuYnVmZmVyVG9IZXgoQnVmZmVyLmZyb20oJ0EnKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJ1ZmZlclRvSGV4KHZhbHVlLCB3aXRoUHJlZml4ID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gQmFzZS5idWZmZXJUb0hleCh2YWx1ZSwgd2l0aFByZWZpeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlclRvSGV4XG4gICAgICogQGRlc2MgUmV0dXJucyBhIGhleCBzdHJpbmcgd2l0aCAweCBwcmVmaXggZm9yIGdpdmVuIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBoZXhTdHIgPSBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KEJ1ZmZlci5mcm9tKCdBJykpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVyVG9IZXgodmFsdWUsIHdpdGhQcmVmaXggPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBgJHt3aXRoUHJlZml4ID8gJzB4JyA6ICcnfSR7KHZhbHVlIHx8IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKSkudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlcmlmeVxuICAgICAqIEBkZXNjIFJldHVybnMgYSBidWZmZXIgdHlwZSBmb3IgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R8QnVmZmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGJ1ZiA9IHRyZWUuYnVmZmVyaWZ5KCcweDEyMzQnKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYnVmZmVyaWZ5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmJ1ZmZlcmlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlcmlmeUZuXG4gICAgICogQGRlc2MgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBidWZmZXJpZnkgdGhlIHJldHVybiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgZm4gPSB0cmVlLmJ1ZmZlcmlmeUZuKCh2YWx1ZSkgPT4gc2hhMjU2KHZhbHVlKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGJ1ZmZlcmlmeUZuKGYpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdiA9IGYodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odi5yZXBsYWNlKCcweCcsICcnKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoMTYpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHYuYnVmZmVyLCB2LmJ5dGVPZmZzZXQsIHYuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcnlwdG8tanMgc3VwcG9ydFxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGYoY3J5cHRvX2pzXzEuZGVmYXVsdC5lbmMuSGV4LnBhcnNlKHZhbHVlLnRvU3RyaW5nKCdoZXgnKSkpLnRvU3RyaW5nKGNyeXB0b19qc18xLmRlZmF1bHQuZW5jLkhleCksICdoZXgnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXNIZXhTdHJpbmdcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBoZXggc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zb2xlLmxvZyhNZXJrbGVUcmVlLmlzSGV4U3RyaW5nKCcweDEyMzQnKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmlzSGV4U3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9nMlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGxvZzIgb2YgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBsb2cyKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT09IDEgPyAwIDogMSArIHRoaXMubG9nMigobiAvIDIpIHwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHppcFxuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGhleCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxOdW1iZXJbXXxCdWZmZXJbXX0gYSAtIGZpcnN0IGFycmF5XG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxOdW1iZXJbXXxCdWZmZXJbXX0gYiAtICBzZWNvbmQgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXVtdfE51bWJlcltdW118QnVmZmVyW11bXX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHppcHBlZCA9IHRyZWUuemlwKFsnYScsICdiJ10sWydBJywgJ0InXSlcbiAgICAgKmNvbnNvbGUubG9nKHppcHBlZCkgLy8gWyBbICdhJywgJ0EnIF0sIFsgJ2InLCAnQicgXSBdXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB6aXAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5tYXAoKGUsIGkpID0+IFtlLCBiW2ldXSk7XG4gICAgfVxuICAgIHN0YXRpYyBoZXhaZXJvUGFkKGhleFN0ciwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgaGV4U3RyLnJlcGxhY2UoJzB4JywgJycpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2UgPSBCYXNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlIiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwiY3J5cHRvX2pzXzEiLCJwcmludCIsImJ1ZmZlckluZGV4T2YiLCJhcnJheSIsImVsZW1lbnQiLCJpc1NvcnRlZCIsImJpbmFyeVNlYXJjaCIsIkJ1ZmZlciIsImNvbXBhcmUiLCJlcUNoZWNrZXIiLCJidWZmZXIxIiwiYnVmZmVyMiIsImVxdWFscyIsImxpbmVhclNlYXJjaCIsImNvbXBhcmVGdW5jdGlvbiIsInN0YXJ0IiwiZW5kIiwibGVuZ3RoIiwibWlkIiwiTWF0aCIsImZsb29yIiwib3JkZXJpbmciLCJpIiwiYnVmZmVyaWZ5IiwiaXNCdWZmZXIiLCJ3b3JkcyIsImZyb20iLCJ0b1N0cmluZyIsImRlZmF1bHQiLCJlbmMiLCJIZXgiLCJpc0hleFN0cmluZyIsInJlcGxhY2UiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwicyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJiaWdOdW1iZXJpZnkiLCJzdGFydHNXaXRoIiwiQmlnSW50IiwiRXJyb3IiLCJ2IiwidGVzdCIsInRyZWUiLCJjb25zb2xlIiwibG9nIiwiYnVmZmVyVG9IZXgiLCJ3aXRoUHJlZml4IiwiYWxsb2MiLCJidWZmZXJpZnlGbiIsImYiLCJwYXJzZSIsImxvZzIiLCJuIiwiemlwIiwiYSIsImIiLCJtYXAiLCJlIiwiaGV4WmVyb1BhZCIsImhleFN0ciIsInBhZFN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/Base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/IncrementalMerkleTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/merkletreejs/dist/IncrementalMerkleTree.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IncrementalMerkleTree = void 0;\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\"));\nconst treeify_1 = __importDefault(__webpack_require__(/*! treeify */ \"(ssr)/./node_modules/treeify/treeify.js\"));\nclass IncrementalMerkleTree extends Base_1.default {\n    constructor(hashFn, options){\n        super();\n        this.hashFn = hashFn;\n        if (options.depth) {\n            this.depth = options.depth;\n        }\n        if (options.arity) {\n            this.arity = options.arity;\n        }\n        if (this.depth < 1) {\n            throw new Error(\"depth must be greater than 0\");\n        }\n        if (this.arity < 1) {\n            throw new Error(\"arity must be greater than 0\");\n        }\n        const nodes = [];\n        let zeroValue = options.zeroValue;\n        this.zeroValue = zeroValue;\n        this.zeroes = [];\n        if (this.depth) {\n            for(let i = 0; i < this.depth; i++){\n                this.zeroes.push(zeroValue);\n                nodes[i] = [];\n                zeroValue = this.hashFn(Array(this.arity).fill(zeroValue));\n            }\n        }\n        this.nodes = nodes;\n        this.root = zeroValue;\n    }\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.bufferify(this.getRoot()));\n    }\n    insert(leaf) {\n        if (this.depth && this.arity) {\n            if (this.nodes[0].length >= this.getMaxLeaves()) {\n                throw new Error(\"tree is full\");\n            }\n        }\n        let node = leaf;\n        let index = this.nodes[0].length;\n        for(let level = 0; level < this.depth; level += 1){\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for(let i = levelStartIndex; i < levelEndIndex; i += 1){\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                } else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    delete(index) {\n        this.update(index, this.zeroValue);\n    }\n    update(index, newLeaf) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error(\"out of bounds\");\n        }\n        let node = newLeaf;\n        for(let level = 0; level < this.depth; level += 1){\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for(let i = levelStartIndex; i < levelEndIndex; i += 1){\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                } else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    getDepth() {\n        return this.depth;\n    }\n    getArity() {\n        return this.arity;\n    }\n    getMaxLeaves() {\n        return Math.pow(this.depth, this.arity);\n    }\n    indexOf(leaf) {\n        return this.nodes[0].indexOf(leaf);\n    }\n    getLeaves() {\n        const leaves = this.copyList(this.nodes[0]);\n        const index = this.nodes[0].length;\n        for(let i = index; i < this.getMaxLeaves(); i++){\n            leaves[i] = this.zeroValue;\n        }\n        return leaves;\n    }\n    copyList(list) {\n        return list.map((x)=>BigInt(x));\n    }\n    getLayers() {\n        const layers = [];\n        for (const list of this.nodes){\n            layers.push(this.copyList(list));\n        }\n        if (layers[0].length < this.getMaxLeaves()) {\n            let index = layers[0].length;\n            for(let i = index; i < this.getMaxLeaves(); i++){\n                layers[0][i] = this.zeroValue;\n            }\n            for(let level = 0; level < this.depth; level++){\n                const position = index % this.arity;\n                const levelStartIndex = index - position;\n                const levelEndIndex = levelStartIndex + this.arity;\n                for(let i = levelStartIndex; i < levelEndIndex; i++){\n                    if (i >= layers[level].length) {\n                        layers[level][i] = this.zeroes[level];\n                    }\n                }\n                index = Math.floor(index / this.arity);\n            }\n        }\n        layers.push([\n            this.root\n        ]);\n        return layers;\n    }\n    getHexLayers() {\n        return this.getLayers().reduce((acc, item)=>{\n            if (Array.isArray(item)) {\n                acc.push(item.map((layer)=>this.bufferToHex(this.bufferify(layer))));\n            } else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer)=>layer.map((value)=>this.bufferToHex(this.bufferify(value), false)));\n        const objs = [];\n        for(let i = 0; i < layers.length; i++){\n            const arr = [];\n            for(let j = 0; j < layers[i].length; j++){\n                const obj = {\n                    [layers[i][j]]: null\n                };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    computeRoot() {\n        let node;\n        let index = this.nodes[0].length;\n        for(let level = 0; level < this.depth; level += 1){\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            for(let i = levelStartIndex; i < levelEndIndex; i += 1){\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                } else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        return node;\n    }\n    getProof(index) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error(\"The leaf does not exist in this tree\");\n        }\n        const siblings = [];\n        const pathIndices = [];\n        const leafIndex = index;\n        for(let level = 0; level < this.depth; level += 1){\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            pathIndices[level] = position;\n            siblings[level] = [];\n            for(let i = levelStartIndex; i < levelEndIndex; i += 1){\n                if (i !== index) {\n                    if (i < this.nodes[level].length) {\n                        siblings[level].push(this.nodes[level][i]);\n                    } else {\n                        siblings[level].push(this.zeroes[level]);\n                    }\n                }\n            }\n            index = Math.floor(index / this.arity);\n        }\n        return {\n            root: this.root,\n            leaf: this.nodes[0][leafIndex],\n            pathIndices,\n            siblings\n        };\n    }\n    verify(proof) {\n        let node = proof.leaf;\n        for(let i = 0; i < proof.siblings.length; i += 1){\n            const children = proof.siblings[i].slice();\n            children.splice(proof.pathIndices[i], 0, node);\n            node = this.hashFn(children);\n        }\n        return proof.root === node;\n    }\n    toString() {\n        return this.toTreeString();\n    }\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n}\nexports.IncrementalMerkleTree = IncrementalMerkleTree;\nif (false) {}\nexports[\"default\"] = IncrementalMerkleTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvSW5jcmVtZW50YWxNZXJrbGVUcmVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyxTQUFTUixnQkFBZ0JTLG1CQUFPQSxDQUFDLDhEQUFRO0FBQy9DLE1BQU1DLFlBQVlWLGdCQUFnQlMsbUJBQU9BLENBQUMsd0RBQVM7QUFDbkQsTUFBTUYsOEJBQThCQyxPQUFPRyxPQUFPO0lBQzlDQyxZQUFZQyxNQUFNLEVBQUVDLE9BQU8sQ0FBRTtRQUN6QixLQUFLO1FBQ0wsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSUMsUUFBUUMsS0FBSyxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdELFFBQVFDLEtBQUs7UUFDOUI7UUFDQSxJQUFJRCxRQUFRRSxLQUFLLEVBQUU7WUFDZixJQUFJLENBQUNBLEtBQUssR0FBR0YsUUFBUUUsS0FBSztRQUM5QjtRQUNBLElBQUksSUFBSSxDQUFDRCxLQUFLLEdBQUcsR0FBRztZQUNoQixNQUFNLElBQUlFLE1BQU07UUFDcEI7UUFDQSxJQUFJLElBQUksQ0FBQ0QsS0FBSyxHQUFHLEdBQUc7WUFDaEIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsTUFBTUMsUUFBUSxFQUFFO1FBQ2hCLElBQUlDLFlBQVlMLFFBQVFLLFNBQVM7UUFDakMsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxJQUFJLENBQUNMLEtBQUssRUFBRTtZQUNaLElBQUss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QUFLO1FBQ3pDO1FBQ0EsT0FBTztZQUFFUyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUFFTSxNQUFNLElBQUksQ0FBQ2IsS0FBSyxDQUFDLEVBQUUsQ0FBQzhELFVBQVU7WUFBRUQ7WUFBYUQ7UUFBUztJQUNwRjtJQUNBRyxPQUFPQyxLQUFLLEVBQUU7UUFDVixJQUFJaEQsT0FBT2dELE1BQU1uRCxJQUFJO1FBQ3JCLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJNkQsTUFBTUosUUFBUSxDQUFDOUMsTUFBTSxFQUFFWCxLQUFLLEVBQUc7WUFDL0MsTUFBTW1CLFdBQVcwQyxNQUFNSixRQUFRLENBQUN6RCxFQUFFLENBQUM4RCxLQUFLO1lBQ3hDM0MsU0FBUzRDLE1BQU0sQ0FBQ0YsTUFBTUgsV0FBVyxDQUFDMUQsRUFBRSxFQUFFLEdBQUdhO1lBQ3pDQSxPQUFPLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQzJCO1FBQ3ZCO1FBQ0EsT0FBTzBDLE1BQU16RCxJQUFJLEtBQUtTO0lBQzFCO0lBQ0FtRCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUNDLFlBQVk7SUFDNUI7SUFDQUEsZUFBZTtRQUNYLE1BQU1qQixNQUFNLElBQUksQ0FBQ0osaUJBQWlCO1FBQ2xDLE9BQU92RCxVQUFVQyxPQUFPLENBQUM0RSxNQUFNLENBQUNsQixLQUFLO0lBQ3pDO0FBQ0o7QUFDQWhFLDZCQUE2QixHQUFHRTtBQUNoQyxJQUFJLEtBQWtCLEVBQWEsRUFHbEM7QUFDREYsa0JBQWUsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJrbGUvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvSW5jcmVtZW50YWxNZXJrbGVUcmVlLmpzPzVhNmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluY3JlbWVudGFsTWVya2xlVHJlZSA9IHZvaWQgMDtcbmNvbnN0IEJhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CYXNlXCIpKTtcbmNvbnN0IHRyZWVpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidHJlZWlmeVwiKSk7XG5jbGFzcyBJbmNyZW1lbnRhbE1lcmtsZVRyZWUgZXh0ZW5kcyBCYXNlXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoaGFzaEZuLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gaGFzaEZuO1xuICAgICAgICBpZiAob3B0aW9ucy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXJpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuYXJpdHkgPSBvcHRpb25zLmFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlcHRoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXB0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXJpdHkgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBsZXQgemVyb1ZhbHVlID0gb3B0aW9ucy56ZXJvVmFsdWU7XG4gICAgICAgIHRoaXMuemVyb1ZhbHVlID0gemVyb1ZhbHVlO1xuICAgICAgICB0aGlzLnplcm9lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnplcm9lcy5wdXNoKHplcm9WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICB6ZXJvVmFsdWUgPSB0aGlzLmhhc2hGbihBcnJheSh0aGlzLmFyaXR5KS5maWxsKHplcm9WYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5yb290ID0gemVyb1ZhbHVlO1xuICAgIH1cbiAgICBnZXRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICBnZXRIZXhSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmJ1ZmZlcmlmeSh0aGlzLmdldFJvb3QoKSkpO1xuICAgIH1cbiAgICBpbnNlcnQobGVhZikge1xuICAgICAgICBpZiAodGhpcy5kZXB0aCAmJiB0aGlzLmFyaXR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXS5sZW5ndGggPj0gdGhpcy5nZXRNYXhMZWF2ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJlZSBpcyBmdWxsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBsZWFmO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vZGVzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbbGV2ZWxdW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLm5vZGVzW2xldmVsXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLm5vZGVzW2xldmVsXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuemVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaEZuKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgfVxuICAgIGRlbGV0ZShpbmRleCkge1xuICAgICAgICB0aGlzLnVwZGF0ZShpbmRleCwgdGhpcy56ZXJvVmFsdWUpO1xuICAgIH1cbiAgICB1cGRhdGUoaW5kZXgsIG5ld0xlYWYpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm5vZGVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBuZXdMZWFmO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBsZXZlbFN0YXJ0SW5kZXggPSBpbmRleCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1tsZXZlbF1baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMubm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMubm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoRm4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0RGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgIH1cbiAgICBnZXRBcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJpdHk7XG4gICAgfVxuICAgIGdldE1heExlYXZlcygpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMuZGVwdGgsIHRoaXMuYXJpdHkpO1xuICAgIH1cbiAgICBpbmRleE9mKGxlYWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uaW5kZXhPZihsZWFmKTtcbiAgICB9XG4gICAgZ2V0TGVhdmVzKCkge1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmNvcHlMaXN0KHRoaXMubm9kZXNbMF0pO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubm9kZXNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLmdldE1heExlYXZlcygpOyBpKyspIHtcbiAgICAgICAgICAgIGxlYXZlc1tpXSA9IHRoaXMuemVyb1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWF2ZXM7XG4gICAgfVxuICAgIGNvcHlMaXN0KGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QubWFwKCh4KSA9PiBCaWdJbnQoeCkpO1xuICAgIH1cbiAgICBnZXRMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3Qgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgbGF5ZXJzLnB1c2godGhpcy5jb3B5TGlzdChsaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyc1swXS5sZW5ndGggPCB0aGlzLmdldE1heExlYXZlcygpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBsYXllcnNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy5nZXRNYXhMZWF2ZXMoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzWzBdW2ldID0gdGhpcy56ZXJvVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsU3RhcnRJbmRleCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsU3RhcnRJbmRleDsgaSA8IGxldmVsRW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBsYXllcnNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzW2xldmVsXVtpXSA9IHRoaXMuemVyb2VzW2xldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXllcnMucHVzaChbdGhpcy5yb290XSk7XG4gICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuICAgIGdldEhleExheWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzKCkucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goaXRlbS5tYXAobGF5ZXIgPT4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmJ1ZmZlcmlmeShsYXllcikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgZ2V0TGF5ZXJzQXNPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCkubWFwKChsYXllcikgPT4gbGF5ZXIubWFwKCh2YWx1ZSkgPT4gdGhpcy5idWZmZXJUb0hleCh0aGlzLmJ1ZmZlcmlmeSh2YWx1ZSksIGZhbHNlKSkpO1xuICAgICAgICBjb25zdCBvYmpzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGF5ZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0geyBbbGF5ZXJzW2ldW2pdXTogbnVsbCB9O1xuICAgICAgICAgICAgICAgIGlmIChvYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBha2V5ID0gT2JqZWN0LmtleXMoYSlbMF07XG4gICAgICAgICAgICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dW2FrZXldID0gYVtha2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmtleSA9IE9iamVjdC5rZXlzKGIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV1bYmtleV0gPSBiW2JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyci5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpzLnB1c2goLi4uYXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Jqc1swXTtcbiAgICB9XG4gICAgY29tcHV0ZVJvb3QoKSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vZGVzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMubm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMubm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoRm4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldFByb29mKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5ub2Rlc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxlYWYgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0aEluZGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGVhZkluZGV4ID0gaW5kZXg7XG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0aGlzLmRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGluZGV4ICUgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsU3RhcnRJbmRleCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBsZXZlbEVuZEluZGV4ID0gbGV2ZWxTdGFydEluZGV4ICsgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIHBhdGhJbmRpY2VzW2xldmVsXSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgc2libGluZ3NbbGV2ZWxdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0ucHVzaCh0aGlzLm5vZGVzW2xldmVsXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0ucHVzaCh0aGlzLnplcm9lc1tsZXZlbF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcm9vdDogdGhpcy5yb290LCBsZWFmOiB0aGlzLm5vZGVzWzBdW2xlYWZJbmRleF0sIHBhdGhJbmRpY2VzLCBzaWJsaW5ncyB9O1xuICAgIH1cbiAgICB2ZXJpZnkocHJvb2YpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBwcm9vZi5sZWFmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLnNpYmxpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb29mLnNpYmxpbmdzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UocHJvb2YucGF0aEluZGljZXNbaV0sIDAsIG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaEZuKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2Yucm9vdCA9PT0gbm9kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVHJlZVN0cmluZygpO1xuICAgIH1cbiAgICB0b1RyZWVTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuZ2V0TGF5ZXJzQXNPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIHRyZWVpZnlfMS5kZWZhdWx0LmFzVHJlZShvYmosIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5jcmVtZW50YWxNZXJrbGVUcmVlID0gSW5jcmVtZW50YWxNZXJrbGVUcmVlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgO1xuICAgIHdpbmRvdy5JbmNyZW1lbnRhbE1lcmtsZVRyZWUgPSBJbmNyZW1lbnRhbE1lcmtsZVRyZWU7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBJbmNyZW1lbnRhbE1lcmtsZVRyZWU7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW5jcmVtZW50YWxNZXJrbGVUcmVlIiwiQmFzZV8xIiwicmVxdWlyZSIsInRyZWVpZnlfMSIsImRlZmF1bHQiLCJjb25zdHJ1Y3RvciIsImhhc2hGbiIsIm9wdGlvbnMiLCJkZXB0aCIsImFyaXR5IiwiRXJyb3IiLCJub2RlcyIsInplcm9WYWx1ZSIsInplcm9lcyIsImkiLCJwdXNoIiwiQXJyYXkiLCJmaWxsIiwicm9vdCIsImdldFJvb3QiLCJnZXRIZXhSb290IiwiYnVmZmVyVG9IZXgiLCJidWZmZXJpZnkiLCJpbnNlcnQiLCJsZWFmIiwibGVuZ3RoIiwiZ2V0TWF4TGVhdmVzIiwibm9kZSIsImluZGV4IiwibGV2ZWwiLCJwb3NpdGlvbiIsImxldmVsU3RhcnRJbmRleCIsImxldmVsRW5kSW5kZXgiLCJjaGlsZHJlbiIsIk1hdGgiLCJmbG9vciIsImRlbGV0ZSIsInVwZGF0ZSIsIm5ld0xlYWYiLCJnZXREZXB0aCIsImdldEFyaXR5IiwicG93IiwiaW5kZXhPZiIsImdldExlYXZlcyIsImxlYXZlcyIsImNvcHlMaXN0IiwibGlzdCIsIm1hcCIsIngiLCJCaWdJbnQiLCJnZXRMYXllcnMiLCJsYXllcnMiLCJnZXRIZXhMYXllcnMiLCJyZWR1Y2UiLCJhY2MiLCJpdGVtIiwiaXNBcnJheSIsImxheWVyIiwiZ2V0TGF5ZXJzQXNPYmplY3QiLCJvYmpzIiwiYXJyIiwiaiIsIm9iaiIsImEiLCJzaGlmdCIsImFrZXkiLCJrZXlzIiwiYiIsImJrZXkiLCJjb21wdXRlUm9vdCIsImdldFByb29mIiwic2libGluZ3MiLCJwYXRoSW5kaWNlcyIsImxlYWZJbmRleCIsInZlcmlmeSIsInByb29mIiwic2xpY2UiLCJzcGxpY2UiLCJ0b1N0cmluZyIsInRvVHJlZVN0cmluZyIsImFzVHJlZSIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/IncrementalMerkleTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/MerkleMountainRange.js":
/*!***************************************************************!*\
  !*** ./node_modules/merkletreejs/dist/MerkleMountainRange.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst sha256_1 = __importDefault(__webpack_require__(/*! crypto-js/sha256 */ \"(ssr)/./node_modules/crypto-js/sha256.js\"));\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */ class MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn){\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves){\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */ append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for(let i = 0; i < peakIndexes.length; i++){\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */ hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([\n            this.bufferify(index),\n            dataHash\n        ]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */ hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([\n            this.bufferify(index),\n            this.bufferify(left),\n            this.bufferify(right)\n        ]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for(let i = 0; i < peakIndexes.length; i++){\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */ getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for(let i = 255; i > 0; i--){\n            if ((width & 1 << i - 1) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error(\"invalid bit calculation\");\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while(bits > 0){\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error(\"received invalid number of peaks\");\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([\n            this.bufferify(size),\n            ...peaks.map(this.bufferify)\n        ]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */ getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */ getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */ getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */ mountainHeight(size) {\n        let height = 1;\n        while(1 << height <= size + height){\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */ heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while(reducedIndex > peakIndex){\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */ isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */ getChildren(index) {\n        const left = index - (1 << this.heightAt(index) - 1);\n        const right = index - 1;\n        if (left === right) {\n            throw new Error(\"not a parent\");\n        }\n        return [\n            left,\n            right\n        ];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */ getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error(\"out of range\");\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error(\"not a leaf\");\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for(let i = 0; i < peaks.length; i++){\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while(cursor !== index){\n            height--;\n            [left, right] = this.getChildren(cursor);\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */ verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error(\"index is out of range\");\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error(\"invalid root hash from the peaks\");\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for(let i = 0; i < peakIndexes.length; i++){\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error(\"target not found\");\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while(height > 0){\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                break;\n            } else {\n                // on the parent node. Go left or right\n                [left, right] = this.getChildren(cursor);\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while(height < path.length){\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            } else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            } else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error(\"hashed peak is invalid\");\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for(let height = 1; height <= 32; height++){\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << height - 1;\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            } else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error(\"invalid number of peaks\");\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for(let i = 0; i < 32; i++){\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error(\"invalid number of peaks\");\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for(let height = 1; height <= 32; height++){\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            } else {\n                peakRef = 1 << height - 1;\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    } else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                } else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error(\"invalid root hash from the peaks\");\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for(let i = 0; i < itemHashes.length; i++){\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */ _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error(\"out of range\");\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nif (false) {}\nexports[\"default\"] = MerkleMountainRange;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlTW91bnRhaW5SYW5nZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHLEtBQUs7QUFDbkMsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsV0FBV1YsZ0JBQWdCUyxtQkFBT0EsQ0FBQyxrRUFBa0I7QUFDM0QsTUFBTUUsU0FBU1gsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw4REFBUTtBQUMvQyxtREFBbUQ7QUFDbkQ7O0NBRUMsR0FDRCxNQUFNRiw0QkFBNEJJLE9BQU9DLE9BQU87SUFDNUNDLFlBQVlDLFNBQVNKLFNBQVNFLE9BQU8sRUFBRUcsU0FBUyxFQUFFLEVBQUVDLFVBQVUsRUFBRUMsYUFBYSxFQUFFQyxZQUFZLENBQUU7UUFDekYsS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxTQUFTWSxNQUFNLENBQUNDLEtBQUssQ0FBQztRQUNsQyxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHLENBQUM7UUFDYlYsU0FBU0EsT0FBT1csR0FBRyxDQUFDLElBQUksQ0FBQ0MsU0FBUztRQUNsQyxJQUFJLENBQUNiLE1BQU0sR0FBRyxJQUFJLENBQUNjLFdBQVcsQ0FBQ2Q7UUFDL0IsSUFBSSxDQUFDRSxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUNDLFlBQVksR0FBR0E7UUFDcEIsS0FBSyxNQUFNVyxRQUFRZCxPQUFRO1lBQ3ZCLElBQUksQ0FBQ2UsTUFBTSxDQUFDRDtRQUNoQjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0RDLE9BQU9MLElBQUksRUFBRTtRQUNUQSxPQUFPLElBQUksQ0FBQ0UsU0FBUyxDQUFDRjtRQUN0QixNQUFNTSxXQUFXLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ1c7UUFDN0IsTUFBTU8sY0FBYyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0Y7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ04sSUFBSSxDQUFDTyxZQUFZLElBQUksSUFBSSxDQUFDQyxXQUFXLENBQUMsSUFBSSxDQUFDbkIsTUFBTSxDQUFDLElBQUksQ0FBQ1csSUFBSSxDQUFDTyxZQUFZLE9BQU9BLGFBQWE7WUFDbEcsSUFBSSxDQUFDUCxJQUFJLENBQUNPLFlBQVksR0FBR1A7UUFDN0I7UUFDQSxNQUFNSSxPQUFPLElBQUksQ0FBQ0ssUUFBUSxDQUFDLElBQUksQ0FBQ1osSUFBSSxHQUFHLEdBQUdTO1FBQzFDLElBQUksQ0FBQ1AsTUFBTSxDQUFDLElBQUksQ0FBQ0YsSUFBSSxHQUFHLEVBQUUsR0FBR087UUFDN0IsSUFBSSxDQUFDTixLQUFLLElBQUk7UUFDZCwrQkFBK0I7UUFDL0IsTUFBTVksY0FBYyxJQUFJLENBQUNDLGNBQWMsQ0FBQyxJQUFJLENBQUNiLEtBQUs7UUFDbEQsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQ2UsT0FBTyxDQUFDLElBQUksQ0FBQ2QsS0FBSztRQUNuQyx3REFBd0Q7UUFDeEQsTUFBTWUsUUFBUSxFQUFFO1FBQ2hCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixZQUFZSyxNQUFNLEVBQUVELElBQUs7WUFDekNELEtBQUssQ0FBQ0MsRUFBRSxHQUFHLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUNOLFdBQVcsQ0FBQ0ksRUFBRTtRQUNuRDtRQUNBLDRCQUE0QjtRQUM1QixJQUFJLENBQUNwQixJQUFJLEdBQUcsSUFBSSxDQUFDdUIsV0FBVyxDQUFDLElBQUksQ0FBQ25CLEtBQUssRUFBRWU7SUFDN0M7SUFDQTs7O0tBR0MsR0FDREosU0FBU1MsS0FBSyxFQUFFWixRQUFRLEVBQUU7UUFDdEJBLFdBQVcsSUFBSSxDQUFDSixTQUFTLENBQUNJO1FBQzFCLElBQUksSUFBSSxDQUFDZixVQUFVLEVBQUU7WUFDakIsT0FBTyxJQUFJLENBQUNXLFNBQVMsQ0FBQyxJQUFJLENBQUNYLFVBQVUsQ0FBQzJCLE9BQU9aO1FBQ2pEO1FBQ0EsT0FBTyxJQUFJLENBQUNqQixNQUFNLENBQUNOLFNBQVNZLE1BQU0sQ0FBQ3dCLE1BQU0sQ0FBQztZQUFDLElBQUksQ0FBQ2pCLFNBQVMsQ0FBQ2dCO1lBQVFaO1NBQVM7SUFDL0U7SUFDQTs7O0tBR0MsR0FDRGMsV0FBV0YsS0FBSyxFQUFFRyxJQUFJLEVBQUVDLEtBQUssRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQzdCLFlBQVksRUFBRTtZQUNuQixPQUFPLElBQUksQ0FBQ1MsU0FBUyxDQUFDLElBQUksQ0FBQ1QsWUFBWSxDQUFDeUIsT0FBT0csTUFBTUM7UUFDekQ7UUFDQSxPQUFPLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ04sU0FBU1ksTUFBTSxDQUFDd0IsTUFBTSxDQUFDO1lBQUMsSUFBSSxDQUFDakIsU0FBUyxDQUFDZ0I7WUFBUSxJQUFJLENBQUNoQixTQUFTLENBQUNtQjtZQUFPLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ29CO1NBQU87SUFDbEg7SUFDQUMsV0FBVztRQUNQLE1BQU1iLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUMsSUFBSSxDQUFDYixLQUFLO1FBQ2xELE1BQU1lLFFBQVEsRUFBRTtRQUNoQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosWUFBWUssTUFBTSxFQUFFRCxJQUFLO1lBQ3pDRCxLQUFLLENBQUNDLEVBQUUsR0FBRyxJQUFJLENBQUNmLE1BQU0sQ0FBQ1csV0FBVyxDQUFDSSxFQUFFLENBQUM7UUFDMUM7UUFDQSxPQUFPRDtJQUNYO0lBQ0FXLGFBQWExQixLQUFLLEVBQUU7UUFDaEIsSUFBSUEsUUFBUSxNQUFNLEdBQUc7WUFDakIsT0FBTyxJQUFJLENBQUNjLE9BQU8sQ0FBQ2Q7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ2MsT0FBTyxDQUFDZCxRQUFRLEtBQUs7SUFDckM7SUFDQTs7O0tBR0MsR0FDRGEsZUFBZWIsS0FBSyxFQUFFO1FBQ2xCLE1BQU0yQixXQUFXLElBQUksQ0FBQ0MsVUFBVSxDQUFDNUI7UUFDakMsTUFBTVksY0FBYyxFQUFFO1FBQ3RCLElBQUlpQixRQUFRO1FBQ1osSUFBSTlCLE9BQU87UUFDWCxJQUFLLElBQUlpQixJQUFJLEtBQUtBLElBQUksR0FBR0EsSUFBSztZQUMxQixJQUFJLENBQUNoQixRQUFTLEtBQU1nQixJQUFJLENBQUUsTUFBTyxHQUFHO2dCQUNoQyxjQUFjO2dCQUNkakIsT0FBT0EsT0FBUSxNQUFLaUIsQ0FBQUEsSUFBSztnQkFDekJKLFdBQVcsQ0FBQ2lCLFFBQVEsR0FBRzlCO2dCQUN2QixJQUFJYSxZQUFZSyxNQUFNLElBQUlVLFVBQVU7b0JBQ2hDO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUlFLFVBQVVqQixZQUFZSyxNQUFNLEVBQUU7WUFDOUIsTUFBTSxJQUFJYSxNQUFNO1FBQ3BCO1FBQ0EsT0FBT2xCO0lBQ1g7SUFDQWdCLFdBQVc1QixLQUFLLEVBQUU7UUFDZCxJQUFJK0IsT0FBTy9CO1FBQ1gsSUFBSWdDLE1BQU07UUFDVixNQUFPRCxPQUFPLEVBQUc7WUFDYixJQUFJQSxPQUFPLE1BQU0sR0FBRztnQkFDaEJDO1lBQ0o7WUFDQUQsT0FBT0EsUUFBUTtRQUNuQjtRQUNBLE9BQU9DO0lBQ1g7SUFDQWIsWUFBWW5CLEtBQUssRUFBRWUsS0FBSyxFQUFFO1FBQ3RCLE1BQU1oQixPQUFPLElBQUksQ0FBQ2UsT0FBTyxDQUFDZDtRQUMxQixJQUFJLElBQUksQ0FBQzRCLFVBQVUsQ0FBQzVCLFdBQVdlLE1BQU1FLE1BQU0sRUFBRTtZQUN6QyxNQUFNLElBQUlhLE1BQU07UUFDcEI7UUFDQSxJQUFJOUIsVUFBVSxLQUFLLENBQUNlLE1BQU1FLE1BQU0sRUFBRTtZQUM5QixPQUFPaEMsU0FBU1ksTUFBTSxDQUFDQyxLQUFLLENBQUM7UUFDakM7UUFDQSxJQUFJLElBQUksQ0FBQ0osYUFBYSxFQUFFO1lBQ3BCLE9BQU8sSUFBSSxDQUFDVSxTQUFTLENBQUMsSUFBSSxDQUFDVixhQUFhLENBQUNLLE1BQU1nQjtRQUNuRDtRQUNBLE9BQU8sSUFBSSxDQUFDeEIsTUFBTSxDQUFDTixTQUFTWSxNQUFNLENBQUN3QixNQUFNLENBQUM7WUFBQyxJQUFJLENBQUNqQixTQUFTLENBQUNMO2VBQVVnQixNQUFNWixHQUFHLENBQUMsSUFBSSxDQUFDQyxTQUFTO1NBQUU7SUFDbEc7SUFDQTs7S0FFQyxHQUNEVSxRQUFRZCxLQUFLLEVBQUU7UUFDWCxPQUFPLENBQUNBLFNBQVMsS0FBSyxJQUFJLENBQUM0QixVQUFVLENBQUM1QjtJQUMxQztJQUNBOztLQUVDLEdBQ0RpQyxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNyQyxJQUFJO0lBQ3BCO0lBQ0FzQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUN4QixXQUFXLENBQUMsSUFBSSxDQUFDdUIsT0FBTztJQUN4QztJQUNBOztLQUVDLEdBQ0RFLFFBQVFmLEtBQUssRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDbkIsTUFBTSxDQUFDbUIsTUFBTTtJQUM3QjtJQUNBOztLQUVDLEdBQ0RnQixlQUFlckMsSUFBSSxFQUFFO1FBQ2pCLElBQUlzQyxTQUFTO1FBQ2IsTUFBTyxLQUFLQSxVQUFVdEMsT0FBT3NDLE9BQVE7WUFDakNBO1FBQ0o7UUFDQSxPQUFPQSxTQUFTO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsU0FBU2xCLEtBQUssRUFBRTtRQUNaLElBQUltQixlQUFlbkI7UUFDbkIsSUFBSW9CLFlBQVk7UUFDaEIsSUFBSUgsU0FBUztRQUNiLDZEQUE2RDtRQUM3RCxNQUFPRSxlQUFlQyxVQUFXO1lBQzdCRCxnQkFBZ0IsQ0FBQyxLQUFLRixNQUFLLElBQUs7WUFDaENBLFNBQVMsSUFBSSxDQUFDRCxjQUFjLENBQUNHO1lBQzdCQyxZQUFZLENBQUMsS0FBS0gsTUFBSyxJQUFLO1FBQ2hDO1FBQ0EsOEJBQThCO1FBQzlCLE9BQU9BLFNBQVVHLENBQUFBLFlBQVlELFlBQVc7SUFDNUM7SUFDQTs7S0FFQyxHQUNERSxPQUFPckIsS0FBSyxFQUFFO1FBQ1YsT0FBTyxJQUFJLENBQUNrQixRQUFRLENBQUNsQixXQUFXO0lBQ3BDO0lBQ0E7O0tBRUMsR0FDRHNCLFlBQVl0QixLQUFLLEVBQUU7UUFDZixNQUFNRyxPQUFPSCxRQUFTLE1BQU0sSUFBSSxDQUFDa0IsUUFBUSxDQUFDbEIsU0FBUyxDQUFDO1FBQ3BELE1BQU1JLFFBQVFKLFFBQVE7UUFDdEIsSUFBSUcsU0FBU0MsT0FBTztZQUNoQixNQUFNLElBQUlNLE1BQU07UUFDcEI7UUFDQSxPQUFPO1lBQUNQO1lBQU1DO1NBQU07SUFDeEI7SUFDQTs7S0FFQyxHQUNEbUIsZUFBZXZCLEtBQUssRUFBRTtRQUNsQixJQUFJQSxRQUFRLElBQUksQ0FBQ3JCLElBQUksRUFBRTtZQUNuQixNQUFNLElBQUkrQixNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1csTUFBTSxDQUFDckIsUUFBUTtZQUNyQixNQUFNLElBQUlVLE1BQU07UUFDcEI7UUFDQSxNQUFNbEMsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTUksUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDeEIsNkJBQTZCO1FBQzdCLE1BQU1lLFFBQVEsSUFBSSxDQUFDRixjQUFjLENBQUMsSUFBSSxDQUFDYixLQUFLO1FBQzVDLE1BQU1tQixjQUFjLEVBQUU7UUFDdEIsSUFBSXlCLFNBQVM7UUFDYixJQUFLLElBQUk1QixJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztZQUNuQyxnQ0FBZ0M7WUFDaENHLFdBQVcsQ0FBQ0gsRUFBRSxHQUFHLElBQUksQ0FBQ2YsTUFBTSxDQUFDYyxLQUFLLENBQUNDLEVBQUUsQ0FBQztZQUN0QyxnREFBZ0Q7WUFDaEQsSUFBSUQsS0FBSyxDQUFDQyxFQUFFLElBQUlJLFNBQVN3QixXQUFXLEdBQUc7Z0JBQ25DQSxTQUFTN0IsS0FBSyxDQUFDQyxFQUFFO1lBQ3JCO1FBQ0o7UUFDQSxJQUFJTyxPQUFPO1FBQ1gsSUFBSUMsUUFBUTtRQUNaLHlFQUF5RTtRQUN6RSwrRUFBK0U7UUFDL0UsSUFBSWEsU0FBUyxJQUFJLENBQUNDLFFBQVEsQ0FBQ007UUFDM0IsTUFBTUMsV0FBVyxFQUFFO1FBQ25CLE1BQU9ELFdBQVd4QixNQUFPO1lBQ3JCaUI7WUFDQyxDQUFDZCxNQUFNQyxNQUFNLEdBQUcsSUFBSSxDQUFDa0IsV0FBVyxDQUFDRTtZQUNsQyxzREFBc0Q7WUFDdERBLFNBQVN4QixTQUFTRyxPQUFPQSxPQUFPQztZQUNoQyxnQ0FBZ0M7WUFDaENxQixRQUFRLENBQUNSLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQ3BDLE1BQU0sQ0FBQ21CLFNBQVNHLE9BQU9DLFFBQVFELEtBQUs7UUFDcEU7UUFDQSxPQUFPO1lBQ0gzQjtZQUNBSTtZQUNBbUI7WUFDQTBCO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0RDLE9BQU9sRCxJQUFJLEVBQUVJLEtBQUssRUFBRW9CLEtBQUssRUFBRXJDLEtBQUssRUFBRWdDLEtBQUssRUFBRThCLFFBQVEsRUFBRTtRQUMvQzlELFFBQVEsSUFBSSxDQUFDcUIsU0FBUyxDQUFDckI7UUFDdkIsTUFBTWdCLE9BQU8sSUFBSSxDQUFDZSxPQUFPLENBQUNkO1FBQzFCLElBQUlELE9BQU9xQixPQUFPO1lBQ2QsTUFBTSxJQUFJVSxNQUFNO1FBQ3BCO1FBQ0EsOENBQThDO1FBQzlDLElBQUksQ0FBQ2xDLEtBQUttRCxNQUFNLENBQUMsSUFBSSxDQUFDNUIsV0FBVyxDQUFDbkIsT0FBT2UsU0FBUztZQUM5QyxNQUFNLElBQUllLE1BQU07UUFDcEI7UUFDQSxzREFBc0Q7UUFDdEQsSUFBSWMsU0FBUztRQUNiLElBQUlJO1FBQ0osTUFBTXBDLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNiO1FBQ3hDLElBQUssSUFBSWdCLElBQUksR0FBR0EsSUFBSUosWUFBWUssTUFBTSxFQUFFRCxJQUFLO1lBQ3pDLElBQUlKLFdBQVcsQ0FBQ0ksRUFBRSxJQUFJSSxPQUFPO2dCQUN6QjRCLGFBQWFqQyxLQUFLLENBQUNDLEVBQUU7Z0JBQ3JCNEIsU0FBU2hDLFdBQVcsQ0FBQ0ksRUFBRTtnQkFDdkI7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDZ0MsWUFBWTtZQUNiLE1BQU0sSUFBSWxCLE1BQU07UUFDcEI7UUFDQSw4QkFBOEI7UUFDOUIsSUFBSU8sU0FBU1EsU0FBUzVCLE1BQU0sR0FBRztRQUMvQixNQUFNZ0MsT0FBTyxJQUFJQyxNQUFNYjtRQUN2QixJQUFJZCxPQUFPO1FBQ1gsSUFBSUMsUUFBUTtRQUNaLE1BQU9hLFNBQVMsRUFBRztZQUNmLDJDQUEyQztZQUMzQ1ksSUFBSSxDQUFDLEVBQUVaLE9BQU8sR0FBR087WUFDakIsSUFBSUEsV0FBV3hCLE9BQU87Z0JBRWxCO1lBQ0osT0FDSztnQkFDRCx1Q0FBdUM7Z0JBQ3RDLENBQUNHLE1BQU1DLE1BQU0sR0FBRyxJQUFJLENBQUNrQixXQUFXLENBQUNFO2dCQUNsQ0EsU0FBU3hCLFFBQVFHLE9BQU9DLFFBQVFEO2dCQUNoQztZQUNKO1FBQ0o7UUFDQSw4Q0FBOEM7UUFDOUMsSUFBSTRCO1FBQ0osTUFBT2QsU0FBU1ksS0FBS2hDLE1BQU0sQ0FBRTtZQUN6QixjQUFjO1lBQ2QyQixTQUFTSyxJQUFJLENBQUNaLE9BQU87WUFDckIsSUFBSUEsV0FBVyxHQUFHO2dCQUNkLHVCQUF1QjtnQkFDdkJjLE9BQU8sSUFBSSxDQUFDeEMsUUFBUSxDQUFDaUMsUUFBUSxJQUFJLENBQUNyRCxNQUFNLENBQUNSO1lBQzdDLE9BQ0ssSUFBSTZELFNBQVMsTUFBTUssSUFBSSxDQUFDWixTQUFTLEVBQUUsRUFBRTtnQkFDdEMsc0RBQXNEO2dCQUN0RGMsT0FBTyxJQUFJLENBQUM3QixVQUFVLENBQUNzQixRQUFRQyxRQUFRLENBQUNSLFNBQVMsRUFBRSxFQUFFYztZQUN6RCxPQUNLO2dCQUNELHVEQUF1RDtnQkFDdkRBLE9BQU8sSUFBSSxDQUFDN0IsVUFBVSxDQUFDc0IsUUFBUU8sTUFBTU4sUUFBUSxDQUFDUixTQUFTLEVBQUU7WUFDN0Q7WUFDQSxXQUFXO1lBQ1hBO1FBQ0o7UUFDQSx5RUFBeUU7UUFDekUsSUFBSSxDQUFDYyxLQUFLSixNQUFNLENBQUNDLGFBQWE7WUFDMUIsTUFBTSxJQUFJbEIsTUFBTTtRQUNwQjtRQUNBLE9BQU87SUFDWDtJQUNBc0IsZUFBZXBELEtBQUssRUFBRWUsS0FBSyxFQUFFO1FBQ3pCLE1BQU1zQyxVQUFVLENBQUM7UUFDakIsSUFBSUMsV0FBVztRQUNmLElBQUlDLFVBQVU7UUFDZCxJQUFJMUIsUUFBUWQsTUFBTUUsTUFBTTtRQUN4QixJQUFLLElBQUlvQixTQUFTLEdBQUdBLFVBQVUsSUFBSUEsU0FBVTtZQUN6Qyx1Q0FBdUM7WUFDdkNpQixXQUFXLEtBQUtqQjtZQUNoQmtCLFVBQVUsS0FBTWxCLFNBQVM7WUFDekIsSUFBSSxDQUFDckMsUUFBUXVELE9BQU0sTUFBTyxHQUFHO2dCQUN6QkYsT0FBTyxDQUFDQyxTQUFTLEdBQUd2QyxLQUFLLENBQUMsRUFBRWMsTUFBTTtZQUN0QyxPQUNLO2dCQUNEd0IsT0FBTyxDQUFDQyxTQUFTLEdBQUc7WUFDeEI7UUFDSjtRQUNBLElBQUl6QixVQUFVLEdBQUc7WUFDYixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxPQUFPdUI7SUFDWDtJQUNBRyxlQUFleEQsS0FBSyxFQUFFcUQsT0FBTyxFQUFFO1FBQzNCLE1BQU1JLFlBQVksSUFBSSxDQUFDN0IsVUFBVSxDQUFDNUI7UUFDbEMsTUFBTWUsUUFBUSxJQUFJbUMsTUFBTU87UUFDeEIsSUFBSTVCLFFBQVE7UUFDWixJQUFLLElBQUliLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1lBQ3pCLElBQUlxQyxPQUFPLENBQUNyQyxFQUFFLEtBQUssR0FBRztnQkFDbEJELEtBQUssQ0FBQ2MsUUFBUSxHQUFHd0IsT0FBTyxDQUFDckMsRUFBRTtZQUMvQjtRQUNKO1FBQ0EsSUFBSWEsVUFBVTRCLFdBQVc7WUFDckIsTUFBTSxJQUFJM0IsTUFBTTtRQUNwQjtRQUNBLE9BQU9mO0lBQ1g7SUFDQTJDLFdBQVcxRCxLQUFLLEVBQUUyRCxXQUFXLEVBQUVDLFFBQVEsRUFBRTtRQUNyQyxNQUFNQyxjQUFjLENBQUM7UUFDckIsTUFBTUMsV0FBVzlELFFBQVE7UUFDekIsSUFBSStELGNBQWMsSUFBSSxDQUFDckMsWUFBWSxDQUFDb0M7UUFDcEMsSUFBSUUsYUFBYSxJQUFJLENBQUNyRCxRQUFRLENBQUNvRCxhQUFhSDtRQUM1QyxJQUFJTixXQUFXO1FBQ2YsSUFBSUMsVUFBVTtRQUNkLElBQUlVLGdCQUFnQjtRQUNwQixJQUFJQyxnQkFBZ0I7UUFDcEIsSUFBSUMsV0FBVztRQUNmLElBQUssSUFBSTlCLFNBQVMsR0FBR0EsVUFBVSxJQUFJQSxTQUFVO1lBQ3pDLHVDQUF1QztZQUN2Q2lCLFdBQVcsS0FBS2pCO1lBQ2hCLElBQUk4QixVQUFVO2dCQUNWTixXQUFXLENBQUNQLFNBQVMsR0FBR0ssV0FBVyxDQUFDTCxTQUFTO1lBQ2pELE9BQ0s7Z0JBQ0RDLFVBQVUsS0FBTWxCLFNBQVM7Z0JBQ3pCNEIsZ0JBQWdCLENBQUNqRSxRQUFRdUQsT0FBTSxNQUFPO2dCQUN0Q1csZ0JBQWdCLENBQUNKLFdBQVdQLE9BQU0sTUFBTztnQkFDekMsbUVBQW1FO2dCQUNuRVE7Z0JBQ0EsSUFBSUUsZUFBZTtvQkFDZkQsYUFBYSxJQUFJLENBQUMxQyxVQUFVLENBQUN5QyxhQUFhSixXQUFXLENBQUNMLFNBQVMsRUFBRVU7Z0JBQ3JFO2dCQUNBLHVDQUF1QztnQkFDdkMsSUFBSUUsZUFBZTtvQkFDZix3Q0FBd0M7b0JBQ3hDLElBQUlELGVBQWU7d0JBQ2ZKLFdBQVcsQ0FBQ1AsU0FBUyxHQUFHSyxXQUFXLENBQUNMLFNBQVM7b0JBQ2pELE9BQ0s7d0JBQ0RPLFdBQVcsQ0FBQ1AsU0FBUyxHQUFHVTtvQkFDNUI7b0JBQ0FHLFdBQVc7Z0JBQ2YsT0FDSztvQkFDRE4sV0FBVyxDQUFDUCxTQUFTLEdBQUc7Z0JBQzVCO1lBQ0o7UUFDSjtRQUNBLE9BQU9PO0lBQ1g7SUFDQU8sT0FBT3hFLElBQUksRUFBRUksS0FBSyxFQUFFZSxLQUFLLEVBQUVzRCxVQUFVLEVBQUU7UUFDbkMsOENBQThDO1FBQzlDLElBQUksQ0FBQ3pFLEtBQUttRCxNQUFNLENBQUMsSUFBSSxDQUFDNUIsV0FBVyxDQUFDbkIsT0FBT2UsU0FBUztZQUM5QyxNQUFNLElBQUllLE1BQU07UUFDcEI7UUFDQSxJQUFJd0MsV0FBV3RFO1FBQ2YsSUFBSXVFLGFBQWEsSUFBSSxDQUFDbkIsY0FBYyxDQUFDcEQsT0FBT2U7UUFDNUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlxRCxXQUFXcEQsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDdUQsYUFBYSxJQUFJLENBQUNiLFVBQVUsQ0FBQ1ksVUFBVUMsWUFBWUYsVUFBVSxDQUFDckQsRUFBRTtZQUNoRXNEO1FBQ0o7UUFDQSxPQUFPLElBQUksQ0FBQ25ELFdBQVcsQ0FBQ21ELFVBQVUsSUFBSSxDQUFDZCxjQUFjLENBQUNjLFVBQVVDO0lBQ3BFO0lBQ0E7Ozs7O0tBS0MsR0FDRHJELGlCQUFpQkUsS0FBSyxFQUFFO1FBQ3BCLElBQUlBLFFBQVEsSUFBSSxDQUFDckIsSUFBSSxFQUFFO1lBQ25CLE1BQU0sSUFBSStCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDN0IsTUFBTSxDQUFDbUIsTUFBTSxFQUFFO1lBQ3JCLE1BQU0sQ0FBQ29ELFdBQVdDLFdBQVcsR0FBRyxJQUFJLENBQUMvQixXQUFXLENBQUN0QjtZQUNqRCxNQUFNc0QsV0FBVyxJQUFJLENBQUN4RCxnQkFBZ0IsQ0FBQ3NEO1lBQ3ZDLE1BQU1HLFlBQVksSUFBSSxDQUFDekQsZ0JBQWdCLENBQUN1RDtZQUN4QyxJQUFJLENBQUN4RSxNQUFNLENBQUNtQixNQUFNLEdBQUcsSUFBSSxDQUFDRSxVQUFVLENBQUNGLE9BQU9zRCxVQUFVQztRQUMxRDtRQUNBLE9BQU8sSUFBSSxDQUFDMUUsTUFBTSxDQUFDbUIsTUFBTTtJQUM3QjtBQUNKO0FBQ0F0QywyQkFBMkIsR0FBR0U7QUFDOUIsSUFBSSxLQUFrQixFQUFhLEVBR2xDO0FBQ0RGLGtCQUFlLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVya2xlLy4vbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZU1vdW50YWluUmFuZ2UuanM/ZDM1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVya2xlTW91bnRhaW5SYW5nZSA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG8tanMvc2hhMjU2XCIpKTtcbmNvbnN0IEJhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CYXNlXCIpKTtcbi8vIEBjcmVkaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS93YW5zZW9iL3NvbGlkaXR5LW1tclxuLyoqXG4gKiBAZGVzYyBUaGUgaW5kZXggb2YgdGhpcyBNTVIgaW1wbGVtZW50YXRpb24gc3RhcnRzIGZyb20gMSBub3QgMC5cbiAqL1xuY2xhc3MgTWVya2xlTW91bnRhaW5SYW5nZSBleHRlbmRzIEJhc2VfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoRm4gPSBzaGEyNTZfMS5kZWZhdWx0LCBsZWF2ZXMgPSBbXSwgaGFzaExlYWZGbiwgcGVha0JhZ2dpbmdGbiwgaGFzaEJyYW5jaEZuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGFzaGVzID0ge307XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKHRoaXMuYnVmZmVyaWZ5KTtcbiAgICAgICAgdGhpcy5oYXNoRm4gPSB0aGlzLmJ1ZmZlcmlmeUZuKGhhc2hGbik7XG4gICAgICAgIHRoaXMuaGFzaExlYWZGbiA9IGhhc2hMZWFmRm47XG4gICAgICAgIHRoaXMucGVha0JhZ2dpbmdGbiA9IHBlYWtCYWdnaW5nRm47XG4gICAgICAgIHRoaXMuaGFzaEJyYW5jaEZuID0gaGFzaEJyYW5jaEZuO1xuICAgICAgICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChsZWFmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBUaGlzIG9ubHkgc3RvcmVzIHRoZSBoYXNoZWQgdmFsdWUgb2YgdGhlIGxlYWYuXG4gICAgICogSWYgeW91IG5lZWQgdG8gcmV0cmlldmUgdGhlIGRldGFpbCBkYXRhIGxhdGVyLCB1c2UgYSBtYXAgdG8gc3RvcmUgdGhlbS5cbiAgICAgKi9cbiAgICBhcHBlbmQoZGF0YSkge1xuICAgICAgICBkYXRhID0gdGhpcy5idWZmZXJpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGRhdGFIYXNoID0gdGhpcy5oYXNoRm4oZGF0YSk7XG4gICAgICAgIGNvbnN0IGRhdGFIYXNoSGV4ID0gdGhpcy5idWZmZXJUb0hleChkYXRhSGFzaCk7XG4gICAgICAgIGlmICghdGhpcy5kYXRhW2RhdGFIYXNoSGV4XSB8fCB0aGlzLmJ1ZmZlclRvSGV4KHRoaXMuaGFzaEZuKHRoaXMuZGF0YVtkYXRhSGFzaEhleF0pKSAhPT0gZGF0YUhhc2hIZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtkYXRhSGFzaEhleF0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmhhc2hMZWFmKHRoaXMuc2l6ZSArIDEsIGRhdGFIYXNoKTtcbiAgICAgICAgdGhpcy5oYXNoZXNbdGhpcy5zaXplICsgMV0gPSBsZWFmO1xuICAgICAgICB0aGlzLndpZHRoICs9IDE7XG4gICAgICAgIC8vIGZpbmQgcGVha3MgZm9yIGVubGFyZ2VkIHRyZWVcbiAgICAgICAgY29uc3QgcGVha0luZGV4ZXMgPSB0aGlzLmdldFBlYWtJbmRleGVzKHRoaXMud2lkdGgpO1xuICAgICAgICAvLyB0aGUgcmlnaHQgbW9zdCBwZWFrJ3MgdmFsdWUgaXMgdGhlIG5ldyBzaXplIG9mIHRoZSB1cGRhdGVkIHRyZWVcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5nZXRTaXplKHRoaXMud2lkdGgpO1xuICAgICAgICAvLyBzdGFydGluZyBmcm9tIHRoZSBsZWZ0LW1vc3QgcGVhaywgZ2V0IGFsbCBwZWFrIGhhc2hlc1xuICAgICAgICBjb25zdCBwZWFrcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlYWtJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwZWFrc1tpXSA9IHRoaXMuX2dldE9yQ3JlYXRlTm9kZShwZWFrSW5kZXhlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0cmVlIHJvb3QgaGFzaFxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnBlYWtCYWdnaW5nKHRoaXMud2lkdGgsIHBlYWtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgaGFzaCBvZiBhIGxlYWYgbm9kZSB3aXRoIGhhc2goTSB8IERBVEEgKVxuICAgICAqICAgICAgIE0gaXMgdGhlIGluZGV4IG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGhhc2hMZWFmKGluZGV4LCBkYXRhSGFzaCkge1xuICAgICAgICBkYXRhSGFzaCA9IHRoaXMuYnVmZmVyaWZ5KGRhdGFIYXNoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzaExlYWZGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyaWZ5KHRoaXMuaGFzaExlYWZGbihpbmRleCwgZGF0YUhhc2gpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNoRm4oYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXJpZnkoaW5kZXgpLCBkYXRhSGFzaF0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgaGFzaCBhIHBhcmVudCBub2RlIHdpdGggaGFzaChNIHwgTGVmdCBjaGlsZCB8IFJpZ2h0IGNoaWxkKVxuICAgICAqICAgICAgIE0gaXMgdGhlIGluZGV4IG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGhhc2hCcmFuY2goaW5kZXgsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc2hCcmFuY2hGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyaWZ5KHRoaXMuaGFzaEJyYW5jaEZuKGluZGV4LCBsZWZ0LCByaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hGbihidWZmZXJfMS5CdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlcmlmeShpbmRleCksIHRoaXMuYnVmZmVyaWZ5KGxlZnQpLCB0aGlzLmJ1ZmZlcmlmeShyaWdodCldKSk7XG4gICAgfVxuICAgIGdldFBlYWtzKCkge1xuICAgICAgICBjb25zdCBwZWFrSW5kZXhlcyA9IHRoaXMuZ2V0UGVha0luZGV4ZXModGhpcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IHBlYWtzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVha0luZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBlYWtzW2ldID0gdGhpcy5oYXNoZXNbcGVha0luZGV4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZWFrcztcbiAgICB9XG4gICAgZ2V0TGVhZkluZGV4KHdpZHRoKSB7XG4gICAgICAgIGlmICh3aWR0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpemUod2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpemUod2lkdGggLSAxKSArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgYWxsIHBlYWtzIG9mIHRoZSBzbWFsbGVzdCBtZXJrbGUgbW91bnRhaW4gcmFuZ2UgdHJlZSB3aGljaCBpbmNsdWRlc1xuICAgICAqICAgICAgIHRoZSBnaXZlbiBpbmRleChzaXplKS5cbiAgICAgKi9cbiAgICBnZXRQZWFrSW5kZXhlcyh3aWR0aCkge1xuICAgICAgICBjb25zdCBudW1QZWFrcyA9IHRoaXMubnVtT2ZQZWFrcyh3aWR0aCk7XG4gICAgICAgIGNvbnN0IHBlYWtJbmRleGVzID0gW107XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI1NTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCh3aWR0aCAmICgxIDw8IChpIC0gMSkpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHBlYWsgZXhpc3RzXG4gICAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgKyAoMSA8PCBpKSAtIDE7XG4gICAgICAgICAgICAgICAgcGVha0luZGV4ZXNbY291bnQrK10gPSBzaXplO1xuICAgICAgICAgICAgICAgIGlmIChwZWFrSW5kZXhlcy5sZW5ndGggPj0gbnVtUGVha3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCAhPT0gcGVha0luZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYml0IGNhbGN1bGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlYWtJbmRleGVzO1xuICAgIH1cbiAgICBudW1PZlBlYWtzKHdpZHRoKSB7XG4gICAgICAgIGxldCBiaXRzID0gd2lkdGg7XG4gICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICB3aGlsZSAoYml0cyA+IDApIHtcbiAgICAgICAgICAgIGlmIChiaXRzICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG51bSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyA9IGJpdHMgPj4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBwZWFrQmFnZ2luZyh3aWR0aCwgcGVha3MpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSh3aWR0aCk7XG4gICAgICAgIGlmICh0aGlzLm51bU9mUGVha3Mod2lkdGgpICE9PSBwZWFrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjZWl2ZWQgaW52YWxpZCBudW1iZXIgb2YgcGVha3MnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPT09IDAgJiYgIXBlYWtzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZWFrQmFnZ2luZ0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJpZnkodGhpcy5wZWFrQmFnZ2luZ0ZuKHNpemUsIHBlYWtzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaEZuKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmZmVyaWZ5KHNpemUpLCAuLi5wZWFrcy5tYXAodGhpcy5idWZmZXJpZnkpXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGdldFNpemUod2lkdGgpIHtcbiAgICAgICAgcmV0dXJuICh3aWR0aCA8PCAxKSAtIHRoaXMubnVtT2ZQZWFrcyh3aWR0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIHJvb3QgdmFsdWUgb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0Um9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9XG4gICAgZ2V0SGV4Um9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyVG9IZXgodGhpcy5nZXRSb290KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGV2IEl0IHJldHVybnMgdGhlIGhhc2ggdmFsdWUgb2YgYSBub2RlIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24uIE5vdGUgdGhhdCB0aGUgaW5kZXggc3RhcnRzIGZyb20gMS5cbiAgICAgKi9cbiAgICBnZXROb2RlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hlc1tpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgaGlnaGVzdCBwZWFrLlxuICAgICAqL1xuICAgIG1vdW50YWluSGVpZ2h0KHNpemUpIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IDE7XG4gICAgICAgIHdoaWxlICgxIDw8IGhlaWdodCA8PSBzaXplICsgaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVpZ2h0IC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBpbmRleC5cbiAgICAgKi9cbiAgICBoZWlnaHRBdChpbmRleCkge1xuICAgICAgICBsZXQgcmVkdWNlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCBwZWFrSW5kZXggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgLy8gaWYgYW4gaW5kZXggaGFzIGEgbGVmdCBtb3VudGFpbiB0aGVuIHN1YnRyYWN0IHRoZSBtb3VudGFpblxuICAgICAgICB3aGlsZSAocmVkdWNlZEluZGV4ID4gcGVha0luZGV4KSB7XG4gICAgICAgICAgICByZWR1Y2VkSW5kZXggLT0gKDEgPDwgaGVpZ2h0KSAtIDE7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm1vdW50YWluSGVpZ2h0KHJlZHVjZWRJbmRleCk7XG4gICAgICAgICAgICBwZWFrSW5kZXggPSAoMSA8PCBoZWlnaHQpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmRleCBpcyBvbiB0aGUgcmlnaHQgc2xvcGVcbiAgICAgICAgcmV0dXJuIGhlaWdodCAtIChwZWFrSW5kZXggLSByZWR1Y2VkSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHdoZXRoZXIgdGhlIGluZGV4IGlzIHRoZSBsZWFmIG5vZGUgb3Igbm90XG4gICAgICovXG4gICAgaXNMZWFmKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodEF0KGluZGV4KSA9PT0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgY2hpbGRyZW4gd2hlbiBpdCBpcyBhIHBhcmVudCBub2RlLlxuICAgICAqL1xuICAgIGdldENoaWxkcmVuKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBpbmRleCAtICgxIDw8ICh0aGlzLmhlaWdodEF0KGluZGV4KSAtIDEpKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBpbmRleCAtIDE7XG4gICAgICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSBwYXJlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyBhIG1lcmtsZSBwcm9vZiBmb3IgYSBsZWFmLiBOb3RlIHRoYXQgdGhlIGluZGV4IHN0YXJ0cyBmcm9tIDEuXG4gICAgICovXG4gICAgZ2V0TWVya2xlUHJvb2YoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0xlYWYoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIGxlYWYnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290ID0gdGhpcy5yb290O1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIC8vIGZpbmQgYWxsIHBlYWtzIGZvciBiYWdnaW5nXG4gICAgICAgIGNvbnN0IHBlYWtzID0gdGhpcy5nZXRQZWFrSW5kZXhlcyh0aGlzLndpZHRoKTtcbiAgICAgICAgY29uc3QgcGVha0JhZ2dpbmcgPSBbXTtcbiAgICAgICAgbGV0IGN1cnNvciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVha3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIGhhc2ggb2YgYWxsIHBlYWtzXG4gICAgICAgICAgICBwZWFrQmFnZ2luZ1tpXSA9IHRoaXMuaGFzaGVzW3BlYWtzW2ldXTtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBlYWsgd2hpY2ggaW5jbHVkZXMgdGhlIHRhcmdldCBpbmRleFxuICAgICAgICAgICAgaWYgKHBlYWtzW2ldID49IGluZGV4ICYmIGN1cnNvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IHBlYWtzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgbGV0IHJpZ2h0ID0gMDtcbiAgICAgICAgLy8gZ2V0IGhhc2hlcyBvZiB0aGUgc2libGluZ3MgaW4gdGhlIG1vdW50YWluIHdoaWNoIHRoZSBpbmRleCBiZWxnb25zIHRvLlxuICAgICAgICAvLyBpdCBtb3ZlcyB0aGUgY3Vyc29yIGZyb20gdGhlIHN1bW1pdCBvZiB0aGUgbW91bnRhaW4gZG93biB0byB0aGUgdGFyZ2V0IGluZGV4XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmhlaWdodEF0KGN1cnNvcik7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgIHdoaWxlIChjdXJzb3IgIT09IGluZGV4KSB7XG4gICAgICAgICAgICBoZWlnaHQtLTtcbiAgICAgICAgICAgIChbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRDaGlsZHJlbihjdXJzb3IpKTtcbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIGN1cnNvciBkb3duIHRvIHRoZSBsZWZ0IHNpemUgb3IgcmlnaHQgc2l6ZVxuICAgICAgICAgICAgY3Vyc29yID0gaW5kZXggPD0gbGVmdCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgICAgIC8vIHJlbWFpbmluZyBub2RlIGlzIHRoZSBzaWJsaW5nXG4gICAgICAgICAgICBzaWJsaW5nc1toZWlnaHQgLSAxXSA9IHRoaXMuaGFzaGVzW2luZGV4IDw9IGxlZnQgPyByaWdodCA6IGxlZnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBwZWFrQmFnZ2luZyxcbiAgICAgICAgICAgIHNpYmxpbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdHJ1ZSB3aGVuIHRoZSBnaXZlbiBwYXJhbXMgdmVyaWZpZXMgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgZXhpc3RzIGluIHRoZSB0cmVlIG9yIHJldmVydHMgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZlcmlmeShyb290LCB3aWR0aCwgaW5kZXgsIHZhbHVlLCBwZWFrcywgc2libGluZ3MpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmJ1ZmZlcmlmeSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUod2lkdGgpO1xuICAgICAgICBpZiAoc2l6ZSA8IGluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHRoZSByb290IGVxdWFscyB0aGUgcGVhayBiYWdnaW5nIGhhc2hcbiAgICAgICAgaWYgKCFyb290LmVxdWFscyh0aGlzLnBlYWtCYWdnaW5nKHdpZHRoLCBwZWFrcykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcm9vdCBoYXNoIGZyb20gdGhlIHBlYWtzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCB0aGUgbW91bnRhaW4gd2hlcmUgdGhlIHRhcmdldCBpbmRleCBiZWxvbmdzIHRvXG4gICAgICAgIGxldCBjdXJzb3IgPSAwO1xuICAgICAgICBsZXQgdGFyZ2V0UGVhaztcbiAgICAgICAgY29uc3QgcGVha0luZGV4ZXMgPSB0aGlzLmdldFBlYWtJbmRleGVzKHdpZHRoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWFrSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBlYWtJbmRleGVzW2ldID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0UGVhayA9IHBlYWtzW2ldO1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IHBlYWtJbmRleGVzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0UGVhaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCB0aGUgcGF0aCBjbGltYmluZyBkb3duXG4gICAgICAgIGxldCBoZWlnaHQgPSBzaWJsaW5ncy5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBwYXRoID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgbGV0IHJpZ2h0ID0gMDtcbiAgICAgICAgd2hpbGUgKGhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIC8vIHJlY29yZCB0aGUgY3VycmVudCBjdXJzb3IgYW5kIGNsaW1iIGRvd25cbiAgICAgICAgICAgIHBhdGhbLS1oZWlnaHRdID0gY3Vyc29yO1xuICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBvbiB0aGUgbGVhZiBub2RlLiBTdG9wIGNsaW1iaW5nIGRvd25cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBwYXJlbnQgbm9kZS4gR28gbGVmdCBvciByaWdodFxuICAgICAgICAgICAgICAgIChbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRDaGlsZHJlbihjdXJzb3IpKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBpbmRleCA+IGxlZnQgPyByaWdodCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzdW1taXQgaGFzaCBjbGltYmluZyB1cCBhZ2FpblxuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgd2hpbGUgKGhlaWdodCA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIGN1cnNvclxuICAgICAgICAgICAgY3Vyc29yID0gcGF0aFtoZWlnaHRdO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGN1c29yIGlzIG9uIHRoZSBsZWFmXG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaExlYWYoY3Vyc29yLCB0aGlzLmhhc2hGbih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3Vyc29yIC0gMSA9PT0gcGF0aFtoZWlnaHQgLSAxXSkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnNvciBpcyBvbiBhIHBhcmVudCBhbmQgYSBzaWJsaW5ncyBpcyBvbiB0aGUgbGVmdFxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhc2hCcmFuY2goY3Vyc29yLCBzaWJsaW5nc1toZWlnaHQgLSAxXSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IgaXMgb24gYSBwYXJlbnQgYW5kIGEgc2libGluZ3MgaXMgb24gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuaGFzaEJyYW5jaChjdXJzb3IsIG5vZGUsIHNpYmxpbmdzW2hlaWdodCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsaW1iIHVwXG4gICAgICAgICAgICBoZWlnaHQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlZCBoYXNoIHZhbHVlIG9mIHRoZSBzdW1taXQgc2hvdWxkIGVxdWFsIHRvIHRoZSB0YXJnZXQgcGVhayBoYXNoXG4gICAgICAgIGlmICghbm9kZS5lcXVhbHModGFyZ2V0UGVhaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaGVkIHBlYWsgaXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwZWFrc1RvUGVha01hcCh3aWR0aCwgcGVha3MpIHtcbiAgICAgICAgY29uc3QgcGVha01hcCA9IHt9O1xuICAgICAgICBsZXQgYml0SW5kZXggPSAwO1xuICAgICAgICBsZXQgcGVha1JlZiA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IHBlYWtzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaGVpZ2h0ID0gMTsgaGVpZ2h0IDw9IDMyOyBoZWlnaHQrKykge1xuICAgICAgICAgICAgLy8gaW5kZXggc3RhcnRzIGZyb20gdGhlIHJpZ2h0IG1vc3QgYml0XG4gICAgICAgICAgICBiaXRJbmRleCA9IDMyIC0gaGVpZ2h0O1xuICAgICAgICAgICAgcGVha1JlZiA9IDEgPDwgKGhlaWdodCAtIDEpO1xuICAgICAgICAgICAgaWYgKCh3aWR0aCAmIHBlYWtSZWYpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVha01hcFtiaXRJbmRleF0gPSBwZWFrc1stLWNvdW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlYWtNYXBbYml0SW5kZXhdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBudW1iZXIgb2YgcGVha3MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVha01hcDtcbiAgICB9XG4gICAgcGVha01hcFRvUGVha3Mod2lkdGgsIHBlYWtNYXApIHtcbiAgICAgICAgY29uc3QgYXJyTGVuZ3RoID0gdGhpcy5udW1PZlBlYWtzKHdpZHRoKTtcbiAgICAgICAgY29uc3QgcGVha3MgPSBuZXcgQXJyYXkoYXJyTGVuZ3RoKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGVha01hcFtpXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHBlYWtzW2NvdW50KytdID0gcGVha01hcFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgIT09IGFyckxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG51bWJlciBvZiBwZWFrcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZWFrcztcbiAgICB9XG4gICAgcGVha1VwZGF0ZSh3aWR0aCwgcHJldlBlYWtNYXAsIGl0ZW1IYXNoKSB7XG4gICAgICAgIGNvbnN0IG5leHRQZWFrTWFwID0ge307XG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gd2lkdGggKyAxO1xuICAgICAgICBsZXQgY3Vyc29ySW5kZXggPSB0aGlzLmdldExlYWZJbmRleChuZXdXaWR0aCk7XG4gICAgICAgIGxldCBjdXJzb3JOb2RlID0gdGhpcy5oYXNoTGVhZihjdXJzb3JJbmRleCwgaXRlbUhhc2gpO1xuICAgICAgICBsZXQgYml0SW5kZXggPSAwO1xuICAgICAgICBsZXQgcGVha1JlZiA9IDA7XG4gICAgICAgIGxldCBwcmV2UGVha0V4aXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0UGVha0V4aXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBvYnRhaW5lZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBoZWlnaHQgPSAxOyBoZWlnaHQgPD0gMzI7IGhlaWdodCsrKSB7XG4gICAgICAgICAgICAvLyBpbmRleCBzdGFydHMgZnJvbSB0aGUgcmlnaHQgbW9zdCBiaXRcbiAgICAgICAgICAgIGJpdEluZGV4ID0gMzIgLSBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAob2J0YWluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGVha01hcFtiaXRJbmRleF0gPSBwcmV2UGVha01hcFtiaXRJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWFrUmVmID0gMSA8PCAoaGVpZ2h0IC0gMSk7XG4gICAgICAgICAgICAgICAgcHJldlBlYWtFeGlzdCA9ICh3aWR0aCAmIHBlYWtSZWYpICE9PSAwO1xuICAgICAgICAgICAgICAgIG5leHRQZWFrRXhpc3QgPSAobmV3V2lkdGggJiBwZWFrUmVmKSAhPT0gMDtcbiAgICAgICAgICAgICAgICAvLyBnZXQgbmV3IGN1cnNvciBub2RlIHdpdGggaGFzaGluZyB0aGUgcGVhayBhbmQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICAgICAgICAgICAgY3Vyc29ySW5kZXgrKztcbiAgICAgICAgICAgICAgICBpZiAocHJldlBlYWtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3JOb2RlID0gdGhpcy5oYXNoQnJhbmNoKGN1cnNvckluZGV4LCBwcmV2UGVha01hcFtiaXRJbmRleF0sIGN1cnNvck5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBuZXcgcGVhayBleGlzdHMgZm9yIHRoZSBiaXQgaW5kZXhcbiAgICAgICAgICAgICAgICBpZiAobmV4dFBlYWtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBwcmV2IHBlYWsgZXhpc3RzIGZvciB0aGUgYml0IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UGVha0V4aXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UGVha01hcFtiaXRJbmRleF0gPSBwcmV2UGVha01hcFtiaXRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UGVha01hcFtiaXRJbmRleF0gPSBjdXJzb3JOb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9idGFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQZWFrTWFwW2JpdEluZGV4XSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0UGVha01hcDtcbiAgICB9XG4gICAgcm9sbFVwKHJvb3QsIHdpZHRoLCBwZWFrcywgaXRlbUhhc2hlcykge1xuICAgICAgICAvLyBjaGVjayB0aGUgcm9vdCBlcXVhbHMgdGhlIHBlYWsgYmFnZ2luZyBoYXNoXG4gICAgICAgIGlmICghcm9vdC5lcXVhbHModGhpcy5wZWFrQmFnZ2luZyh3aWR0aCwgcGVha3MpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJvb3QgaGFzaCBmcm9tIHRoZSBwZWFrcycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0bXBXaWR0aCA9IHdpZHRoO1xuICAgICAgICBsZXQgdG1wUGVha01hcCA9IHRoaXMucGVha3NUb1BlYWtNYXAod2lkdGgsIHBlYWtzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtSGFzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0bXBQZWFrTWFwID0gdGhpcy5wZWFrVXBkYXRlKHRtcFdpZHRoLCB0bXBQZWFrTWFwLCBpdGVtSGFzaGVzW2ldKTtcbiAgICAgICAgICAgIHRtcFdpZHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGVha0JhZ2dpbmcodG1wV2lkdGgsIHRoaXMucGVha01hcFRvUGVha3ModG1wV2lkdGgsIHRtcFBlYWtNYXApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgaGFzaCB2YWx1ZSBvZiB0aGUgbm9kZSBmb3IgdGhlIGluZGV4LlxuICAgICAqICAgICAgSWYgdGhlIGhhc2ggYWxyZWFkeSBleGlzdHMgaXQgc2ltcGx5IHJldHVybnMgdGhlIHN0b3JlZCB2YWx1ZS4gT24gdGhlIG90aGVyIGhhbmQsXG4gICAgICogICAgICBpdCBjb21wdXRlcyBoYXNoZXMgcmVjdXJzaXZlbHkgZG93bndhcmQuXG4gICAgICogICAgICBPbmx5IGFwcGVuZGluZyBhbiBpdGVtIGNhbGxzIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgX2dldE9yQ3JlYXRlTm9kZShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc2hlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIGNvbnN0IFtsZWZ0SW5kZXgsIHJpZ2h0SW5kZXhdID0gdGhpcy5nZXRDaGlsZHJlbihpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0SGFzaCA9IHRoaXMuX2dldE9yQ3JlYXRlTm9kZShsZWZ0SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRIYXNoID0gdGhpcy5fZ2V0T3JDcmVhdGVOb2RlKHJpZ2h0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5oYXNoZXNbaW5kZXhdID0gdGhpcy5oYXNoQnJhbmNoKGluZGV4LCBsZWZ0SGFzaCwgcmlnaHRIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNoZXNbaW5kZXhdO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVya2xlTW91bnRhaW5SYW5nZSA9IE1lcmtsZU1vdW50YWluUmFuZ2U7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICA7XG4gICAgd2luZG93Lk1lcmtsZU1vdW50YWluUmFuZ2UgPSBNZXJrbGVNb3VudGFpblJhbmdlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVya2xlTW91bnRhaW5SYW5nZTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNZXJrbGVNb3VudGFpblJhbmdlIiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwic2hhMjU2XzEiLCJCYXNlXzEiLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJoYXNoRm4iLCJsZWF2ZXMiLCJoYXNoTGVhZkZuIiwicGVha0JhZ2dpbmdGbiIsImhhc2hCcmFuY2hGbiIsInJvb3QiLCJCdWZmZXIiLCJhbGxvYyIsInNpemUiLCJ3aWR0aCIsImhhc2hlcyIsImRhdGEiLCJtYXAiLCJidWZmZXJpZnkiLCJidWZmZXJpZnlGbiIsImxlYWYiLCJhcHBlbmQiLCJkYXRhSGFzaCIsImRhdGFIYXNoSGV4IiwiYnVmZmVyVG9IZXgiLCJoYXNoTGVhZiIsInBlYWtJbmRleGVzIiwiZ2V0UGVha0luZGV4ZXMiLCJnZXRTaXplIiwicGVha3MiLCJpIiwibGVuZ3RoIiwiX2dldE9yQ3JlYXRlTm9kZSIsInBlYWtCYWdnaW5nIiwiaW5kZXgiLCJjb25jYXQiLCJoYXNoQnJhbmNoIiwibGVmdCIsInJpZ2h0IiwiZ2V0UGVha3MiLCJnZXRMZWFmSW5kZXgiLCJudW1QZWFrcyIsIm51bU9mUGVha3MiLCJjb3VudCIsIkVycm9yIiwiYml0cyIsIm51bSIsImdldFJvb3QiLCJnZXRIZXhSb290IiwiZ2V0Tm9kZSIsIm1vdW50YWluSGVpZ2h0IiwiaGVpZ2h0IiwiaGVpZ2h0QXQiLCJyZWR1Y2VkSW5kZXgiLCJwZWFrSW5kZXgiLCJpc0xlYWYiLCJnZXRDaGlsZHJlbiIsImdldE1lcmtsZVByb29mIiwiY3Vyc29yIiwic2libGluZ3MiLCJ2ZXJpZnkiLCJlcXVhbHMiLCJ0YXJnZXRQZWFrIiwicGF0aCIsIkFycmF5Iiwibm9kZSIsInBlYWtzVG9QZWFrTWFwIiwicGVha01hcCIsImJpdEluZGV4IiwicGVha1JlZiIsInBlYWtNYXBUb1BlYWtzIiwiYXJyTGVuZ3RoIiwicGVha1VwZGF0ZSIsInByZXZQZWFrTWFwIiwiaXRlbUhhc2giLCJuZXh0UGVha01hcCIsIm5ld1dpZHRoIiwiY3Vyc29ySW5kZXgiLCJjdXJzb3JOb2RlIiwicHJldlBlYWtFeGlzdCIsIm5leHRQZWFrRXhpc3QiLCJvYnRhaW5lZCIsInJvbGxVcCIsIml0ZW1IYXNoZXMiLCJ0bXBXaWR0aCIsInRtcFBlYWtNYXAiLCJsZWZ0SW5kZXgiLCJyaWdodEluZGV4IiwibGVmdEhhc2giLCJyaWdodEhhc2giLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/MerkleMountainRange.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/MerkleSumTree.js":
/*!*********************************************************!*\
  !*** ./node_modules/merkletreejs/dist/MerkleSumTree.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MerkleSumTree = exports.ProofStep = exports.Leaf = exports.Bucket = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\");\nclass Bucket {\n    constructor(size, hashed){\n        this.size = BigInt(size);\n        this.hashed = hashed;\n        // each node in the tree can have a parent, and a left or right sibling\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexports.Bucket = Bucket;\nclass Leaf {\n    constructor(hashFn, rng, data){\n        this.hashFn = hashFn;\n        this.rng = rng.map((x)=>BigInt(x));\n        this.data = data;\n    }\n    getBucket() {\n        let hashed;\n        if (this.data) {\n            hashed = this.hashFn(this.data);\n        } else {\n            hashed = Buffer.alloc(32);\n        }\n        return new Bucket(BigInt(this.rng[1]) - BigInt(this.rng[0]), hashed);\n    }\n}\nexports.Leaf = Leaf;\nclass ProofStep {\n    constructor(bucket, right){\n        this.bucket = bucket;\n        this.right = right; // whether the bucket hash should be appeded on the right side in this step (default is left\n    }\n}\nexports.ProofStep = ProofStep;\nclass MerkleSumTree extends Base_1.Base {\n    constructor(leaves, hashFn){\n        super();\n        this.leaves = leaves;\n        this.hashFn = hashFn;\n        MerkleSumTree.checkConsecutive(leaves);\n        this.buckets = [];\n        for (const l of leaves){\n            this.buckets.push(l.getBucket());\n        }\n        let buckets = [];\n        for (const bucket of this.buckets){\n            buckets.push(bucket);\n        }\n        while(buckets.length !== 1){\n            const newBuckets = [];\n            while(buckets.length){\n                if (buckets.length >= 2) {\n                    const b1 = buckets.shift();\n                    const b2 = buckets.shift();\n                    const size = b1.size + b2.size;\n                    const hashed = this.hashFn(Buffer.concat([\n                        this.sizeToBuffer(b1.size),\n                        this.bufferify(b1.hashed),\n                        this.sizeToBuffer(b2.size),\n                        this.bufferify(b2.hashed)\n                    ]));\n                    const b = new Bucket(size, hashed);\n                    b2.parent = b;\n                    b1.parent = b2.parent;\n                    b1.right = b2;\n                    b2.left = b1;\n                    newBuckets.push(b);\n                } else {\n                    newBuckets.push(buckets.shift());\n                }\n            }\n            buckets = newBuckets;\n        }\n        this.root = buckets[0];\n    }\n    sizeToBuffer(size) {\n        const buf = Buffer.alloc(8);\n        const view = new DataView(buf.buffer);\n        view.setBigInt64(0, BigInt(size), false); // true when little endian\n        return buf;\n    }\n    static checkConsecutive(leaves) {\n        let curr = BigInt(0);\n        for (const leaf of leaves){\n            if (leaf.rng[0] !== curr) {\n                throw new Error(\"leaf ranges are invalid\");\n            }\n            curr = BigInt(leaf.rng[1]);\n        }\n    }\n    // gets inclusion/exclusion proof of a bucket in the specified index\n    getProof(index) {\n        let curr = this.buckets[Number(index)];\n        const proof = [];\n        while(curr && curr.parent){\n            const right = !!curr.right;\n            const bucket = curr.right ? curr.right : curr.left;\n            curr = curr.parent;\n            proof.push(new ProofStep(bucket, right));\n        }\n        return proof;\n    }\n    sum(arr) {\n        let total = BigInt(0);\n        for (const value of arr){\n            total += BigInt(value);\n        }\n        return total;\n    }\n    // validates the suppplied proof for a specified leaf according to the root bucket\n    verifyProof(root, leaf, proof) {\n        const rng = [\n            this.sum(proof.filter((x)=>!x.right).map((x)=>x.bucket.size)),\n            BigInt(root.size) - this.sum(proof.filter((x)=>x.right).map((x)=>x.bucket.size))\n        ];\n        if (!(rng[0] === leaf.rng[0] && rng[1] === leaf.rng[1])) {\n            // supplied steps are not routing to the range specified\n            return false;\n        }\n        let curr = leaf.getBucket();\n        let hashed;\n        for (const step of proof){\n            if (step.right) {\n                hashed = this.hashFn(Buffer.concat([\n                    this.sizeToBuffer(curr.size),\n                    this.bufferify(curr.hashed),\n                    this.sizeToBuffer(step.bucket.size),\n                    this.bufferify(step.bucket.hashed)\n                ]));\n            } else {\n                hashed = this.hashFn(Buffer.concat([\n                    this.sizeToBuffer(step.bucket.size),\n                    this.bufferify(step.bucket.hashed),\n                    this.sizeToBuffer(curr.size),\n                    this.bufferify(curr.hashed)\n                ]));\n            }\n            curr = new Bucket(BigInt(curr.size) + BigInt(step.bucket.size), hashed);\n        }\n        return curr.size === root.size && curr.hashed.toString(\"hex\") === root.hashed.toString(\"hex\");\n    }\n}\nexports.MerkleSumTree = MerkleSumTree;\nif (false) {}\nexports[\"default\"] = MerkleSumTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlU3VtVHJlZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHQSxZQUFZLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ2pGLE1BQU1NLFNBQVNDLG1CQUFPQSxDQUFDLDhEQUFRO0FBQy9CLE1BQU1GO0lBQ0ZHLFlBQVlDLElBQUksRUFBRUMsTUFBTSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0QsSUFBSSxHQUFHRSxPQUFPRjtRQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCx1RUFBdUU7UUFDdkUsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2pCO0FBQ0o7QUFDQWQsY0FBYyxHQUFHSztBQUNqQixNQUFNRDtJQUNGSSxZQUFZTyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxDQUFFO1FBQzNCLElBQUksQ0FBQ0YsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHQSxJQUFJRSxHQUFHLENBQUNDLENBQUFBLElBQUtSLE9BQU9RO1FBQy9CLElBQUksQ0FBQ0YsSUFBSSxHQUFHQTtJQUNoQjtJQUNBRyxZQUFZO1FBQ1IsSUFBSVY7UUFDSixJQUFJLElBQUksQ0FBQ08sSUFBSSxFQUFFO1lBQ1hQLFNBQVMsSUFBSSxDQUFDSyxNQUFNLENBQUMsSUFBSSxDQUFDRSxJQUFJO1FBQ2xDLE9BQ0s7WUFDRFAsU0FBU1csT0FBT0MsS0FBSyxDQUFDO1FBQzFCO1FBQ0EsT0FBTyxJQUFJakIsT0FBT00sT0FBTyxJQUFJLENBQUNLLEdBQUcsQ0FBQyxFQUFFLElBQUlMLE9BQU8sSUFBSSxDQUFDSyxHQUFHLENBQUMsRUFBRSxHQUFHTjtJQUNqRTtBQUNKO0FBQ0FWLFlBQVks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LElBQUlNLEtBQUszQyxLQUFLLEVBQUU7Z0JBQ1pKLFNBQVMsSUFBSSxDQUFDSyxNQUFNLENBQUNNLE9BQU9jLE1BQU0sQ0FBQztvQkFBQyxJQUFJLENBQUNDLFlBQVksQ0FBQ1MsS0FBS3BDLElBQUk7b0JBQUcsSUFBSSxDQUFDNEIsU0FBUyxDQUFDUSxLQUFLbkMsTUFBTTtvQkFBRyxJQUFJLENBQUMwQixZQUFZLENBQUNxQixLQUFLbEMsTUFBTSxDQUFDZCxJQUFJO29CQUFHLElBQUksQ0FBQzRCLFNBQVMsQ0FBQ29CLEtBQUtsQyxNQUFNLENBQUNiLE1BQU07aUJBQUU7WUFDM0ssT0FDSztnQkFDREEsU0FBUyxJQUFJLENBQUNLLE1BQU0sQ0FBQ00sT0FBT2MsTUFBTSxDQUFDO29CQUFDLElBQUksQ0FBQ0MsWUFBWSxDQUFDcUIsS0FBS2xDLE1BQU0sQ0FBQ2QsSUFBSTtvQkFBRyxJQUFJLENBQUM0QixTQUFTLENBQUNvQixLQUFLbEMsTUFBTSxDQUFDYixNQUFNO29CQUFHLElBQUksQ0FBQzBCLFlBQVksQ0FBQ1MsS0FBS3BDLElBQUk7b0JBQUcsSUFBSSxDQUFDNEIsU0FBUyxDQUFDUSxLQUFLbkMsTUFBTTtpQkFBRTtZQUMzSztZQUNBbUMsT0FBTyxJQUFJeEMsT0FBT00sT0FBT2tDLEtBQUtwQyxJQUFJLElBQUlFLE9BQU84QyxLQUFLbEMsTUFBTSxDQUFDZCxJQUFJLEdBQUdDO1FBQ3BFO1FBQ0EsT0FBT21DLEtBQUtwQyxJQUFJLEtBQUs4QixLQUFLOUIsSUFBSSxJQUFJb0MsS0FBS25DLE1BQU0sQ0FBQ2dELFFBQVEsQ0FBQyxXQUFXbkIsS0FBSzdCLE1BQU0sQ0FBQ2dELFFBQVEsQ0FBQztJQUMzRjtBQUNKO0FBQ0ExRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSSxLQUFrQixFQUFhLEVBR2xDO0FBQ0RGLGtCQUFlLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVya2xlLy4vbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZVN1bVRyZWUuanM/ZDUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVya2xlU3VtVHJlZSA9IGV4cG9ydHMuUHJvb2ZTdGVwID0gZXhwb3J0cy5MZWFmID0gZXhwb3J0cy5CdWNrZXQgPSB2b2lkIDA7XG5jb25zdCBCYXNlXzEgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xuY2xhc3MgQnVja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBoYXNoZWQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gQmlnSW50KHNpemUpO1xuICAgICAgICB0aGlzLmhhc2hlZCA9IGhhc2hlZDtcbiAgICAgICAgLy8gZWFjaCBub2RlIGluIHRoZSB0cmVlIGNhbiBoYXZlIGEgcGFyZW50LCBhbmQgYSBsZWZ0IG9yIHJpZ2h0IHNpYmxpbmdcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkJ1Y2tldCA9IEJ1Y2tldDtcbmNsYXNzIExlYWYge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hGbiwgcm5nLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gaGFzaEZuO1xuICAgICAgICB0aGlzLnJuZyA9IHJuZy5tYXAoeCA9PiBCaWdJbnQoeCkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBnZXRCdWNrZXQoKSB7XG4gICAgICAgIGxldCBoYXNoZWQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGhhc2hlZCA9IHRoaXMuaGFzaEZuKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNoZWQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVja2V0KEJpZ0ludCh0aGlzLnJuZ1sxXSkgLSBCaWdJbnQodGhpcy5ybmdbMF0pLCBoYXNoZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVhZiA9IExlYWY7XG5jbGFzcyBQcm9vZlN0ZXAge1xuICAgIGNvbnN0cnVjdG9yKGJ1Y2tldCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDsgLy8gd2hldGhlciB0aGUgYnVja2V0IGhhc2ggc2hvdWxkIGJlIGFwcGVkZWQgb24gdGhlIHJpZ2h0IHNpZGUgaW4gdGhpcyBzdGVwIChkZWZhdWx0IGlzIGxlZnRcbiAgICB9XG59XG5leHBvcnRzLlByb29mU3RlcCA9IFByb29mU3RlcDtcbmNsYXNzIE1lcmtsZVN1bVRyZWUgZXh0ZW5kcyBCYXNlXzEuQmFzZSB7XG4gICAgY29uc3RydWN0b3IobGVhdmVzLCBoYXNoRm4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sZWF2ZXMgPSBsZWF2ZXM7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gaGFzaEZuO1xuICAgICAgICBNZXJrbGVTdW1UcmVlLmNoZWNrQ29uc2VjdXRpdmUobGVhdmVzKTtcbiAgICAgICAgdGhpcy5idWNrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbCBvZiBsZWF2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0cy5wdXNoKGwuZ2V0QnVja2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWNrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgICAgYnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGJ1Y2tldHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCdWNrZXRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAoYnVja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiMSA9IGJ1Y2tldHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYjIgPSBidWNrZXRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBiMS5zaXplICsgYjIuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaGVkID0gdGhpcy5oYXNoRm4oQnVmZmVyLmNvbmNhdChbdGhpcy5zaXplVG9CdWZmZXIoYjEuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KGIxLmhhc2hlZCksIHRoaXMuc2l6ZVRvQnVmZmVyKGIyLnNpemUpLCB0aGlzLmJ1ZmZlcmlmeShiMi5oYXNoZWQpXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gbmV3IEJ1Y2tldChzaXplLCBoYXNoZWQpO1xuICAgICAgICAgICAgICAgICAgICBiMi5wYXJlbnQgPSBiO1xuICAgICAgICAgICAgICAgICAgICBiMS5wYXJlbnQgPSBiMi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGIxLnJpZ2h0ID0gYjI7XG4gICAgICAgICAgICAgICAgICAgIGIyLmxlZnQgPSBiMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QnVja2V0cy5wdXNoKGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QnVja2V0cy5wdXNoKGJ1Y2tldHMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0cyA9IG5ld0J1Y2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gYnVja2V0c1swXTtcbiAgICB9XG4gICAgc2l6ZVRvQnVmZmVyKHNpemUpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIpO1xuICAgICAgICB2aWV3LnNldEJpZ0ludDY0KDAsIEJpZ0ludChzaXplKSwgZmFsc2UpOyAvLyB0cnVlIHdoZW4gbGl0dGxlIGVuZGlhblxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2tDb25zZWN1dGl2ZShsZWF2ZXMpIHtcbiAgICAgICAgbGV0IGN1cnIgPSBCaWdJbnQoMCk7XG4gICAgICAgIGZvciAoY29uc3QgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgICAgIGlmIChsZWFmLnJuZ1swXSAhPT0gY3Vycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhZiByYW5nZXMgYXJlIGludmFsaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnIgPSBCaWdJbnQobGVhZi5ybmdbMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGdldHMgaW5jbHVzaW9uL2V4Y2x1c2lvbiBwcm9vZiBvZiBhIGJ1Y2tldCBpbiB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgZ2V0UHJvb2YoaW5kZXgpIHtcbiAgICAgICAgbGV0IGN1cnIgPSB0aGlzLmJ1Y2tldHNbTnVtYmVyKGluZGV4KV07XG4gICAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICAgIHdoaWxlIChjdXJyICYmIGN1cnIucGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9ICEhY3Vyci5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldCA9IGN1cnIucmlnaHQgPyBjdXJyLnJpZ2h0IDogY3Vyci5sZWZ0O1xuICAgICAgICAgICAgY3VyciA9IGN1cnIucGFyZW50O1xuICAgICAgICAgICAgcHJvb2YucHVzaChuZXcgUHJvb2ZTdGVwKGJ1Y2tldCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2Y7XG4gICAgfVxuICAgIHN1bShhcnIpIHtcbiAgICAgICAgbGV0IHRvdGFsID0gQmlnSW50KDApO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycikge1xuICAgICAgICAgICAgdG90YWwgKz0gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlcyB0aGUgc3VwcHBsaWVkIHByb29mIGZvciBhIHNwZWNpZmllZCBsZWFmIGFjY29yZGluZyB0byB0aGUgcm9vdCBidWNrZXRcbiAgICB2ZXJpZnlQcm9vZihyb290LCBsZWFmLCBwcm9vZikge1xuICAgICAgICBjb25zdCBybmcgPSBbdGhpcy5zdW0ocHJvb2YuZmlsdGVyKHggPT4gIXgucmlnaHQpLm1hcCh4ID0+IHguYnVja2V0LnNpemUpKSwgQmlnSW50KHJvb3Quc2l6ZSkgLSB0aGlzLnN1bShwcm9vZi5maWx0ZXIoeCA9PiB4LnJpZ2h0KS5tYXAoeCA9PiB4LmJ1Y2tldC5zaXplKSldO1xuICAgICAgICBpZiAoIShybmdbMF0gPT09IGxlYWYucm5nWzBdICYmIHJuZ1sxXSA9PT0gbGVhZi5ybmdbMV0pKSB7XG4gICAgICAgICAgICAvLyBzdXBwbGllZCBzdGVwcyBhcmUgbm90IHJvdXRpbmcgdG8gdGhlIHJhbmdlIHNwZWNpZmllZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyID0gbGVhZi5nZXRCdWNrZXQoKTtcbiAgICAgICAgbGV0IGhhc2hlZDtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHByb29mKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5yaWdodCkge1xuICAgICAgICAgICAgICAgIGhhc2hlZCA9IHRoaXMuaGFzaEZuKEJ1ZmZlci5jb25jYXQoW3RoaXMuc2l6ZVRvQnVmZmVyKGN1cnIuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KGN1cnIuaGFzaGVkKSwgdGhpcy5zaXplVG9CdWZmZXIoc3RlcC5idWNrZXQuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KHN0ZXAuYnVja2V0Lmhhc2hlZCldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYXNoZWQgPSB0aGlzLmhhc2hGbihCdWZmZXIuY29uY2F0KFt0aGlzLnNpemVUb0J1ZmZlcihzdGVwLmJ1Y2tldC5zaXplKSwgdGhpcy5idWZmZXJpZnkoc3RlcC5idWNrZXQuaGFzaGVkKSwgdGhpcy5zaXplVG9CdWZmZXIoY3Vyci5zaXplKSwgdGhpcy5idWZmZXJpZnkoY3Vyci5oYXNoZWQpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IG5ldyBCdWNrZXQoQmlnSW50KGN1cnIuc2l6ZSkgKyBCaWdJbnQoc3RlcC5idWNrZXQuc2l6ZSksIGhhc2hlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnIuc2l6ZSA9PT0gcm9vdC5zaXplICYmIGN1cnIuaGFzaGVkLnRvU3RyaW5nKCdoZXgnKSA9PT0gcm9vdC5oYXNoZWQudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVya2xlU3VtVHJlZSA9IE1lcmtsZVN1bVRyZWU7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICA7XG4gICAgd2luZG93Lk1lcmtsZVN1bVRyZWUgPSBNZXJrbGVTdW1UcmVlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVya2xlU3VtVHJlZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1lcmtsZVN1bVRyZWUiLCJQcm9vZlN0ZXAiLCJMZWFmIiwiQnVja2V0IiwiQmFzZV8xIiwicmVxdWlyZSIsImNvbnN0cnVjdG9yIiwic2l6ZSIsImhhc2hlZCIsIkJpZ0ludCIsInBhcmVudCIsImxlZnQiLCJyaWdodCIsImhhc2hGbiIsInJuZyIsImRhdGEiLCJtYXAiLCJ4IiwiZ2V0QnVja2V0IiwiQnVmZmVyIiwiYWxsb2MiLCJidWNrZXQiLCJCYXNlIiwibGVhdmVzIiwiY2hlY2tDb25zZWN1dGl2ZSIsImJ1Y2tldHMiLCJsIiwicHVzaCIsImxlbmd0aCIsIm5ld0J1Y2tldHMiLCJiMSIsInNoaWZ0IiwiYjIiLCJjb25jYXQiLCJzaXplVG9CdWZmZXIiLCJidWZmZXJpZnkiLCJiIiwicm9vdCIsImJ1ZiIsInZpZXciLCJEYXRhVmlldyIsImJ1ZmZlciIsInNldEJpZ0ludDY0IiwiY3VyciIsImxlYWYiLCJFcnJvciIsImdldFByb29mIiwiaW5kZXgiLCJOdW1iZXIiLCJwcm9vZiIsInN1bSIsImFyciIsInRvdGFsIiwidmVyaWZ5UHJvb2YiLCJmaWx0ZXIiLCJzdGVwIiwidG9TdHJpbmciLCJ3aW5kb3ciLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/MerkleSumTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/MerkleTree.js":
/*!******************************************************!*\
  !*** ./node_modules/merkletreejs/dist/MerkleTree.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MerkleTree = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst buffer_reverse_1 = __importDefault(__webpack_require__(/*! buffer-reverse */ \"(ssr)/./node_modules/buffer-reverse/index.js\"));\nconst sha256_1 = __importDefault(__webpack_require__(/*! crypto-js/sha256 */ \"(ssr)/./node_modules/crypto-js/sha256.js\"));\nconst treeify_1 = __importDefault(__webpack_require__(/*! treeify */ \"(ssr)/./node_modules/treeify/treeify.js\"));\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/./node_modules/merkletreejs/dist/Base.js\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */ class MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */ constructor(leaves, hashFn = sha256_1.default, options = {}){\n        super();\n        this.duplicateOdd = false;\n        this.concatenator = buffer_1.Buffer.concat;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.complete = false;\n        if (options.complete) {\n            if (options.isBitcoinTree) {\n                throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n            }\n            if (options.duplicateOdd) {\n                throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n            }\n        }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.complete = !!options.complete;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === \"function\") {\n                this.fillDefaultHash = options.fillDefaultHash;\n            } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === \"string\") {\n                this.fillDefaultHash = (idx, hashFn)=>options.fillDefaultHash;\n            } else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        if (options.concatenator) {\n            this.concatenator = options.concatenator;\n        }\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    getOptions() {\n        var _a, _b;\n        return {\n            complete: this.complete,\n            isBitcoinTree: this.isBitcoinTree,\n            hashLeaves: this.hashLeaves,\n            sortLeaves: this.sortLeaves,\n            sortPairs: this.sortPairs,\n            sort: this.sort,\n            fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,\n            duplicateOdd: this.duplicateOdd\n        };\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for(let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++){\n                this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n            }\n        }\n        this.createHashes(this.leaves);\n    }\n    createHashes(nodes) {\n        this.layers = [\n            nodes\n        ];\n        while(nodes.length > 1){\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - Math.pow(2, Math.ceil(Math.log2(nodes.length))) : nodes.length;\n            for(let i = 0; i < nodes.length; i += 2){\n                if (i >= layerLimit) {\n                    this.layers[layerIndex].push(...nodes.slice(layerLimit));\n                    break;\n                } else if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        const data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            hash = this.hashFn(this.concatenator([\n                                buffer_reverse_1.default(data),\n                                buffer_reverse_1.default(data)\n                            ]));\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        } else {\n                            if (this.duplicateOdd) {\n                            // continue with creating layer\n                            } else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [\n                        buffer_reverse_1.default(left),\n                        buffer_reverse_1.default(right)\n                    ];\n                } else {\n                    combined = [\n                        left,\n                        right\n                    ];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer_1.Buffer.compare);\n                }\n                let hash = this.hashFn(this.concatenator(combined));\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */ addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */ addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */ getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer_1.Buffer.compare);\n                }\n            }\n            return this.leaves.filter((leaf)=>this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */ getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */ getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for(let i = 0; i < leaves.length; i++){\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */ getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */ getHexLeaves() {\n        return this.leaves.map((leaf)=>this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */ static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map((leaf)=>MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */ static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === \"string\") {\n            parsed = JSON.parse(jsonStr);\n        } else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        } else {\n            throw new Error(\"Expected type of string or object\");\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error(\"Expected JSON string to be array\");\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[][]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */ getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[][]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */ getHexLayers() {\n        return this.layers.reduce((acc, item)=>{\n            if (Array.isArray(item)) {\n                acc.push(item.map((layer)=>this.bufferToHex(layer)));\n            } else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */ getLayersFlat() {\n        const layers = this.layers.reduce((acc, item)=>{\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            } else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer_1.Buffer.from([\n            0\n        ]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */ getHexLayersFlat() {\n        return this.getLayersFlat().map((layer)=>this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */ getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */ getRoot() {\n        if (this.layers.length === 0) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */ getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */ getProof(leaf, index) {\n        if (typeof leaf === \"undefined\") {\n            throw new Error(\"leaf is required\");\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for(let i = 0; i < this.leaves.length; i++){\n                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for(let i = 0; i < this.layers.length; i++){\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? index : index + 1;\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? \"left\" : \"right\",\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = index / 2 | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */ getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map((item)=>this.bufferToHex(item.data));\n    }\n    /**\n     * getProofs\n     * @desc Returns the proofs for all leaves.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n     * @example\n     * ```js\n     *const proofs = tree.getProofs()\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proofs = tree.getProofs()\n     *```\n     */ getProofs() {\n        const proof = [];\n        const proofs = [];\n        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n        return proofs;\n    }\n    /**\n     * getProofsDFS\n     * @desc Get all proofs through single traverse\n     * @param {Number} currentLayer - Current layer index in traverse.\n     * @param {Number} index - Current tarvese node index in traverse.\n     * @param {Object[]} proof - Proof chain for single leaf.\n     * @param {Object[]} proofs - Proofs for all leaves\n     * @example\n     * ```js\n     *const layers = tree.getLayers()\n     *const index = 0;\n     *let proof = [];\n     *let proofs = [];\n     *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n     *```\n     */ getProofsDFS(currentLayer, index, proof, proofs) {\n        const isRightNode = index % 2;\n        if (currentLayer === -1) {\n            if (!isRightNode) proofs.push([\n                ...proof\n            ].reverse());\n            return;\n        }\n        if (index >= this.layers[currentLayer].length) return;\n        const layer = this.layers[currentLayer];\n        const pairIndex = isRightNode ? index - 1 : index + 1;\n        let pushed = false;\n        if (pairIndex < layer.length) {\n            pushed = true;\n            proof.push({\n                position: isRightNode ? \"left\" : \"right\",\n                data: layer[pairIndex]\n            });\n        }\n        const leftchildIndex = index * 2;\n        const rightchildIndex = index * 2 + 1;\n        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n        if (pushed) proof.splice(proof.length - 1, 1);\n    }\n    /**\n     * getHexProofs\n     * @desc Returns the proofs for all leaves as hex strings.\n     * @return {String[]} - Proofs array as hex strings.\n     * @example\n     * ```js\n     *const proofs = tree.getHexProofs()\n     *```\n     */ getHexProofs() {\n        return this.getProofs().map((item)=>this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */ getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map((item)=>{\n            return [\n                item.position === \"left\" ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */ static marshalProof(proof) {\n        const json = proof.map((item)=>{\n            if (typeof item === \"string\") {\n                return item;\n            }\n            if (buffer_1.Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */ static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === \"string\") {\n            parsed = JSON.parse(jsonStr);\n        } else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        } else {\n            throw new Error(\"Expected type of string or object\");\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error(\"Expected JSON string to be array\");\n        }\n        return parsed.map((item)=>{\n            if (typeof item === \"string\") {\n                return MerkleTree.bufferify(item);\n            } else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            } else {\n                throw new Error(\"Expected item to be of type string or object\");\n            }\n        });\n    }\n    static marshalTree(tree) {\n        const root = tree.getHexRoot();\n        const leaves = tree.leaves.map((leaf)=>MerkleTree.bufferToHex(leaf));\n        const layers = tree.getHexLayers();\n        const options = tree.getOptions();\n        return JSON.stringify({\n            options,\n            root,\n            layers,\n            leaves\n        }, null, 2);\n    }\n    static unmarshalTree(jsonStr, hashFn = sha256_1.default, options = {}) {\n        let parsed = null;\n        if (typeof jsonStr === \"string\") {\n            parsed = JSON.parse(jsonStr);\n        } else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        } else {\n            throw new Error(\"Expected type of string or object\");\n        }\n        if (!parsed) {\n            throw new Error(\"could not parse json\");\n        }\n        options = Object.assign({}, parsed.options || {}, options);\n        return new MerkleTree(parsed.leaves, hashFn, options);\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */ getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices){\n            let x = leafCount + index;\n            while(x > 1){\n                maximalIndices.add(x ^ 1);\n                x = x / 2 | 0;\n            }\n        }\n        const a = treeIndices.map((index)=>leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b)=>a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices){\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while(index > 1){\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1)) break;\n                    index = index / 2 | 0;\n                }\n            }\n        }\n        return proof.filter((index)=>{\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for(let index = 0; index < depth; index++){\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({\n                    index,\n                    leavesCount\n                });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for(let layerIndex = 0; layerIndex < depth; layerIndex++){\n            const siblingIndices = layerNodes.map((index)=>{\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index)=>!layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find(({ index })=>index === layerIndex);\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [\n                ...new Set(layerNodes.map((index)=>{\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))\n            ];\n        }\n        return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */ getMultiProof(tree, indices) {\n        if (!this.complete) {\n            console.warn(\"Warning: For correct multiProofs it's strongly recommended to set complete: true\");\n        }\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                els = els.sort(buffer_1.Buffer.compare);\n            }\n            let ids = els.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx)=>idx !== -1)) {\n                throw new Error(\"Element does not exist in Merkle tree\");\n            }\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for(let i = 0; i < this.layers.length; i++){\n                const layer = this.layers[i];\n                for(let j = 0; j < ids.length; j++){\n                    const idx = ids[j];\n                    const pairElement = this.getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push(idx / 2 | 0);\n                }\n                ids = nextIds.filter((value, i, self)=>self.indexOf(value) === i);\n                nextIds = [];\n            }\n            return proof.filter((value)=>!hashes.includes(value));\n        }\n        return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map((index)=>tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        let currentLayerIndices = indices;\n        for (const treeLayer of tree){\n            const siblings = [];\n            for (const index of currentLayerIndices){\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices){\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */ getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x)=>this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */ getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error(\"Invalid Inputs!\");\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = [\n                ...leaves\n            ].sort((a, b)=>a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        } else {\n            ids = leaves.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx)=>idx !== -1)) {\n            throw new Error(\"Element does not exist in Merkle tree\");\n        }\n        const _proofs = proofs.map((item)=>this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for(let index = 0; index < this.layers.length; index++){\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx)=>{\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this.getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push(idx / 2 | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */ verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) || !targetNode || !root) {\n            return false;\n        }\n        for(let i = 0; i < proof.length; i++){\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === \"string\") {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            } else if (Array.isArray(node)) {\n                isLeftNode = node[0] === 0;\n                data = this.bufferify(node[1]);\n            } else if (buffer_1.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            } else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = node.position === \"left\";\n            } else {\n                throw new Error(\"Expected node to be of type string or object\");\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? \"unshift\" : \"push\"](buffer_reverse_1.default(data));\n                hash = this.hashFn(this.concatenator(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            } else {\n                if (this.sortPairs) {\n                    if (buffer_1.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    } else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                } else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? \"unshift\" : \"push\"](data);\n                    hash = this.hashFn(this.concatenator(buffers));\n                }\n            }\n        }\n        return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */ verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map((leaf)=>this.bufferify(leaf));\n        proof = proof.map((leaf)=>this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)){\n            tree[Math.pow(2, depth) + index] = leaf;\n        }\n        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)){\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map((value)=>+value).sort((a, b)=>a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while(i < indexqueue.length){\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [\n                    tree[index - index % 2],\n                    tree[index - index % 2 + 1]\n                ];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer_1.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n                tree[index / 2 | 0] = hash;\n                indexqueue.push(index / 2 | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || ({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for(let i = 0; i < totalHashes; i++){\n            const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [\n                bufA,\n                bufB\n            ].sort(buffer_1.Buffer.compare);\n            hashes[i] = this.hashFn(this.concatenator(buffers));\n        }\n        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map((leaf)=>this.bufferify(leaf));\n        proof = proof.map((leaf)=>this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */ getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */ getLayersAsObject() {\n        const layers = this.getLayers().map((layer)=>layer.map((value)=>this.bufferToHex(value, false)));\n        const objs = [];\n        for(let i = 0; i < layers.length; i++){\n            const arr = [];\n            for(let j = 0; j < layers[i].length; j++){\n                const obj = {\n                    [layers[i][j]]: null\n                };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */ static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */ static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */ resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */ getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        } else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */ toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */ toString() {\n        return this.toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & v - 1);\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this.zip(leafIndices, leafHashes).sort(([indexA], [indexB])=>indexA - indexB);\n        const leafTupleIndices = leafTuples.map(([index])=>index);\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for(let i = 0; i < proofIndices.length; i++){\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [\n            leafTuples\n        ];\n        for(let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++){\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB])=>indexA - indexB).map(([, hash])=>hash);\n            const s = tree[layerIndex].map(([layerIndex])=>layerIndex);\n            const parentIndices = [\n                ...new Set(s.map((index)=>{\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))\n            ];\n            const parentLayer = [];\n            for(let i = 0; i < parentIndices.length; i++){\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(this.concatenator([\n                    bufA,\n                    bufB\n                ])) : bufA;\n                parentLayer.push([\n                    parentNodeTreeIndex,\n                    hash\n                ]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (false) {}\nexports[\"default\"] = MerkleTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlVHJlZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsbUJBQW1CVixnQkFBZ0JTLG1CQUFPQSxDQUFDLG9FQUFnQjtBQUNqRSxNQUFNRSxXQUFXWCxnQkFBZ0JTLG1CQUFPQSxDQUFDLGtFQUFrQjtBQUMzRCxNQUFNRyxZQUFZWixnQkFBZ0JTLG1CQUFPQSxDQUFDLHdEQUFTO0FBQ25ELE1BQU1JLFNBQVNiLGdCQUFnQlMsbUJBQU9BLENBQUMsOERBQVE7QUFDL0M7OztDQUdDLEdBQ0QsTUFBTUYsbUJBQW1CTSxPQUFPQyxPQUFPO0lBQ25DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQkMsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxTQUFTTixTQUFTRyxPQUFPLEVBQUVJLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDekQsS0FBSztRQUNMLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsWUFBWSxHQUFHWixTQUFTYSxNQUFNLENBQUNDLE1BQU07UUFDMUMsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDUixNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNTLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElB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QWUsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJrbGUvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvTWVya2xlVHJlZS5qcz83NWMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJrbGVUcmVlID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3QgYnVmZmVyX3JldmVyc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYnVmZmVyLXJldmVyc2VcIikpO1xuY29uc3Qgc2hhMjU2XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyeXB0by1qcy9zaGEyNTZcIikpO1xuY29uc3QgdHJlZWlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0cmVlaWZ5XCIpKTtcbmNvbnN0IEJhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CYXNlXCIpKTtcbi8qKlxuICogQ2xhc3MgcmVwcmVuc2VudGluZyBhIE1lcmtsZSBUcmVlXG4gKiBAbmFtZXNwYWNlIE1lcmtsZVRyZWVcbiAqL1xuY2xhc3MgTWVya2xlVHJlZSBleHRlbmRzIEJhc2VfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBAZGVzYyBDb25zdHJ1Y3RzIGEgTWVya2xlIFRyZWUuXG4gICAgICogQWxsIG5vZGVzIGFuZCBsZWF2ZXMgYXJlIHN0b3JlZCBhcyBCdWZmZXJzLlxuICAgICAqIExvbmVseSBsZWFmIG5vZGVzIGFyZSBwcm9tb3RlZCB0byB0aGUgbmV4dCBsZXZlbCB1cCB3aXRob3V0IGJlaW5nIGhhc2hlZCBhZ2Fpbi5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsZWF2ZXMgLSBBcnJheSBvZiBoYXNoZWQgbGVhdmVzLiBFYWNoIGxlYWYgbXVzdCBiZSBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoRnVuY3Rpb24gLSBIYXNoIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaGFzaGluZyBsZWF2ZXMgYW5kIG5vZGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IE1lcmtsZVRyZWUgPSByZXF1aXJlKCdtZXJrbGV0cmVlanMnKVxuICAgICAqY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgICAgKlxuICAgICAqZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcbiAgICAgKiAgLy8gcmV0dXJucyBCdWZmZXJcbiAgICAgKiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgICAgKn1cbiAgICAgKlxuICAgICAqY29uc3QgbGVhdmVzID0gWydhJywgJ2InLCAnYyddLm1hcCh2YWx1ZSA9PiBrZWNjYWsodmFsdWUpKVxuICAgICAqXG4gICAgICpjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzLCBzaGEyNTYpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWF2ZXMsIGhhc2hGbiA9IHNoYTI1Nl8xLmRlZmF1bHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmR1cGxpY2F0ZU9kZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbmNhdGVuYXRvciA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQ7XG4gICAgICAgIHRoaXMuaGFzaExlYXZlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQml0Y29pblRyZWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZWF2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zb3J0TGVhdmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc29ydFBhaXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc29ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpbGxEZWZhdWx0SGFzaCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiBcImNvbXBsZXRlXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggXCJpc0JpdGNvaW5UcmVlXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmR1cGxpY2F0ZU9kZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uIFwiY29tcGxldGVcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBcImR1cGxpY2F0ZU9kZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JpdGNvaW5UcmVlID0gISFvcHRpb25zLmlzQml0Y29pblRyZWU7XG4gICAgICAgIHRoaXMuaGFzaExlYXZlcyA9ICEhb3B0aW9ucy5oYXNoTGVhdmVzO1xuICAgICAgICB0aGlzLnNvcnRMZWF2ZXMgPSAhIW9wdGlvbnMuc29ydExlYXZlcztcbiAgICAgICAgdGhpcy5zb3J0UGFpcnMgPSAhIW9wdGlvbnMuc29ydFBhaXJzO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gISFvcHRpb25zLmNvbXBsZXRlO1xuICAgICAgICBpZiAob3B0aW9ucy5maWxsRGVmYXVsdEhhc2gpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWxsRGVmYXVsdEhhc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxEZWZhdWx0SGFzaCA9IG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoKSB8fCB0eXBlb2Ygb3B0aW9ucy5maWxsRGVmYXVsdEhhc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsRGVmYXVsdEhhc2ggPSAoaWR4LCBoYXNoRm4pID0+IG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgXCJmaWxsRGVmYXVsdEhhc2hcIiBtdXN0IGJlIGEgZnVuY3Rpb24sIEJ1ZmZlciwgb3Igc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3J0ID0gISFvcHRpb25zLnNvcnQ7XG4gICAgICAgIGlmICh0aGlzLnNvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydExlYXZlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNvcnRQYWlycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kdXBsaWNhdGVPZGQgPSAhIW9wdGlvbnMuZHVwbGljYXRlT2RkO1xuICAgICAgICBpZiAob3B0aW9ucy5jb25jYXRlbmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29uY2F0ZW5hdG9yID0gb3B0aW9ucy5jb25jYXRlbmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNoRm4gPSB0aGlzLmJ1ZmZlcmlmeUZuKGhhc2hGbik7XG4gICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlcyhsZWF2ZXMpO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcGxldGU6IHRoaXMuY29tcGxldGUsXG4gICAgICAgICAgICBpc0JpdGNvaW5UcmVlOiB0aGlzLmlzQml0Y29pblRyZWUsXG4gICAgICAgICAgICBoYXNoTGVhdmVzOiB0aGlzLmhhc2hMZWF2ZXMsXG4gICAgICAgICAgICBzb3J0TGVhdmVzOiB0aGlzLnNvcnRMZWF2ZXMsXG4gICAgICAgICAgICBzb3J0UGFpcnM6IHRoaXMuc29ydFBhaXJzLFxuICAgICAgICAgICAgc29ydDogdGhpcy5zb3J0LFxuICAgICAgICAgICAgZmlsbERlZmF1bHRIYXNoOiAoX2IgPSAoX2EgPSB0aGlzLmZpbGxEZWZhdWx0SGFzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICBkdXBsaWNhdGVPZGQ6IHRoaXMuZHVwbGljYXRlT2RkXG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb2Nlc3NMZWF2ZXMobGVhdmVzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc2hMZWF2ZXMpIHtcbiAgICAgICAgICAgIGxlYXZlcyA9IGxlYXZlcy5tYXAodGhpcy5oYXNoRm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgICAgIGlmICh0aGlzLnNvcnRMZWF2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMubGVhdmVzID0gdGhpcy5sZWF2ZXMuc29ydChidWZmZXJfMS5CdWZmZXIuY29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsbERlZmF1bHRIYXNoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZWF2ZXMubGVuZ3RoOyBpIDwgTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMih0aGlzLmxlYXZlcy5sZW5ndGgpKSk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnB1c2godGhpcy5idWZmZXJpZnkodGhpcy5maWxsRGVmYXVsdEhhc2goaSwgdGhpcy5oYXNoRm4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVIYXNoZXModGhpcy5sZWF2ZXMpO1xuICAgIH1cbiAgICBjcmVhdGVIYXNoZXMobm9kZXMpIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBbbm9kZXNdO1xuICAgICAgICB3aGlsZSAobm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJJbmRleCA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJMaW1pdCA9IHRoaXMuY29tcGxldGUgJiYgbGF5ZXJJbmRleCA9PT0gMSAmJiAhTnVtYmVyLmlzSW50ZWdlcihNYXRoLmxvZzIobm9kZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICA/ICgyICogbm9kZXMubGVuZ3RoKSAtIChNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKG5vZGVzLmxlbmd0aCkpKSlcbiAgICAgICAgICAgICAgICA6IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBsYXllckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLnB1c2goLi4ubm9kZXMuc2xpY2UobGF5ZXJMaW1pdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSArIDEgPT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc2ggPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgYml0Y29pbiB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQml0Y29pbiBtZXRob2Qgb2YgZHVwbGljYXRpbmcgdGhlIG9kZCBlbmRpbmcgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoW2J1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdChkYXRhKSwgYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KGRhdGEpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQodGhpcy5oYXNoRm4oaGFzaCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLnB1c2goaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kdXBsaWNhdGVPZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgd2l0aCBjcmVhdGluZyBsYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBjb3B5IG9mIGhhc2ggYW5kIGNvbnRpbnVlIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGkgKyAxID09PSBub2Rlcy5sZW5ndGggPyBsZWZ0IDogbm9kZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBjb21iaW5lZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNCaXRjb2luVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCA9IFtidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQobGVmdCksIGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdChyaWdodCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQgPSBbbGVmdCwgcmlnaHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQuc29ydChidWZmZXJfMS5CdWZmZXIuY29tcGFyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoY29tYmluZWQpKTtcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgaGFzaCBpZiBiaXRjb2luIHRyZWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQodGhpcy5oYXNoRm4oaGFzaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKGhhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSB0aGlzLmxheWVyc1tsYXllckluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRMZWFmXG4gICAgICogQGRlc2MgQWRkcyBhIGxlYWYgdG8gdGhlIHRyZWUgYW5kIHJlLWNhbGN1bGF0ZXMgbGF5ZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gLSBMZWFmXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAtIFNldCB0byB0cnVlIGlmIHRoZSBsZWFmIHNob3VsZCBiZSBoYXNoZWQgYmVmb3JlIGJlaW5nIGFkZGVkIHRvIHRyZWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICp0cmVlLmFkZExlYWYobmV3TGVhZilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGFkZExlYWYobGVhZiwgc2hvdWxkSGFzaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzaG91bGRIYXNoKSB7XG4gICAgICAgICAgICBsZWFmID0gdGhpcy5oYXNoRm4obGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVzKHRoaXMubGVhdmVzLmNvbmNhdChsZWFmKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZExlYXZlc1xuICAgICAqIEBkZXNjIEFkZHMgbXVsdGlwbGUgbGVhdmVzIHRvIHRoZSB0cmVlIGFuZCByZS1jYWxjdWxhdGVzIGxheWVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfEJ1ZmZlcltdfSAtIEFycmF5IG9mIGxlYXZlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gLSBTZXQgdG8gdHJ1ZSBpZiB0aGUgbGVhdmVzIHNob3VsZCBiZSBoYXNoZWQgYmVmb3JlIGJlaW5nIGFkZGVkIHRvIHRyZWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICp0cmVlLmFkZExlYXZlcyhuZXdMZWF2ZXMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBhZGRMZWF2ZXMobGVhdmVzLCBzaG91bGRIYXNoID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHNob3VsZEhhc2gpIHtcbiAgICAgICAgICAgIGxlYXZlcyA9IGxlYXZlcy5tYXAodGhpcy5oYXNoRm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlcyh0aGlzLmxlYXZlcy5jb25jYXQobGVhdmVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExlYXZlc1xuICAgICAqIEBkZXNjIFJldHVybnMgYXJyYXkgb2YgbGVhdmVzIG9mIE1lcmtsZSBUcmVlLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhdmVzID0gdHJlZS5nZXRMZWF2ZXMoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGVhdmVzKHZhbHVlcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNoTGVhdmVzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCh0aGlzLmhhc2hGbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ydExlYXZlcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuc29ydChidWZmZXJfMS5CdWZmZXIuY29tcGFyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVzLmZpbHRlcihsZWFmID0+IHRoaXMuYnVmZmVySW5kZXhPZih2YWx1ZXMsIGxlYWYsIHRoaXMuc29ydExlYXZlcykgIT09IC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExlYWZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBsZWFmIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gLSBJbmRleCBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWFmID0gdHJlZS5nZXRMZWFmKDEpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMZWFmKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmxlYXZlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlYXZlc1tpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExlYWZJbmRleFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBsZWFmLCBvciAtMSBpZiB0aGUgbGVhZiBpcyBub3QgZm91bmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSAtIFRhcmdldCBsZWFmXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhZiA9IEJ1ZmZlci5mcm9tKCdhYmMnKVxuICAgICAqY29uc3QgaW5kZXggPSB0cmVlLmdldExlYWZJbmRleChsZWFmKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGVhZkluZGV4KHRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmJ1ZmZlcmlmeSh0YXJnZXQpO1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmdldExlYXZlcygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGVhZiA9IGxlYXZlc1tpXTtcbiAgICAgICAgICAgIGlmIChsZWFmLmVxdWFscyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMZWFmQ291bnRcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgbGVhdmVzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGNvdW50ID0gdHJlZS5nZXRMZWFmQ291bnQoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGVhZkNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhMZWF2ZXNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGFycmF5IG9mIGxlYXZlcyBvZiBNZXJrbGUgVHJlZSBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYXZlcyA9IHRyZWUuZ2V0SGV4TGVhdmVzKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleExlYXZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVzLm1hcChsZWFmID0+IHRoaXMuYnVmZmVyVG9IZXgobGVhZikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYXJzaGFsTGVhdmVzXG4gICAgICogQGRlc2MgUmV0dXJucyBhcnJheSBvZiBsZWF2ZXMgb2YgTWVya2xlIFRyZWUgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfEJ1ZmZlcltdfSAtIE1lcmtsZSB0cmVlIGxlYXZlc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gLSBMaXN0IG9mIGxlYXZlcyBhcyBKU09OIHN0cmluZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QganNvblN0ciA9IE1lcmtsZVRyZWUubWFyc2hhbExlYXZlcyhsZWF2ZXMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFyc2hhbExlYXZlcyhsZWF2ZXMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGxlYXZlcy5tYXAobGVhZiA9PiBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KGxlYWYpKSwgbnVsbCwgMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVubWFyc2hhbExlYXZlc1xuICAgICAqIEBkZXNjIFJldHVybnMgYXJyYXkgb2YgbGVhdmVzIG9mIE1lcmtsZSBUcmVlIGFzIGEgQnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IC0gSlNPTiBzdHJpbmdpZmllZCBsZWF2ZXNcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJbXX0gLSBVbm1hcnNoYWxsZWQgbGlzdCBvZiBsZWF2ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYXZlcyA9IE1lcmtsZVRyZWUudW5tYXJzaGFsTGVhdmVzKGpzb25TdHIpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5tYXJzaGFsTGVhdmVzKGpzb25TdHIpIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YganNvblN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoanNvblN0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvblN0ciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgcGFyc2VkID0ganNvblN0cjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdHlwZSBvZiBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyc2VkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBKU09OIHN0cmluZyB0byBiZSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQubWFwKE1lcmtsZVRyZWUuYnVmZmVyaWZ5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGF5ZXJzXG4gICAgICogQGRlc2MgUmV0dXJucyBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBvZiBhbGwgbGF5ZXJzIG9mIE1lcmtsZSBUcmVlLCBpbmNsdWRpbmcgbGVhdmVzIGFuZCByb290LlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsYXllcnMgPSB0cmVlLmdldExheWVycygpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMYXllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4TGF5ZXJzXG4gICAgICogQGRlc2MgUmV0dXJucyBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBvZiBhbGwgbGF5ZXJzIG9mIE1lcmtsZSBUcmVlLCBpbmNsdWRpbmcgbGVhdmVzIGFuZCByb290IGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsYXllcnMgPSB0cmVlLmdldEhleExheWVycygpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhMYXllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVycy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChpdGVtLm1hcChsYXllciA9PiB0aGlzLmJ1ZmZlclRvSGV4KGxheWVyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExheWVyc0ZsYXRcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHNpbmdsZSBmbGF0IGFycmF5IG9mIGFsbCBsYXllcnMgb2YgTWVya2xlIFRyZWUsIGluY2x1ZGluZyBsZWF2ZXMgYW5kIHJvb3QuXG4gICAgICogQHJldHVybiB7QnVmZmVyW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsYXllcnMgPSB0cmVlLmdldExheWVyc0ZsYXQoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzRmxhdCgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYWNjLnVuc2hpZnQoLi4uaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgbGF5ZXJzLnVuc2hpZnQoYnVmZmVyXzEuQnVmZmVyLmZyb20oWzBdKSk7XG4gICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleExheWVyc0ZsYXRcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHNpbmdsZSBmbGF0IGFycmF5IG9mIGFsbCBsYXllcnMgb2YgTWVya2xlIFRyZWUsIGluY2x1ZGluZyBsZWF2ZXMgYW5kIHJvb3QgYXMgaGV4IHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0SGV4TGF5ZXJzRmxhdCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhMYXllcnNGbGF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcnNGbGF0KCkubWFwKGxheWVyID0+IHRoaXMuYnVmZmVyVG9IZXgobGF5ZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGF5ZXJDb3VudFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBsYXllcnMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgY291bnQgPSB0cmVlLmdldExheWVyQ291bnQoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGF5ZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzKCkubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRSb290XG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgTWVya2xlIHJvb3QgaGFzaCBhcyBhIEJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCByb290ID0gdHJlZS5nZXRSb290KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzW3RoaXMubGF5ZXJzLmxlbmd0aCAtIDFdWzBdIHx8IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4Um9vdFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIE1lcmtsZSByb290IGhhc2ggYXMgYSBoZXggc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IHJvb3QgPSB0cmVlLmdldEhleFJvb3QoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4Um9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyVG9IZXgodGhpcy5nZXRSb290KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGZvciBhIHRhcmdldCBsZWFmLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBsZWFmIC0gVGFyZ2V0IGxlYWZcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIFRhcmdldCBsZWFmIGluZGV4IGluIGxlYXZlcyBhcnJheS5cbiAgICAgKiBVc2UgaWYgdGhlcmUgYXJlIGxlYXZlcyBjb250YWluaW5nIGR1cGxpY2F0ZSBkYXRhIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGl0LlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAtIEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBhIHBvc2l0aW9uIHByb3BlcnR5IG9mIHR5cGUgc3RyaW5nXG4gICAgICogd2l0aCB2YWx1ZXMgb2YgJ2xlZnQnIG9yICdyaWdodCcgYW5kIGEgZGF0YSBwcm9wZXJ0eSBvZiB0eXBlIEJ1ZmZlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2YobGVhdmVzWzJdKVxuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYXZlcyA9IFsnYScsICdiJywgJ2EnXS5tYXAodmFsdWUgPT4ga2VjY2FrKHZhbHVlKSlcbiAgICAgKmNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShsZWF2ZXMsIGtlY2NhaylcbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihsZWF2ZXNbMl0sIDIpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRQcm9vZihsZWFmLCBpbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIGxlYWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlYWYgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZWFmID0gdGhpcy5idWZmZXJpZnkobGVhZik7XG4gICAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbmRleCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKGxlYWYsIHRoaXMubGVhdmVzW2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpc1JpZ2h0Tm9kZSA9IGluZGV4ICUgMjtcbiAgICAgICAgICAgIGNvbnN0IHBhaXJJbmRleCA9IChpc1JpZ2h0Tm9kZSA/IGluZGV4IC0gMVxuICAgICAgICAgICAgICAgIDogdGhpcy5pc0JpdGNvaW5UcmVlICYmIGluZGV4ID09PSBsYXllci5sZW5ndGggLSAxICYmIGkgPCB0aGlzLmxheWVycy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb29mIEdlbmVyYXRpb24gZm9yIEJpdGNvaW4gVHJlZXNcbiAgICAgICAgICAgICAgICAgICAgPyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9vZiBHZW5lcmF0aW9uIGZvciBOb24tQml0Y29pbiBUcmVlc1xuICAgICAgICAgICAgICAgICAgICA6IGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAocGFpckluZGV4IDwgbGF5ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJvb2YucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpc1JpZ2h0Tm9kZSA/ICdsZWZ0JyA6ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxheWVyW3BhaXJJbmRleF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBpbmRleCB0byBwYXJlbnQgaW5kZXhcbiAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC8gMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4UHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZiBmb3IgYSB0YXJnZXQgbGVhZiBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZiAtIFRhcmdldCBsZWFmXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gLSBUYXJnZXQgbGVhZiBpbmRleCBpbiBsZWF2ZXMgYXJyYXkuXG4gICAgICogVXNlIGlmIHRoZXJlIGFyZSBsZWF2ZXMgY29udGFpbmluZyBkdXBsaWNhdGUgZGF0YSBpbiBvcmRlciB0byBkaXN0aW5ndWlzaCBpdC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBQcm9vZiBhcnJheSBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0SGV4UHJvb2YobGVhdmVzWzJdKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4UHJvb2YobGVhZiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YobGVhZiwgaW5kZXgpLm1hcChpdGVtID0+IHRoaXMuYnVmZmVyVG9IZXgoaXRlbS5kYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFByb29mc1xuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mcyBmb3IgYWxsIGxlYXZlcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSBwb3NpdGlvbiBwcm9wZXJ0eSBvZiB0eXBlIHN0cmluZ1xuICAgICAqIHdpdGggdmFsdWVzIG9mICdsZWZ0JyBvciAncmlnaHQnIGFuZCBhIGRhdGEgcHJvcGVydHkgb2YgdHlwZSBCdWZmZXIgZm9yIGFsbCBsZWF2ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgcHJvb2ZzID0gdHJlZS5nZXRQcm9vZnMoKVxuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYXZlcyA9IFsnYScsICdiJywgJ2EnXS5tYXAodmFsdWUgPT4ga2VjY2FrKHZhbHVlKSlcbiAgICAgKmNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShsZWF2ZXMsIGtlY2NhaylcbiAgICAgKmNvbnN0IHByb29mcyA9IHRyZWUuZ2V0UHJvb2ZzKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFByb29mcygpIHtcbiAgICAgICAgY29uc3QgcHJvb2YgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvb2ZzID0gW107XG4gICAgICAgIHRoaXMuZ2V0UHJvb2ZzREZTKHRoaXMubGF5ZXJzLmxlbmd0aCAtIDEsIDAsIHByb29mLCBwcm9vZnMpO1xuICAgICAgICByZXR1cm4gcHJvb2ZzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm9vZnNERlNcbiAgICAgKiBAZGVzYyBHZXQgYWxsIHByb29mcyB0aHJvdWdoIHNpbmdsZSB0cmF2ZXJzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50TGF5ZXIgLSBDdXJyZW50IGxheWVyIGluZGV4IGluIHRyYXZlcnNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEN1cnJlbnQgdGFydmVzZSBub2RlIGluZGV4IGluIHRyYXZlcnNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHByb29mIC0gUHJvb2YgY2hhaW4gZm9yIHNpbmdsZSBsZWFmLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHByb29mcyAtIFByb29mcyBmb3IgYWxsIGxlYXZlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0TGF5ZXJzKClcbiAgICAgKmNvbnN0IGluZGV4ID0gMDtcbiAgICAgKmxldCBwcm9vZiA9IFtdO1xuICAgICAqbGV0IHByb29mcyA9IFtdO1xuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mc0RGUyhsYXllcnMsIGluZGV4LCBwcm9vZiwgcHJvb2ZzKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0UHJvb2ZzREZTKGN1cnJlbnRMYXllciwgaW5kZXgsIHByb29mLCBwcm9vZnMpIHtcbiAgICAgICAgY29uc3QgaXNSaWdodE5vZGUgPSBpbmRleCAlIDI7XG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIWlzUmlnaHROb2RlKVxuICAgICAgICAgICAgICAgIHByb29mcy5wdXNoKFsuLi5wcm9vZl0ucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5sYXllcnNbY3VycmVudExheWVyXS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbY3VycmVudExheWVyXTtcbiAgICAgICAgY29uc3QgcGFpckluZGV4ID0gaXNSaWdodE5vZGUgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICAgIGxldCBwdXNoZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhaXJJbmRleCA8IGxheWVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb29mLnB1c2goe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpc1JpZ2h0Tm9kZSA/ICdsZWZ0JyA6ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgZGF0YTogbGF5ZXJbcGFpckluZGV4XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdGNoaWxkSW5kZXggPSBpbmRleCAqIDI7XG4gICAgICAgIGNvbnN0IHJpZ2h0Y2hpbGRJbmRleCA9IGluZGV4ICogMiArIDE7XG4gICAgICAgIHRoaXMuZ2V0UHJvb2ZzREZTKGN1cnJlbnRMYXllciAtIDEsIGxlZnRjaGlsZEluZGV4LCBwcm9vZiwgcHJvb2ZzKTtcbiAgICAgICAgdGhpcy5nZXRQcm9vZnNERlMoY3VycmVudExheWVyIC0gMSwgcmlnaHRjaGlsZEluZGV4LCBwcm9vZiwgcHJvb2ZzKTtcbiAgICAgICAgaWYgKHB1c2hlZClcbiAgICAgICAgICAgIHByb29mLnNwbGljZShwcm9vZi5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4UHJvb2ZzXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2ZzIGZvciBhbGwgbGVhdmVzIGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIFByb29mcyBhcnJheSBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBwcm9vZnMgPSB0cmVlLmdldEhleFByb29mcygpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhQcm9vZnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb29mcygpLm1hcChpdGVtID0+IHRoaXMuYnVmZmVyVG9IZXgoaXRlbS5kYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogZ2V0UG9zaXRpb25hbEhleFByb29mXG4gICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZiBmb3IgYSB0YXJnZXQgbGVhZiBhcyBoZXggc3RyaW5ncyBhbmQgdGhlIHBvc2l0aW9uIGluIGJpbmFyeSAobGVmdCA9PSAwKS5cbiAgICAqIEBwYXJhbSB7QnVmZmVyfSBsZWFmIC0gVGFyZ2V0IGxlYWZcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gVGFyZ2V0IGxlYWYgaW5kZXggaW4gbGVhdmVzIGFycmF5LlxuICAgICogVXNlIGlmIHRoZXJlIGFyZSBsZWF2ZXMgY29udGFpbmluZyBkdXBsaWNhdGUgZGF0YSBpbiBvcmRlciB0byBkaXN0aW5ndWlzaCBpdC5cbiAgICAqIEByZXR1cm4geyhzdHJpbmcgfCBudW1iZXIpW11bXX0gLSBQcm9vZiBhcnJheSBhcyBoZXggc3RyaW5ncy4gcG9zaXRpb24gYXQgaW5kZXggMFxuICAgICogQGV4YW1wbGVcbiAgICAqIGBgYGpzXG4gICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQb3NpdGlvbmFsSGV4UHJvb2YobGVhdmVzWzJdKVxuICAgICpgYGBcbiAgICAqL1xuICAgIGdldFBvc2l0aW9uYWxIZXhQcm9vZihsZWFmLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihsZWFmLCBpbmRleCkubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBpdGVtLnBvc2l0aW9uID09PSAnbGVmdCcgPyAwIDogMSxcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRvSGV4KGl0ZW0uZGF0YSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYXJzaGFsUHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHByb29mIGFycmF5IGFzIEpTT04gc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118T2JqZWN0W119IHByb29mIC0gTWVya2xlIHRyZWUgcHJvb2YgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gUHJvb2YgYXJyYXkgYXMgSlNPTiBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QganNvblN0ciA9IE1lcmtsZVRyZWUubWFyc2hhbFByb29mKHByb29mKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIG1hcnNoYWxQcm9vZihwcm9vZikge1xuICAgICAgICBjb25zdCBqc29uID0gcHJvb2YubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkYXRhOiBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KGl0ZW0uZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVubWFyc2hhbFByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgZm9yIGEgdGFyZ2V0IGxlYWYgYXMgYSBsaXN0IG9mIEJ1ZmZlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSAtIE1lcmtsZSB0cmVlIGxlYXZlc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IC0gTWFyc2hhbGxlZCBwcm9vZlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHByb29mID0gTWVya2xlVHJlZS51bm1hcnNoYWxQcm9vZihqc29uU3RyKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIHVubWFyc2hhbFByb29mKGpzb25TdHIpIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YganNvblN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoanNvblN0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvblN0ciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgcGFyc2VkID0ganNvblN0cjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdHlwZSBvZiBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyc2VkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBKU09OIHN0cmluZyB0byBiZSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZXJrbGVUcmVlLmJ1ZmZlcmlmeShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogTWVya2xlVHJlZS5idWZmZXJpZnkoaXRlbS5kYXRhKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGl0ZW0gdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbWFyc2hhbFRyZWUodHJlZSkge1xuICAgICAgICBjb25zdCByb290ID0gdHJlZS5nZXRIZXhSb290KCk7XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHRyZWUubGVhdmVzLm1hcChsZWFmID0+IE1lcmtsZVRyZWUuYnVmZmVyVG9IZXgobGVhZikpO1xuICAgICAgICBjb25zdCBsYXllcnMgPSB0cmVlLmdldEhleExheWVycygpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHJlZS5nZXRPcHRpb25zKCk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxheWVycyxcbiAgICAgICAgICAgIGxlYXZlc1xuICAgICAgICB9LCBudWxsLCAyKTtcbiAgICB9XG4gICAgc3RhdGljIHVubWFyc2hhbFRyZWUoanNvblN0ciwgaGFzaEZuID0gc2hhMjU2XzEuZGVmYXVsdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGpzb25TdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb25TdHIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IGpzb25TdHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHR5cGUgb2Ygc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBwYXJzZSBqc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZC5vcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJrbGVUcmVlKHBhcnNlZC5sZWF2ZXMsIGhhc2hGbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFByb29mSW5kaWNlc1xuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGluZGljZXMgZm9yIGdpdmVuIHRyZWUgaW5kaWNlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB0cmVlSW5kaWNlcyAtIFRyZWUgaW5kaWNlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCAtIFRyZWUgZGVwdGg7IG51bWJlciBvZiBsYXllcnMuXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IC0gUHJvb2YgaW5kaWNlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHByb29mSW5kaWNlcyA9IHRyZWUuZ2V0UHJvb2ZJbmRpY2VzKFsyLDUsNl0sIDQpXG4gICAgICpjb25zb2xlLmxvZyhwcm9vZkluZGljZXMpIC8vIFsgMjMsIDIwLCAxOSwgOCwgMyBdXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRQcm9vZkluZGljZXModHJlZUluZGljZXMsIGRlcHRoKSB7XG4gICAgICAgIGNvbnN0IGxlYWZDb3VudCA9IE1hdGgucG93KDIsIGRlcHRoKTtcbiAgICAgICAgbGV0IG1heGltYWxJbmRpY2VzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRyZWVJbmRpY2VzKSB7XG4gICAgICAgICAgICBsZXQgeCA9IGxlYWZDb3VudCArIGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKHggPiAxKSB7XG4gICAgICAgICAgICAgICAgbWF4aW1hbEluZGljZXMuYWRkKHggXiAxKTtcbiAgICAgICAgICAgICAgICB4ID0gKHggLyAyKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYSA9IHRyZWVJbmRpY2VzLm1hcChpbmRleCA9PiBsZWFmQ291bnQgKyBpbmRleCk7XG4gICAgICAgIGNvbnN0IGIgPSBBcnJheS5mcm9tKG1heGltYWxJbmRpY2VzKS5zb3J0KChhLCBiKSA9PiBhIC0gYikucmV2ZXJzZSgpO1xuICAgICAgICBtYXhpbWFsSW5kaWNlcyA9IGEuY29uY2F0KGIpO1xuICAgICAgICBjb25zdCByZWR1bmRhbnRJbmRpY2VzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCBvZiBtYXhpbWFsSW5kaWNlcykge1xuICAgICAgICAgICAgaWYgKCFyZWR1bmRhbnRJbmRpY2VzLmhhcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBwcm9vZi5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHVuZGFudEluZGljZXMuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWR1bmRhbnRJbmRpY2VzLmhhcyhpbmRleCBeIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC8gMikgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2YuZmlsdGVyKGluZGV4ID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhdHJlZUluZGljZXMuaW5jbHVkZXMoaW5kZXggLSBsZWFmQ291bnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UHJvb2ZJbmRpY2VzRm9yVW5ldmVuVHJlZShzb3J0ZWRMZWFmSW5kaWNlcywgbGVhdmVzQ291bnQpIHtcbiAgICAgICAgY29uc3QgZGVwdGggPSBNYXRoLmNlaWwoTWF0aC5sb2cyKGxlYXZlc0NvdW50KSk7XG4gICAgICAgIGNvbnN0IHVuZXZlbkxheWVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGVwdGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVuZXZlbkxheWVyID0gbGVhdmVzQ291bnQgJSAyICE9PSAwO1xuICAgICAgICAgICAgaWYgKHVuZXZlbkxheWVyKSB7XG4gICAgICAgICAgICAgICAgdW5ldmVuTGF5ZXJzLnB1c2goeyBpbmRleCwgbGVhdmVzQ291bnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWF2ZXNDb3VudCA9IE1hdGguY2VpbChsZWF2ZXNDb3VudCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb29mSW5kaWNlcyA9IFtdO1xuICAgICAgICBsZXQgbGF5ZXJOb2RlcyA9IHNvcnRlZExlYWZJbmRpY2VzO1xuICAgICAgICBmb3IgKGxldCBsYXllckluZGV4ID0gMDsgbGF5ZXJJbmRleCA8IGRlcHRoOyBsYXllckluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdJbmRpY2VzID0gbGF5ZXJOb2Rlcy5tYXAoKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHJvb2ZOb2RlSW5kaWNlcyA9IHNpYmxpbmdJbmRpY2VzLmZpbHRlcigoaW5kZXgpID0+ICFsYXllck5vZGVzLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICAgICAgICBjb25zdCB1bmV2ZW5MYXllciA9IHVuZXZlbkxheWVycy5maW5kKCh7IGluZGV4IH0pID0+IGluZGV4ID09PSBsYXllckluZGV4KTtcbiAgICAgICAgICAgIGlmICh1bmV2ZW5MYXllciAmJiBsYXllck5vZGVzLmluY2x1ZGVzKHVuZXZlbkxheWVyLmxlYXZlc0NvdW50IC0gMSkpIHtcbiAgICAgICAgICAgICAgICBwcm9vZk5vZGVJbmRpY2VzID0gcHJvb2ZOb2RlSW5kaWNlcy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9vZkluZGljZXMucHVzaChwcm9vZk5vZGVJbmRpY2VzKTtcbiAgICAgICAgICAgIGxheWVyTm9kZXMgPSBbLi4ubmV3IFNldChsYXllck5vZGVzLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4ICsgMSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggLSAxKSAvIDI7XG4gICAgICAgICAgICAgICAgfSkpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2ZJbmRpY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRNdWx0aVByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbXVsdGlwcm9vZiBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGluZGljZXMgLSBUcmVlIGluZGljZXMuXG4gICAgICogQHJldHVybiB7QnVmZmVyW119IC0gTXVsdGlwcm9vZnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRpY2VzID0gWzIsIDUsIDZdXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0TXVsdGlQcm9vZihpbmRpY2VzKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TXVsdGlQcm9vZih0cmVlLCBpbmRpY2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBGb3IgY29ycmVjdCBtdWx0aVByb29mcyBpdFxcJ3Mgc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gc2V0IGNvbXBsZXRlOiB0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICAgICAgICBpbmRpY2VzID0gdHJlZTtcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLmdldExheWVyc0ZsYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1VuZXZlbiA9IHRoaXMuaXNVbmV2ZW5UcmVlKCk7XG4gICAgICAgIGlmIChpc1VuZXZlbikge1xuICAgICAgICAgICAgaWYgKGluZGljZXMuZXZlcnkoTnVtYmVyLmlzSW50ZWdlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aVByb29mRm9yVW5ldmVuVHJlZShpbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluZGljZXMuZXZlcnkoTnVtYmVyLmlzSW50ZWdlcikpIHtcbiAgICAgICAgICAgIGxldCBlbHMgPSBpbmRpY2VzO1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ydFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgZWxzID0gZWxzLnNvcnQoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlkcyA9IGVscy5tYXAoKGVsKSA9PiB0aGlzLmJ1ZmZlckluZGV4T2YodGhpcy5sZWF2ZXMsIGVsLCB0aGlzLnNvcnRMZWF2ZXMpKS5zb3J0KChhLCBiKSA9PiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xKTtcbiAgICAgICAgICAgIGlmICghaWRzLmV2ZXJ5KChpZHgpID0+IGlkeCAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIE1lcmtsZSB0cmVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICAgICAgICBsZXQgbmV4dElkcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaWRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWlyRWxlbWVudCA9IHRoaXMuZ2V0UGFpck5vZGUobGF5ZXIsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlcy5wdXNoKGxheWVyW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFpckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb29mLnB1c2gocGFpckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHRJZHMucHVzaCgoaWR4IC8gMikgfCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWRzID0gbmV4dElkcy5maWx0ZXIoKHZhbHVlLCBpLCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpKTtcbiAgICAgICAgICAgICAgICBuZXh0SWRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvb2YuZmlsdGVyKCh2YWx1ZSkgPT4gIWhhc2hlcy5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb29mSW5kaWNlcyhpbmRpY2VzLCBNYXRoLmxvZzIoKHRyZWUubGVuZ3RoIC8gMikgfCAwKSkubWFwKGluZGV4ID0+IHRyZWVbaW5kZXhdKTtcbiAgICB9XG4gICAgZ2V0TXVsdGlQcm9vZkZvclVuZXZlblRyZWUodHJlZSwgaW5kaWNlcykge1xuICAgICAgICBpZiAoIWluZGljZXMpIHtcbiAgICAgICAgICAgIGluZGljZXMgPSB0cmVlO1xuICAgICAgICAgICAgdHJlZSA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb29mSGFzaGVzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50TGF5ZXJJbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgZm9yIChjb25zdCB0cmVlTGF5ZXIgb2YgdHJlZSkge1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgY3VycmVudExheWVySW5kaWNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRMYXllckluZGljZXMuaW5jbHVkZXMoaWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVMYXllcltpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ3MucHVzaCh0cmVlTGF5ZXJbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVySW5kaWNlcy5pbmNsdWRlcyhpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTGF5ZXJbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ3MucHVzaCh0cmVlTGF5ZXJbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb29mSGFzaGVzID0gcHJvb2ZIYXNoZXMuY29uY2F0KHNpYmxpbmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUluZGljZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGN1cnJlbnRMYXllckluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUluZGljZXMuYWRkKGluZGV4IC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUluZGljZXMuYWRkKChpbmRleCArIDEpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVJbmRpY2VzLmFkZCgoaW5kZXggLSAxKSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudExheWVySW5kaWNlcyA9IEFycmF5LmZyb20odW5pcXVlSW5kaWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb29mSGFzaGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhNdWx0aVByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbXVsdGlwcm9vZiBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzIGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGluZGljZXMgLSBUcmVlIGluZGljZXMuXG4gICAgICogQHJldHVybiB7U3RyaW5nW119IC0gTXVsdGlwcm9vZnMgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldEhleE11bHRpUHJvb2YoaW5kaWNlcylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aVByb29mKHRyZWUsIGluZGljZXMpLm1hcCgoeCkgPT4gdGhpcy5idWZmZXJUb0hleCh4KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFByb29mRmxhZ3NcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGxpc3Qgb2YgYm9vbGVhbnMgd2hlcmUgcHJvb2ZzIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgaGFzaGluZy5cbiAgICAgKiBQcm9vZiBmbGFncyBhcmUgdXNlZCBpbiB0aGUgU29saWRpdHkgbXVsdGlwcm9vZiB2ZXJpZmllcnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXXxCdWZmZXJbXX0gbGVhdmVzXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gcHJvb2ZzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbltdfSAtIEJvb2xlYW4gZmxhZ3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRpY2VzID0gWzIsIDUsIDZdXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0TXVsdGlQcm9vZihpbmRpY2VzKVxuICAgICAqY29uc3QgcHJvb2ZGbGFncyA9IHRyZWUuZ2V0UHJvb2ZGbGFncyhsZWF2ZXMsIHByb29mKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0UHJvb2ZGbGFncyhsZWF2ZXMsIHByb29mcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGVhdmVzKSB8fCBsZWF2ZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnB1dHMhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkcztcbiAgICAgICAgaWYgKGxlYXZlcy5ldmVyeShOdW1iZXIuaXNJbnRlZ2VyKSkge1xuICAgICAgICAgICAgaWRzID0gWy4uLmxlYXZlc10uc29ydCgoYSwgYikgPT4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMSk7IC8vIEluZGljZXMgd2hlcmUgcGFzc2VkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZHMgPSBsZWF2ZXMubWFwKChlbCkgPT4gdGhpcy5idWZmZXJJbmRleE9mKHRoaXMubGVhdmVzLCBlbCwgdGhpcy5zb3J0TGVhdmVzKSkuc29ydCgoYSwgYikgPT4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpZHMuZXZlcnkoKGlkeCkgPT4gaWR4ICE9PSAtMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBkb2VzIG5vdCBleGlzdCBpbiBNZXJrbGUgdHJlZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9wcm9vZnMgPSBwcm9vZnMubWFwKGl0ZW0gPT4gdGhpcy5idWZmZXJpZnkoaXRlbSkpO1xuICAgICAgICBjb25zdCB0ZXN0ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tpbmRleF07XG4gICAgICAgICAgICBpZHMgPSBpZHMucmVkdWNlKChpZHMsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNraXBwZWQgPSB0ZXN0ZWQuaW5jbHVkZXMobGF5ZXJbaWR4XSk7XG4gICAgICAgICAgICAgICAgaWYgKCFza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXJFbGVtZW50ID0gdGhpcy5nZXRQYWlyTm9kZShsYXllciwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvb2ZVc2VkID0gX3Byb29mcy5pbmNsdWRlcyhsYXllcltpZHhdKSB8fCBfcHJvb2ZzLmluY2x1ZGVzKHBhaXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcGFpckVsZW1lbnQgJiYgZmxhZ3MucHVzaCghcHJvb2ZVc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGVkLnB1c2gobGF5ZXJbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RlZC5wdXNoKHBhaXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goKGlkeCAvIDIpIHwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHZlcmlmeVxuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvb2YgcGF0aCAoYXJyYXkgb2YgaGFzaGVzKSBjYW4gY29ubmVjdCB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiB0byB0aGUgTWVya2xlIHJvb3QuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcHJvb2YgLSBBcnJheSBvZiBwcm9vZiBvYmplY3RzIHRoYXQgc2hvdWxkIGNvbm5lY3RcbiAgICAgKiB0YXJnZXQgbm9kZSB0byBNZXJrbGUgcm9vdC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0Tm9kZSAtIFRhcmdldCBub2RlIEJ1ZmZlclxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSByb290IC0gTWVya2xlIHJvb3QgQnVmZmVyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IHJvb3QgPSB0cmVlLmdldFJvb3QoKVxuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKGxlYXZlc1syXSlcbiAgICAgKmNvbnN0IHZlcmlmaWVkID0gdHJlZS52ZXJpZnkocHJvb2YsIGxlYXZlc1syXSwgcm9vdClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHZlcmlmeShwcm9vZiwgdGFyZ2V0Tm9kZSwgcm9vdCkge1xuICAgICAgICBsZXQgaGFzaCA9IHRoaXMuYnVmZmVyaWZ5KHRhcmdldE5vZGUpO1xuICAgICAgICByb290ID0gdGhpcy5idWZmZXJpZnkocm9vdCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9vZikgfHxcbiAgICAgICAgICAgICF0YXJnZXROb2RlIHx8XG4gICAgICAgICAgICAhcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvb2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwcm9vZltpXTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0xlZnROb2RlID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGNhc2UgZm9yIHdoZW4gcHJvb2YgaXMgaGV4IHZhbHVlcyBvbmx5XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuYnVmZmVyaWZ5KG5vZGUpO1xuICAgICAgICAgICAgICAgIGlzTGVmdE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgICAgIGlzTGVmdE5vZGUgPSAobm9kZVswXSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuYnVmZmVyaWZ5KG5vZGVbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaXNMZWZ0Tm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuYnVmZmVyaWZ5KG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgaXNMZWZ0Tm9kZSA9IChub2RlLnBvc2l0aW9uID09PSAnbGVmdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub2RlIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNCaXRjb2luVHJlZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQoaGFzaCkpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnNbaXNMZWZ0Tm9kZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KGRhdGEpKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICAgICAgICAgIGhhc2ggPSBidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQodGhpcy5oYXNoRm4oaGFzaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ydFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJfMS5CdWZmZXIuY29tcGFyZShoYXNoLCBkYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChoYXNoLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZGF0YSwgaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnNbaXNMZWZ0Tm9kZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuY29tcGFyZShoYXNoLCByb290KSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdmVyaWZ5TXVsdGlQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB0aGUgbXVsdGlwcm9vZnMgY2FuIGNvbm5lY3QgdGhlIGxlYXZlcyB0byB0aGUgTWVya2xlIHJvb3QuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHJvb3QgLSBNZXJrbGUgdHJlZSByb290XG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcHJvb2ZJbmRpY2VzIC0gTGVhdmUgaW5kaWNlcyBmb3IgcHJvb2ZcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBwcm9vZkxlYXZlcyAtIExlYWYgdmFsdWVzIGF0IGluZGljZXMgZm9yIHByb29mXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlYXZlc0NvdW50IC0gQ291bnQgb2Ygb3JpZ2luYWwgbGVhdmVzXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gcHJvb2YgLSBNdWx0aXByb29mcyBnaXZlbiBpbmRpY2VzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYXZlcyA9IHRyZWUuZ2V0TGVhdmVzKClcbiAgICAgKmNvbnN0IHJvb3QgPSB0cmVlLmdldFJvb3QoKVxuICAgICAqY29uc3QgdHJlZUZsYXQgPSB0cmVlLmdldExheWVyc0ZsYXQoKVxuICAgICAqY29uc3QgbGVhdmVzQ291bnQgPSBsZWF2ZXMubGVuZ3RoXG4gICAgICpjb25zdCBwcm9vZkluZGljZXMgPSBbMiwgNSwgNl1cbiAgICAgKmNvbnN0IHByb29mTGVhdmVzID0gcHJvb2ZJbmRpY2VzLm1hcChpID0+IGxlYXZlc1tpXSlcbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRNdWx0aVByb29mKHRyZWVGbGF0LCBpbmRpY2VzKVxuICAgICAqY29uc3QgdmVyaWZpZWQgPSB0cmVlLnZlcmlmeU11bHRpUHJvb2Yocm9vdCwgcHJvb2ZJbmRpY2VzLCBwcm9vZkxlYXZlcywgbGVhdmVzQ291bnQsIHByb29mKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgdmVyaWZ5TXVsdGlQcm9vZihyb290LCBwcm9vZkluZGljZXMsIHByb29mTGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpIHtcbiAgICAgICAgY29uc3QgaXNVbmV2ZW4gPSB0aGlzLmlzVW5ldmVuVHJlZSgpO1xuICAgICAgICBpZiAoaXNVbmV2ZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvbWJpbmUgdGhlc2UgZnVuY3Rpb25zIGFuZCBzaW1wbGlmeVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5TXVsdGlQcm9vZkZvclVuZXZlblRyZWUocm9vdCwgcHJvb2ZJbmRpY2VzLCBwcm9vZkxlYXZlcywgbGVhdmVzQ291bnQsIHByb29mKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXB0aCA9IE1hdGguY2VpbChNYXRoLmxvZzIobGVhdmVzQ291bnQpKTtcbiAgICAgICAgcm9vdCA9IHRoaXMuYnVmZmVyaWZ5KHJvb3QpO1xuICAgICAgICBwcm9vZkxlYXZlcyA9IHByb29mTGVhdmVzLm1hcChsZWFmID0+IHRoaXMuYnVmZmVyaWZ5KGxlYWYpKTtcbiAgICAgICAgcHJvb2YgPSBwcm9vZi5tYXAobGVhZiA9PiB0aGlzLmJ1ZmZlcmlmeShsZWFmKSk7XG4gICAgICAgIGNvbnN0IHRyZWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGxlYWZdIG9mIHRoaXMuemlwKHByb29mSW5kaWNlcywgcHJvb2ZMZWF2ZXMpKSB7XG4gICAgICAgICAgICB0cmVlWyhNYXRoLnBvdygyLCBkZXB0aCkpICsgaW5kZXhdID0gbGVhZjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgcHJvb2ZpdGVtXSBvZiB0aGlzLnppcCh0aGlzLmdldFByb29mSW5kaWNlcyhwcm9vZkluZGljZXMsIGRlcHRoKSwgcHJvb2YpKSB7XG4gICAgICAgICAgICB0cmVlW2luZGV4XSA9IHByb29maXRlbTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXhxdWV1ZSA9IE9iamVjdC5rZXlzKHRyZWUpLm1hcCh2YWx1ZSA9PiArdmFsdWUpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgaW5kZXhxdWV1ZSA9IGluZGV4cXVldWUuc2xpY2UoMCwgaW5kZXhxdWV1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4cXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4cXVldWVbaV07XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMiAmJiAoe30pLmhhc093blByb3BlcnR5LmNhbGwodHJlZSwgaW5kZXggXiAxKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYWlyID0gW3RyZWVbaW5kZXggLSAoaW5kZXggJSAyKV0sIHRyZWVbaW5kZXggLSAoaW5kZXggJSAyKSArIDFdXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpciA9IHBhaXIuc29ydChidWZmZXJfMS5CdWZmZXIuY29tcGFyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBwYWlyWzFdID8gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IocGFpcikpIDogcGFpclswXTtcbiAgICAgICAgICAgICAgICB0cmVlWyhpbmRleCAvIDIpIHwgMF0gPSBoYXNoO1xuICAgICAgICAgICAgICAgIGluZGV4cXVldWUucHVzaCgoaW5kZXggLyAyKSB8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJvb2ZJbmRpY2VzLmxlbmd0aCB8fCAoKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyZWUsIDEpICYmIHRyZWVbMV0uZXF1YWxzKHJvb3QpKTtcbiAgICB9XG4gICAgdmVyaWZ5TXVsdGlQcm9vZldpdGhGbGFncyhyb290LCBsZWF2ZXMsIHByb29mcywgcHJvb2ZGbGFnKSB7XG4gICAgICAgIHJvb3QgPSB0aGlzLmJ1ZmZlcmlmeShyb290KTtcbiAgICAgICAgbGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgICAgIHByb29mcyA9IHByb29mcy5tYXAodGhpcy5idWZmZXJpZnkpO1xuICAgICAgICBjb25zdCBsZWF2ZXNMZW4gPSBsZWF2ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCB0b3RhbEhhc2hlcyA9IHByb29mRmxhZy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgICAgICBsZXQgbGVhZlBvcyA9IDA7XG4gICAgICAgIGxldCBoYXNoUG9zID0gMDtcbiAgICAgICAgbGV0IHByb29mUG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEhhc2hlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBidWZBID0gcHJvb2ZGbGFnW2ldID8gKGxlYWZQb3MgPCBsZWF2ZXNMZW4gPyBsZWF2ZXNbbGVhZlBvcysrXSA6IGhhc2hlc1toYXNoUG9zKytdKSA6IHByb29mc1twcm9vZlBvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZkIgPSBsZWFmUG9zIDwgbGVhdmVzTGVuID8gbGVhdmVzW2xlYWZQb3MrK10gOiBoYXNoZXNbaGFzaFBvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbYnVmQSwgYnVmQl0uc29ydChidWZmZXJfMS5CdWZmZXIuY29tcGFyZSk7XG4gICAgICAgICAgICBoYXNoZXNbaV0gPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihidWZmZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKGhhc2hlc1t0b3RhbEhhc2hlcyAtIDFdLCByb290KSA9PT0gMDtcbiAgICB9XG4gICAgdmVyaWZ5TXVsdGlQcm9vZkZvclVuZXZlblRyZWUocm9vdCwgaW5kaWNlcywgbGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpIHtcbiAgICAgICAgcm9vdCA9IHRoaXMuYnVmZmVyaWZ5KHJvb3QpO1xuICAgICAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgICAgICBwcm9vZiA9IHByb29mLm1hcChsZWFmID0+IHRoaXMuYnVmZmVyaWZ5KGxlYWYpKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWRSb290ID0gdGhpcy5jYWxjdWxhdGVSb290Rm9yVW5ldmVuVHJlZShpbmRpY2VzLCBsZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZik7XG4gICAgICAgIHJldHVybiByb290LmVxdWFscyhjb21wdXRlZFJvb3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXREZXB0aFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHRyZWUgZGVwdGggKG51bWJlciBvZiBsYXllcnMpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgZGVwdGggPSB0cmVlLmdldERlcHRoKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldERlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcnMoKS5sZW5ndGggLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMYXllcnNBc09iamVjdFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGxheWVycyBhcyBuZXN0ZWQgb2JqZWN0cyBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGF5ZXJzT2JqID0gdHJlZS5nZXRMYXllcnNBc09iamVjdCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRMYXllcnNBc09iamVjdCgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoKS5tYXAoKGxheWVyKSA9PiBsYXllci5tYXAoKHZhbHVlKSA9PiB0aGlzLmJ1ZmZlclRvSGV4KHZhbHVlLCBmYWxzZSkpKTtcbiAgICAgICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxheWVyc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHsgW2xheWVyc1tpXVtqXV06IG51bGwgfTtcbiAgICAgICAgICAgICAgICBpZiAob2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IG9ianMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWtleSA9IE9iamVjdC5rZXlzKGEpWzBdO1xuICAgICAgICAgICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXVtha2V5XSA9IGFbYWtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IG9ianMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJrZXkgPSBPYmplY3Qua2V5cyhiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dW2JrZXldID0gYltia2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnIucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Jqcy5wdXNoKC4uLmFycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ianNbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHZlcmlmeVxuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvb2YgcGF0aCAoYXJyYXkgb2YgaGFzaGVzKSBjYW4gY29ubmVjdCB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiB0byB0aGUgTWVya2xlIHJvb3QuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcHJvb2YgLSBBcnJheSBvZiBwcm9vZiBvYmplY3RzIHRoYXQgc2hvdWxkIGNvbm5lY3RcbiAgICAgKiB0YXJnZXQgbm9kZSB0byBNZXJrbGUgcm9vdC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0Tm9kZSAtIFRhcmdldCBub2RlIEJ1ZmZlclxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSByb290IC0gTWVya2xlIHJvb3QgQnVmZmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaEZ1bmN0aW9uIC0gSGFzaCBmdW5jdGlvbiBmb3IgaGFzaGluZyBsZWF2ZXMgYW5kIG5vZGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgdmVyaWZpZWQgPSBNZXJrbGVUcmVlLnZlcmlmeShwcm9vZiwgbGVhZiwgcm9vdCwgc2hhMjU2LCBvcHRpb25zKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIHZlcmlmeShwcm9vZiwgdGFyZ2V0Tm9kZSwgcm9vdCwgaGFzaEZuID0gc2hhMjU2XzEuZGVmYXVsdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShbXSwgaGFzaEZuLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRyZWUudmVyaWZ5KHByb29mLCB0YXJnZXROb2RlLCByb290KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TXVsdGlQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIG11bHRpcHJvb2YgZm9yIGdpdmVuIHRyZWUgaW5kaWNlcy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSB0cmVlIC0gVHJlZSBhcyBhIGZsYXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gaW5kaWNlcyAtIFRyZWUgaW5kaWNlcy5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJbXX0gLSBNdWx0aXByb29mc1xuICAgICAqXG4gICAgICpAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBmbGF0VHJlZSA9IHRyZWUuZ2V0TGF5ZXJzRmxhdCgpXG4gICAgICpjb25zdCBpbmRpY2VzID0gWzIsIDUsIDZdXG4gICAgICpjb25zdCBwcm9vZiA9IE1lcmtsZVRyZWUuZ2V0TXVsdGlQcm9vZihmbGF0VHJlZSwgaW5kaWNlcylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNdWx0aVByb29mKHRyZWUsIGluZGljZXMpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBNZXJrbGVUcmVlKFtdKTtcbiAgICAgICAgcmV0dXJuIHQuZ2V0TXVsdGlQcm9vZih0cmVlLCBpbmRpY2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVzZXRUcmVlXG4gICAgICogQGRlc2MgUmVzZXRzIHRoZSB0cmVlIGJ5IGNsZWFyaW5nIHRoZSBsZWF2ZXMgYW5kIGxheWVycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKnRyZWUucmVzZXRUcmVlKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHJlc2V0VHJlZSgpIHtcbiAgICAgICAgdGhpcy5sZWF2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UGFpck5vZGVcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBub2RlIGF0IHRoZSBpbmRleCBmb3IgZ2l2ZW4gbGF5ZXIuXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGF5ZXIgLSBUcmVlIGxheWVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gSW5kZXggYXQgbGF5ZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSAtIE5vZGVcbiAgICAgKlxuICAgICAqQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3Qgbm9kZSA9IHRyZWUuZ2V0UGFpck5vZGUobGF5ZXIsIGluZGV4KVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0UGFpck5vZGUobGF5ZXIsIGlkeCkge1xuICAgICAgICBjb25zdCBwYWlySWR4ID0gaWR4ICUgMiA9PT0gMCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICBpZiAocGFpcklkeCA8IGxheWVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxheWVyW3BhaXJJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdG9UcmVlU3RyaW5nXG4gICAgICogQGRlc2MgUmV0dXJucyBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVya2xlIHRyZWUgYXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc29sZS5sb2codHJlZS50b1RyZWVTdHJpbmcoKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRvVHJlZVN0cmluZygpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5nZXRMYXllcnNBc09iamVjdCgpO1xuICAgICAgICByZXR1cm4gdHJlZWlmeV8xLmRlZmF1bHQuYXNUcmVlKG9iaiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRvU3RyaW5nXG4gICAgICogQGRlc2MgUmV0dXJucyBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVya2xlIHRyZWUgYXMgYSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zb2xlLmxvZyh0cmVlLnRvU3RyaW5nKCkpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9UcmVlU3RyaW5nKCk7XG4gICAgfVxuICAgIGlzVW5ldmVuVHJlZSh0cmVlTGF5ZXJzKSB7XG4gICAgICAgIGNvbnN0IGRlcHRoID0gKHRyZWVMYXllcnMgPT09IG51bGwgfHwgdHJlZUxheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJlZUxheWVycy5sZW5ndGgpIHx8IHRoaXMuZ2V0RGVwdGgoKTtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzUG93T2YyKGRlcHRoKTtcbiAgICB9XG4gICAgaXNQb3dPZjIodikge1xuICAgICAgICByZXR1cm4gdiAmJiAhKHYgJiAodiAtIDEpKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlUm9vdEZvclVuZXZlblRyZWUobGVhZkluZGljZXMsIGxlYWZIYXNoZXMsIHRvdGFsTGVhdmVzQ291bnQsIHByb29mSGFzaGVzKSB7XG4gICAgICAgIGNvbnN0IGxlYWZUdXBsZXMgPSB0aGlzLnppcChsZWFmSW5kaWNlcywgbGVhZkhhc2hlcykuc29ydCgoW2luZGV4QV0sIFtpbmRleEJdKSA9PiBpbmRleEEgLSBpbmRleEIpO1xuICAgICAgICBjb25zdCBsZWFmVHVwbGVJbmRpY2VzID0gbGVhZlR1cGxlcy5tYXAoKFtpbmRleF0pID0+IGluZGV4KTtcbiAgICAgICAgY29uc3QgcHJvb2ZJbmRpY2VzID0gdGhpcy5nZXRQcm9vZkluZGljZXNGb3JVbmV2ZW5UcmVlKGxlYWZUdXBsZUluZGljZXMsIHRvdGFsTGVhdmVzQ291bnQpO1xuICAgICAgICBsZXQgbmV4dFNsaWNlU3RhcnQgPSAwO1xuICAgICAgICBjb25zdCBwcm9vZlR1cGxlc0J5TGF5ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvb2ZJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gcHJvb2ZJbmRpY2VzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc2xpY2VTdGFydCA9IG5leHRTbGljZVN0YXJ0O1xuICAgICAgICAgICAgbmV4dFNsaWNlU3RhcnQgKz0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBwcm9vZlR1cGxlc0J5TGF5ZXJzW2ldID0gdGhpcy56aXAoaW5kaWNlcywgcHJvb2ZIYXNoZXMuc2xpY2Uoc2xpY2VTdGFydCwgbmV4dFNsaWNlU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmVlID0gW2xlYWZUdXBsZXNdO1xuICAgICAgICBmb3IgKGxldCBsYXllckluZGV4ID0gMDsgbGF5ZXJJbmRleCA8IHByb29mVHVwbGVzQnlMYXllcnMubGVuZ3RoOyBsYXllckluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IHByb29mVHVwbGVzQnlMYXllcnNbbGF5ZXJJbmRleF0uY29uY2F0KHRyZWVbbGF5ZXJJbmRleF0pLnNvcnQoKFtpbmRleEFdLCBbaW5kZXhCXSkgPT4gaW5kZXhBIC0gaW5kZXhCKVxuICAgICAgICAgICAgICAgIC5tYXAoKFssIGhhc2hdKSA9PiBoYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0cmVlW2xheWVySW5kZXhdLm1hcCgoW2xheWVySW5kZXhdKSA9PiBsYXllckluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluZGljZXMgPSBbLi4ubmV3IFNldChzLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4ICsgMSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggLSAxKSAvIDI7XG4gICAgICAgICAgICAgICAgfSkpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudExheWVyID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudEluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlVHJlZUluZGV4ID0gcGFyZW50SW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZBID0gY3VycmVudExheWVyW2kgKiAyXTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZCID0gY3VycmVudExheWVyW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGJ1ZkIgPyB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihbYnVmQSwgYnVmQl0pKSA6IGJ1ZkE7XG4gICAgICAgICAgICAgICAgcGFyZW50TGF5ZXIucHVzaChbcGFyZW50Tm9kZVRyZWVJbmRleCwgaGFzaF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJlZS5wdXNoKHBhcmVudExheWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZVt0cmVlLmxlbmd0aCAtIDFdWzBdWzFdO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVya2xlVHJlZSA9IE1lcmtsZVRyZWU7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICA7XG4gICAgd2luZG93Lk1lcmtsZVRyZWUgPSBNZXJrbGVUcmVlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVya2xlVHJlZTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNZXJrbGVUcmVlIiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwiYnVmZmVyX3JldmVyc2VfMSIsInNoYTI1Nl8xIiwidHJlZWlmeV8xIiwiQmFzZV8xIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwibGVhdmVzIiwiaGFzaEZuIiwib3B0aW9ucyIsImR1cGxpY2F0ZU9kZCIsImNvbmNhdGVuYXRvciIsIkJ1ZmZlciIsImNvbmNhdCIsImhhc2hMZWF2ZXMiLCJpc0JpdGNvaW5UcmVlIiwibGF5ZXJzIiwic29ydExlYXZlcyIsInNvcnRQYWlycyIsInNvcnQiLCJmaWxsRGVmYXVsdEhhc2giLCJjb21wbGV0ZSIsIkVycm9yIiwiaXNCdWZmZXIiLCJpZHgiLCJidWZmZXJpZnlGbiIsInByb2Nlc3NMZWF2ZXMiLCJnZXRPcHRpb25zIiwiX2EiLCJfYiIsInRvU3RyaW5nIiwibWFwIiwiYnVmZmVyaWZ5IiwiY29tcGFyZSIsImkiLCJsZW5ndGgiLCJNYXRoIiwicG93IiwiY2VpbCIsImxvZzIiLCJwdXNoIiwiY3JlYXRlSGFzaGVzIiwibm9kZXMiLCJsYXllckluZGV4IiwibGF5ZXJMaW1pdCIsIk51bWJlciIsImlzSW50ZWdlciIsInNsaWNlIiwiZGF0YSIsImhhc2giLCJsZWZ0IiwicmlnaHQiLCJjb21iaW5lZCIsImFkZExlYWYiLCJsZWFmIiwic2hvdWxkSGFzaCIsImFkZExlYXZlcyIsImdldExlYXZlcyIsInZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsImZpbHRlciIsImJ1ZmZlckluZGV4T2YiLCJnZXRMZWFmIiwiaW5kZXgiLCJmcm9tIiwiZ2V0TGVhZkluZGV4IiwidGFyZ2V0IiwiZXF1YWxzIiwiZ2V0TGVhZkNvdW50IiwiZ2V0SGV4TGVhdmVzIiwiYnVmZmVyVG9IZXgiLCJtYXJzaGFsTGVhdmVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInVubWFyc2hhbExlYXZlcyIsImpzb25TdHIiLCJwYXJzZWQiLCJwYXJzZSIsImdldExheWVycyIsImdldEhleExheWVycyIsInJlZHVjZSIsImFjYyIsIml0ZW0iLCJsYXllciIsImdldExheWVyc0ZsYXQiLCJ1bnNoaWZ0IiwiZ2V0SGV4TGF5ZXJzRmxhdCIsImdldExheWVyQ291bnQiLCJnZXRSb290IiwiZ2V0SGV4Um9vdCIsImdldFByb29mIiwicHJvb2YiLCJpc1JpZ2h0Tm9kZSIsInBhaXJJbmRleCIsInBvc2l0aW9uIiwiZ2V0SGV4UHJvb2YiLCJnZXRQcm9vZnMiLCJwcm9vZnMiLCJnZXRQcm9vZnNERlMiLCJjdXJyZW50TGF5ZXIiLCJyZXZlcnNlIiwicHVzaGVkIiwibGVmdGNoaWxkSW5kZXgiLCJyaWdodGNoaWxkSW5kZXgiLCJzcGxpY2UiLCJnZXRIZXhQcm9vZnMiLCJnZXRQb3NpdGlvbmFsSGV4UHJvb2YiLCJtYXJzaGFsUHJvb2YiLCJqc29uIiwidW5tYXJzaGFsUHJvb2YiLCJtYXJzaGFsVHJlZSIsInRyZWUiLCJyb290IiwidW5tYXJzaGFsVHJlZSIsImFzc2lnbiIsImdldFByb29mSW5kaWNlcyIsInRyZWVJbmRpY2VzIiwiZGVwdGgiLCJsZWFmQ291bnQiLCJtYXhpbWFsSW5kaWNlcyIsIlNldCIsIngiLCJhZGQiLCJhIiwiYiIsInJlZHVuZGFudEluZGljZXMiLCJoYXMiLCJpbmNsdWRlcyIsImdldFByb29mSW5kaWNlc0ZvclVuZXZlblRyZWUiLCJzb3J0ZWRMZWFmSW5kaWNlcyIsImxlYXZlc0NvdW50IiwidW5ldmVuTGF5ZXJzIiwidW5ldmVuTGF5ZXIiLCJwcm9vZkluZGljZXMiLCJsYXllck5vZGVzIiwic2libGluZ0luZGljZXMiLCJwcm9vZk5vZGVJbmRpY2VzIiwiZmluZCIsImdldE11bHRpUHJvb2YiLCJpbmRpY2VzIiwiY29uc29sZSIsIndhcm4iLCJpc1VuZXZlbiIsImlzVW5ldmVuVHJlZSIsImV2ZXJ5IiwiZ2V0TXVsdGlQcm9vZkZvclVuZXZlblRyZWUiLCJlbHMiLCJpZHMiLCJlbCIsImhhc2hlcyIsIm5leHRJZHMiLCJqIiwicGFpckVsZW1lbnQiLCJnZXRQYWlyTm9kZSIsInNlbGYiLCJpbmRleE9mIiwicHJvb2ZIYXNoZXMiLCJjdXJyZW50TGF5ZXJJbmRpY2VzIiwidHJlZUxheWVyIiwic2libGluZ3MiLCJ1bmlxdWVJbmRpY2VzIiwiZ2V0SGV4TXVsdGlQcm9vZiIsImdldFByb29mRmxhZ3MiLCJfcHJvb2ZzIiwidGVzdGVkIiwiZmxhZ3MiLCJza2lwcGVkIiwicHJvb2ZVc2VkIiwidmVyaWZ5IiwidGFyZ2V0Tm9kZSIsIm5vZGUiLCJpc0xlZnROb2RlIiwiYnVmZmVycyIsInZlcmlmeU11bHRpUHJvb2YiLCJwcm9vZkxlYXZlcyIsInZlcmlmeU11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlIiwiemlwIiwicHJvb2ZpdGVtIiwiaW5kZXhxdWV1ZSIsImtleXMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwYWlyIiwidmVyaWZ5TXVsdGlQcm9vZldpdGhGbGFncyIsInByb29mRmxhZyIsImxlYXZlc0xlbiIsInRvdGFsSGFzaGVzIiwibGVhZlBvcyIsImhhc2hQb3MiLCJwcm9vZlBvcyIsImJ1ZkEiLCJidWZCIiwiY29tcHV0ZWRSb290IiwiY2FsY3VsYXRlUm9vdEZvclVuZXZlblRyZWUiLCJnZXREZXB0aCIsImdldExheWVyc0FzT2JqZWN0Iiwib2JqcyIsImFyciIsIm9iaiIsInNoaWZ0IiwiYWtleSIsImJrZXkiLCJ0IiwicmVzZXRUcmVlIiwicGFpcklkeCIsInRvVHJlZVN0cmluZyIsImFzVHJlZSIsInRyZWVMYXllcnMiLCJpc1Bvd09mMiIsInYiLCJsZWFmSW5kaWNlcyIsImxlYWZIYXNoZXMiLCJ0b3RhbExlYXZlc0NvdW50IiwibGVhZlR1cGxlcyIsImluZGV4QSIsImluZGV4QiIsImxlYWZUdXBsZUluZGljZXMiLCJuZXh0U2xpY2VTdGFydCIsInByb29mVHVwbGVzQnlMYXllcnMiLCJzbGljZVN0YXJ0IiwicyIsInBhcmVudEluZGljZXMiLCJwYXJlbnRMYXllciIsInBhcmVudE5vZGVUcmVlSW5kZXgiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/MerkleTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/merkletreejs/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/merkletreejs/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MerkleTree = void 0;\nconst MerkleTree_1 = __importDefault(__webpack_require__(/*! ./MerkleTree */ \"(ssr)/./node_modules/merkletreejs/dist/MerkleTree.js\"));\nexports.MerkleTree = MerkleTree_1.default;\nvar MerkleMountainRange_1 = __webpack_require__(/*! ./MerkleMountainRange */ \"(ssr)/./node_modules/merkletreejs/dist/MerkleMountainRange.js\");\nObject.defineProperty(exports, \"MerkleMountainRange\", ({\n    enumerable: true,\n    get: function() {\n        return MerkleMountainRange_1.MerkleMountainRange;\n    }\n}));\nvar IncrementalMerkleTree_1 = __webpack_require__(/*! ./IncrementalMerkleTree */ \"(ssr)/./node_modules/merkletreejs/dist/IncrementalMerkleTree.js\");\nObject.defineProperty(exports, \"IncrementalMerkleTree\", ({\n    enumerable: true,\n    get: function() {\n        return IncrementalMerkleTree_1.IncrementalMerkleTree;\n    }\n}));\nvar MerkleSumTree_1 = __webpack_require__(/*! ./MerkleSumTree */ \"(ssr)/./node_modules/merkletreejs/dist/MerkleSumTree.js\");\nObject.defineProperty(exports, \"MerkleSumTree\", ({\n    enumerable: true,\n    get: function() {\n        return MerkleSumTree_1.MerkleSumTree;\n    }\n}));\nexports[\"default\"] = MerkleTree_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1HLGVBQWVSLGdCQUFnQlMsbUJBQU9BLENBQUMsMEVBQWM7QUFDM0RKLGtCQUFrQixHQUFHRyxhQUFhRSxPQUFPO0FBQ3pDLElBQUlDLHdCQUF3QkYsbUJBQU9BLENBQUMsNEZBQXVCO0FBQzNETix1REFBc0Q7SUFBRVMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Ysc0JBQXNCRyxtQkFBbUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSixJQUFJQywwQkFBMEJOLG1CQUFPQSxDQUFDLGdHQUF5QjtBQUMvRE4seURBQXdEO0lBQUVTLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLHdCQUF3QkMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekosSUFBSUMsa0JBQWtCUixtQkFBT0EsQ0FBQyxnRkFBaUI7QUFDL0NOLGlEQUFnRDtJQUFFUyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSSxnQkFBZ0JDLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNqSWIsa0JBQWUsR0FBR0csYUFBYUUsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL21lcmtsZS8uL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9pbmRleC5qcz84ZWM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJrbGVUcmVlID0gdm9pZCAwO1xuY29uc3QgTWVya2xlVHJlZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL01lcmtsZVRyZWVcIikpO1xuZXhwb3J0cy5NZXJrbGVUcmVlID0gTWVya2xlVHJlZV8xLmRlZmF1bHQ7XG52YXIgTWVya2xlTW91bnRhaW5SYW5nZV8xID0gcmVxdWlyZShcIi4vTWVya2xlTW91bnRhaW5SYW5nZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lcmtsZU1vdW50YWluUmFuZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1lcmtsZU1vdW50YWluUmFuZ2VfMS5NZXJrbGVNb3VudGFpblJhbmdlOyB9IH0pO1xudmFyIEluY3JlbWVudGFsTWVya2xlVHJlZV8xID0gcmVxdWlyZShcIi4vSW5jcmVtZW50YWxNZXJrbGVUcmVlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5jcmVtZW50YWxNZXJrbGVUcmVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbmNyZW1lbnRhbE1lcmtsZVRyZWVfMS5JbmNyZW1lbnRhbE1lcmtsZVRyZWU7IH0gfSk7XG52YXIgTWVya2xlU3VtVHJlZV8xID0gcmVxdWlyZShcIi4vTWVya2xlU3VtVHJlZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lcmtsZVN1bVRyZWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1lcmtsZVN1bVRyZWVfMS5NZXJrbGVTdW1UcmVlOyB9IH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVya2xlVHJlZV8xLmRlZmF1bHQ7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWVya2xlVHJlZSIsIk1lcmtsZVRyZWVfMSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiTWVya2xlTW91bnRhaW5SYW5nZV8xIiwiZW51bWVyYWJsZSIsImdldCIsIk1lcmtsZU1vdW50YWluUmFuZ2UiLCJJbmNyZW1lbnRhbE1lcmtsZVRyZWVfMSIsIkluY3JlbWVudGFsTWVya2xlVHJlZSIsIk1lcmtsZVN1bVRyZWVfMSIsIk1lcmtsZVN1bVRyZWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/merkletreejs/dist/index.js\n");

/***/ })

};
;