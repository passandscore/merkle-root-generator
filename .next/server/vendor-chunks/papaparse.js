/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/papaparse";
exports.ids = ["vendor-chunks/papaparse"];
exports.modules = {

/***/ "(ssr)/./node_modules/papaparse/papaparse.js":
/*!*********************************************!*\
  !*** ./node_modules/papaparse/papaparse.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @license\nPapa Parse\nv5.4.1\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/ (function(root, factory) {\n    /* globals define */ if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n// in strict mode we cannot access arguments.callee, so we need a named reference to\n// stringify the factory method for the blob worker\n// eslint-disable-next-line func-name\n})(this, function moduleFactory() {\n    \"use strict\";\n    var global = function() {\n        // alternative method, similar to `Function('return this')()`\n        // but without using `eval` (which is disabled when\n        // using Content Security Policy).\n        if (typeof self !== \"undefined\") {\n            return self;\n        }\n        if (false) {}\n        if (typeof global !== \"undefined\") {\n            return global;\n        }\n        // When running tests none of the above have been defined\n        return {};\n    }();\n    function getWorkerBlob() {\n        var URL = global.URL || global.webkitURL || null;\n        var code = moduleFactory.toString();\n        return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob([\n            \"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\n            \"(\",\n            code,\n            \")();\"\n        ], {\n            type: \"text/javascript\"\n        })));\n    }\n    var IS_WORKER = !global.document && !!global.postMessage, IS_PAPA_WORKER = global.IS_PAPA_WORKER || false;\n    var workers = {}, workerIdCounter = 0;\n    var Papa = {};\n    Papa.parse = CsvToJson;\n    Papa.unparse = JsonToCsv;\n    Papa.RECORD_SEP = String.fromCharCode(30);\n    Papa.UNIT_SEP = String.fromCharCode(31);\n    Papa.BYTE_ORDER_MARK = \"\\uFEFF\";\n    Papa.BAD_DELIMITERS = [\n        \"\\r\",\n        \"\\n\",\n        '\"',\n        Papa.BYTE_ORDER_MARK\n    ];\n    Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n    Papa.NODE_STREAM_INPUT = 1;\n    // Configurable chunk sizes for local and remote files, respectively\n    Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\n    Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\n    Papa.DefaultDelimiter = \",\"; // Used if not specified and detection fails\n    // Exposed for testing and development only\n    Papa.Parser = Parser;\n    Papa.ParserHandle = ParserHandle;\n    Papa.NetworkStreamer = NetworkStreamer;\n    Papa.FileStreamer = FileStreamer;\n    Papa.StringStreamer = StringStreamer;\n    Papa.ReadableStreamStreamer = ReadableStreamStreamer;\n    if (typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n        Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n    }\n    if (global.jQuery) {\n        var $ = global.jQuery;\n        $.fn.parse = function(options) {\n            var config = options.config || {};\n            var queue = [];\n            this.each(function(idx) {\n                var supported = $(this).prop(\"tagName\").toUpperCase() === \"INPUT\" && $(this).attr(\"type\").toLowerCase() === \"file\" && global.FileReader;\n                if (!supported || !this.files || this.files.length === 0) return true; // continue to next input element\n                for(var i = 0; i < this.files.length; i++){\n                    queue.push({\n                        file: this.files[i],\n                        inputElem: this,\n                        instanceConfig: $.extend({}, config)\n                    });\n                }\n            });\n            parseNextFile(); // begin parsing\n            return this; // maintains chainability\n            function parseNextFile() {\n                if (queue.length === 0) {\n                    if (isFunction(options.complete)) options.complete();\n                    return;\n                }\n                var f = queue[0];\n                if (isFunction(options.before)) {\n                    var returned = options.before(f.file, f.inputElem);\n                    if (typeof returned === \"object\") {\n                        if (returned.action === \"abort\") {\n                            error(\"AbortError\", f.file, f.inputElem, returned.reason);\n                            return; // Aborts all queued files immediately\n                        } else if (returned.action === \"skip\") {\n                            fileComplete(); // parse the next file in the queue, if any\n                            return;\n                        } else if (typeof returned.config === \"object\") f.instanceConfig = $.extend(f.instanceConfig, returned.config);\n                    } else if (returned === \"skip\") {\n                        fileComplete(); // parse the next file in the queue, if any\n                        return;\n                    }\n                }\n                // Wrap up the user's complete callback, if any, so that ours also gets executed\n                var userCompleteFunc = f.instanceConfig.complete;\n                f.instanceConfig.complete = function(results) {\n                    if (isFunction(userCompleteFunc)) userCompleteFunc(results, f.file, f.inputElem);\n                    fileComplete();\n                };\n                Papa.parse(f.file, f.instanceConfig);\n            }\n            function error(name, file, elem, reason) {\n                if (isFunction(options.error)) options.error({\n                    name: name\n                }, file, elem, reason);\n            }\n            function fileComplete() {\n                queue.splice(0, 1);\n                parseNextFile();\n            }\n        };\n    }\n    if (IS_PAPA_WORKER) {\n        global.onmessage = workerThreadReceivedMessage;\n    }\n    function CsvToJson(_input, _config) {\n        _config = _config || {};\n        var dynamicTyping = _config.dynamicTyping || false;\n        if (isFunction(dynamicTyping)) {\n            _config.dynamicTypingFunction = dynamicTyping;\n            // Will be filled on first row call\n            dynamicTyping = {};\n        }\n        _config.dynamicTyping = dynamicTyping;\n        _config.transform = isFunction(_config.transform) ? _config.transform : false;\n        if (_config.worker && Papa.WORKERS_SUPPORTED) {\n            var w = newWorker();\n            w.userStep = _config.step;\n            w.userChunk = _config.chunk;\n            w.userComplete = _config.complete;\n            w.userError = _config.error;\n            _config.step = isFunction(_config.step);\n            _config.chunk = isFunction(_config.chunk);\n            _config.complete = isFunction(_config.complete);\n            _config.error = isFunction(_config.error);\n            delete _config.worker; // prevent infinite loop\n            w.postMessage({\n                input: _input,\n                config: _config,\n                workerId: w.id\n            });\n            return;\n        }\n        var streamer = null;\n        if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n            // create a node Duplex stream for use\n            // with .pipe\n            streamer = new DuplexStreamStreamer(_config);\n            return streamer.getStream();\n        } else if (typeof _input === \"string\") {\n            _input = stripBom(_input);\n            if (_config.download) streamer = new NetworkStreamer(_config);\n            else streamer = new StringStreamer(_config);\n        } else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n            streamer = new ReadableStreamStreamer(_config);\n        } else if (global.File && _input instanceof File || _input instanceof Object) streamer = new FileStreamer(_config);\n        return streamer.stream(_input);\n        // Strip character from UTF-8 BOM encoded files that cause issue parsing the file\n        function stripBom(string) {\n            if (string.charCodeAt(0) === 0xfeff) {\n                return string.slice(1);\n            }\n            return string;\n        }\n    }\n    function JsonToCsv(_input, _config) {\n        // Default configuration\n        /** whether to surround every datum with quotes */ var _quotes = false;\n        /** whether to write headers */ var _writeHeader = true;\n        /** delimiting character(s) */ var _delimiter = \",\";\n        /** newline character(s) */ var _newline = \"\\r\\n\";\n        /** quote character */ var _quoteChar = '\"';\n        /** escaped quote character, either \"\" or <config.escapeChar>\" */ var _escapedQuote = _quoteChar + _quoteChar;\n        /** whether to skip empty lines */ var _skipEmptyLines = false;\n        /** the columns (keys) we expect when we unparse objects */ var _columns = null;\n        /** whether to prevent outputting cells that can be parsed as formulae by spreadsheet software (Excel and LibreOffice) */ var _escapeFormulae = false;\n        unpackConfig();\n        var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), \"g\");\n        if (typeof _input === \"string\") _input = JSON.parse(_input);\n        if (Array.isArray(_input)) {\n            if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);\n            else if (typeof _input[0] === \"object\") return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);\n        } else if (typeof _input === \"object\") {\n            if (typeof _input.data === \"string\") _input.data = JSON.parse(_input.data);\n            if (Array.isArray(_input.data)) {\n                if (!_input.fields) _input.fields = _input.meta && _input.meta.fields || _columns;\n                if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : typeof _input.data[0] === \"object\" ? Object.keys(_input.data[0]) : [];\n                if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== \"object\") _input.data = [\n                    _input.data\n                ]; // handles input like [1,2,3] or ['asdf']\n            }\n            return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n        }\n        // Default (any valid paths should return before this)\n        throw new Error(\"Unable to serialize unrecognized input\");\n        function unpackConfig() {\n            if (typeof _config !== \"object\") return;\n            if (typeof _config.delimiter === \"string\" && !Papa.BAD_DELIMITERS.filter(function(value) {\n                return _config.delimiter.indexOf(value) !== -1;\n            }).length) {\n                _delimiter = _config.delimiter;\n            }\n            if (typeof _config.quotes === \"boolean\" || typeof _config.quotes === \"function\" || Array.isArray(_config.quotes)) _quotes = _config.quotes;\n            if (typeof _config.skipEmptyLines === \"boolean\" || typeof _config.skipEmptyLines === \"string\") _skipEmptyLines = _config.skipEmptyLines;\n            if (typeof _config.newline === \"string\") _newline = _config.newline;\n            if (typeof _config.quoteChar === \"string\") _quoteChar = _config.quoteChar;\n            if (typeof _config.header === \"boolean\") _writeHeader = _config.header;\n            if (Array.isArray(_config.columns)) {\n                if (_config.columns.length === 0) throw new Error(\"Option columns is empty\");\n                _columns = _config.columns;\n            }\n            if (_config.escapeChar !== undefined) {\n                _escapedQuote = _config.escapeChar + _quoteChar;\n            }\n            if (typeof _config.escapeFormulae === \"boolean\" || _config.escapeFormulae instanceof RegExp) {\n                _escapeFormulae = _config.escapeFormulae instanceof RegExp ? _config.escapeFormulae : /^[=+\\-@\\t\\r].*$/;\n            }\n        }\n        /** The double for loop that iterates the data and writes out a CSV string including header row */ function serialize(fields, data, skipEmptyLines) {\n            var csv = \"\";\n            if (typeof fields === \"string\") fields = JSON.parse(fields);\n            if (typeof data === \"string\") data = JSON.parse(data);\n            var hasHeader = Array.isArray(fields) && fields.length > 0;\n            var dataKeyedByField = !Array.isArray(data[0]);\n            // If there a header row, write it first\n            if (hasHeader && _writeHeader) {\n                for(var i = 0; i < fields.length; i++){\n                    if (i > 0) csv += _delimiter;\n                    csv += safe(fields[i], i);\n                }\n                if (data.length > 0) csv += _newline;\n            }\n            // Then write out the data\n            for(var row = 0; row < data.length; row++){\n                var maxCol = hasHeader ? fields.length : data[row].length;\n                var emptyLine = false;\n                var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n                if (skipEmptyLines && !hasHeader) {\n                    emptyLine = skipEmptyLines === \"greedy\" ? data[row].join(\"\").trim() === \"\" : data[row].length === 1 && data[row][0].length === 0;\n                }\n                if (skipEmptyLines === \"greedy\" && hasHeader) {\n                    var line = [];\n                    for(var c = 0; c < maxCol; c++){\n                        var cx = dataKeyedByField ? fields[c] : c;\n                        line.push(data[row][cx]);\n                    }\n                    emptyLine = line.join(\"\").trim() === \"\";\n                }\n                if (!emptyLine) {\n                    for(var col = 0; col < maxCol; col++){\n                        if (col > 0 && !nullLine) csv += _delimiter;\n                        var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n                        csv += safe(data[row][colIdx], col);\n                    }\n                    if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {\n                        csv += _newline;\n                    }\n                }\n            }\n            return csv;\n        }\n        /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */ function safe(str, col) {\n            if (typeof str === \"undefined\" || str === null) return \"\";\n            if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n            var needsQuotes = false;\n            if (_escapeFormulae && typeof str === \"string\" && _escapeFormulae.test(str)) {\n                str = \"'\" + str;\n                needsQuotes = true;\n            }\n            var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n            needsQuotes = needsQuotes || _quotes === true || typeof _quotes === \"function\" && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === \" \" || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === \" \";\n            return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n        }\n        function hasAny(str, substrings) {\n            for(var i = 0; i < substrings.length; i++)if (str.indexOf(substrings[i]) > -1) return true;\n            return false;\n        }\n    }\n    /** ChunkStreamer is the base prototype for various streamer implementations. */ function ChunkStreamer(config) {\n        this._handle = null;\n        this._finished = false;\n        this._completed = false;\n        this._halted = false;\n        this._input = null;\n        this._baseIndex = 0;\n        this._partialLine = \"\";\n        this._rowCount = 0;\n        this._start = 0;\n        this._nextChunk = null;\n        this.isFirstChunk = true;\n        this._completeResults = {\n            data: [],\n            errors: [],\n            meta: {}\n        };\n        replaceConfig.call(this, config);\n        this.parseChunk = function(chunk, isFakeChunk) {\n            // First chunk pre-processing\n            if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n                var modifiedChunk = this._config.beforeFirstChunk(chunk);\n                if (modifiedChunk !== undefined) chunk = modifiedChunk;\n            }\n            this.isFirstChunk = false;\n            this._halted = false;\n            // Rejoin the line we likely just split in two by chunking the file\n            var aggregate = this._partialLine + chunk;\n            this._partialLine = \"\";\n            var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n            if (this._handle.paused() || this._handle.aborted()) {\n                this._halted = true;\n                return;\n            }\n            var lastIndex = results.meta.cursor;\n            if (!this._finished) {\n                this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n                this._baseIndex = lastIndex;\n            }\n            if (results && results.data) this._rowCount += results.data.length;\n            var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;\n            if (IS_PAPA_WORKER) {\n                global.postMessage({\n                    results: results,\n                    workerId: Papa.WORKER_ID,\n                    finished: finishedIncludingPreview\n                });\n            } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n                this._config.chunk(results, this._handle);\n                if (this._handle.paused() || this._handle.aborted()) {\n                    this._halted = true;\n                    return;\n                }\n                results = undefined;\n                this._completeResults = undefined;\n            }\n            if (!this._config.step && !this._config.chunk) {\n                this._completeResults.data = this._completeResults.data.concat(results.data);\n                this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n                this._completeResults.meta = results.meta;\n            }\n            if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n                this._config.complete(this._completeResults, this._input);\n                this._completed = true;\n            }\n            if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n            return results;\n        };\n        this._sendError = function(error) {\n            if (isFunction(this._config.error)) this._config.error(error);\n            else if (IS_PAPA_WORKER && this._config.error) {\n                global.postMessage({\n                    workerId: Papa.WORKER_ID,\n                    error: error,\n                    finished: false\n                });\n            }\n        };\n        function replaceConfig(config) {\n            // Deep-copy the config so we can edit it\n            var configCopy = copy(config);\n            configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n            if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n            this._handle = new ParserHandle(configCopy);\n            this._handle.streamer = this;\n            this._config = configCopy; // persist the copy to the caller\n        }\n    }\n    function NetworkStreamer(config) {\n        config = config || {};\n        if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n        ChunkStreamer.call(this, config);\n        var xhr;\n        if (IS_WORKER) {\n            this._nextChunk = function() {\n                this._readChunk();\n                this._chunkLoaded();\n            };\n        } else {\n            this._nextChunk = function() {\n                this._readChunk();\n            };\n        }\n        this.stream = function(url) {\n            this._input = url;\n            this._nextChunk(); // Starts streaming\n        };\n        this._readChunk = function() {\n            if (this._finished) {\n                this._chunkLoaded();\n                return;\n            }\n            xhr = new XMLHttpRequest();\n            if (this._config.withCredentials) {\n                xhr.withCredentials = this._config.withCredentials;\n            }\n            if (!IS_WORKER) {\n                xhr.onload = bindFunction(this._chunkLoaded, this);\n                xhr.onerror = bindFunction(this._chunkError, this);\n            }\n            xhr.open(this._config.downloadRequestBody ? \"POST\" : \"GET\", this._input, !IS_WORKER);\n            // Headers can only be set when once the request state is OPENED\n            if (this._config.downloadRequestHeaders) {\n                var headers = this._config.downloadRequestHeaders;\n                for(var headerName in headers){\n                    xhr.setRequestHeader(headerName, headers[headerName]);\n                }\n            }\n            if (this._config.chunkSize) {\n                var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + this._start + \"-\" + end);\n            }\n            try {\n                xhr.send(this._config.downloadRequestBody);\n            } catch (err) {\n                this._chunkError(err.message);\n            }\n            if (IS_WORKER && xhr.status === 0) this._chunkError();\n        };\n        this._chunkLoaded = function() {\n            if (xhr.readyState !== 4) return;\n            if (xhr.status < 200 || xhr.status >= 400) {\n                this._chunkError();\n                return;\n            }\n            // Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n            this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n            this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n            this.parseChunk(xhr.responseText);\n        };\n        this._chunkError = function(errorMessage) {\n            var errorText = xhr.statusText || errorMessage;\n            this._sendError(new Error(errorText));\n        };\n        function getFileSize(xhr) {\n            var contentRange = xhr.getResponseHeader(\"Content-Range\");\n            if (contentRange === null) {\n                return -1;\n            }\n            return parseInt(contentRange.substring(contentRange.lastIndexOf(\"/\") + 1));\n        }\n    }\n    NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    NetworkStreamer.prototype.constructor = NetworkStreamer;\n    function FileStreamer(config) {\n        config = config || {};\n        if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n        ChunkStreamer.call(this, config);\n        var reader, slice;\n        // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n        // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n        var usingAsyncReader = typeof FileReader !== \"undefined\"; // Safari doesn't consider it a function - see issue #105\n        this.stream = function(file) {\n            this._input = file;\n            slice = file.slice || file.webkitSlice || file.mozSlice;\n            if (usingAsyncReader) {\n                reader = new FileReader(); // Preferred method of reading files, even in workers\n                reader.onload = bindFunction(this._chunkLoaded, this);\n                reader.onerror = bindFunction(this._chunkError, this);\n            } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n            this._nextChunk(); // Starts streaming\n        };\n        this._nextChunk = function() {\n            if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview)) this._readChunk();\n        };\n        this._readChunk = function() {\n            var input = this._input;\n            if (this._config.chunkSize) {\n                var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n                input = slice.call(input, this._start, end);\n            }\n            var txt = reader.readAsText(input, this._config.encoding);\n            if (!usingAsyncReader) this._chunkLoaded({\n                target: {\n                    result: txt\n                }\n            }); // mimic the async signature\n        };\n        this._chunkLoaded = function(event) {\n            // Very important to increment start each time before handling results\n            this._start += this._config.chunkSize;\n            this._finished = !this._config.chunkSize || this._start >= this._input.size;\n            this.parseChunk(event.target.result);\n        };\n        this._chunkError = function() {\n            this._sendError(reader.error);\n        };\n    }\n    FileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    FileStreamer.prototype.constructor = FileStreamer;\n    function StringStreamer(config) {\n        config = config || {};\n        ChunkStreamer.call(this, config);\n        var remaining;\n        this.stream = function(s) {\n            remaining = s;\n            return this._nextChunk();\n        };\n        this._nextChunk = function() {\n            if (this._finished) return;\n            var size = this._config.chunkSize;\n            var chunk;\n            if (size) {\n                chunk = remaining.substring(0, size);\n                remaining = remaining.substring(size);\n            } else {\n                chunk = remaining;\n                remaining = \"\";\n            }\n            this._finished = !remaining;\n            return this.parseChunk(chunk);\n        };\n    }\n    StringStreamer.prototype = Object.create(StringStreamer.prototype);\n    StringStreamer.prototype.constructor = StringStreamer;\n    function ReadableStreamStreamer(config) {\n        config = config || {};\n        ChunkStreamer.call(this, config);\n        var queue = [];\n        var parseOnData = true;\n        var streamHasEnded = false;\n        this.pause = function() {\n            ChunkStreamer.prototype.pause.apply(this, arguments);\n            this._input.pause();\n        };\n        this.resume = function() {\n            ChunkStreamer.prototype.resume.apply(this, arguments);\n            this._input.resume();\n        };\n        this.stream = function(stream) {\n            this._input = stream;\n            this._input.on(\"data\", this._streamData);\n            this._input.on(\"end\", this._streamEnd);\n            this._input.on(\"error\", this._streamError);\n        };\n        this._checkIsFinished = function() {\n            if (streamHasEnded && queue.length === 1) {\n                this._finished = true;\n            }\n        };\n        this._nextChunk = function() {\n            this._checkIsFinished();\n            if (queue.length) {\n                this.parseChunk(queue.shift());\n            } else {\n                parseOnData = true;\n            }\n        };\n        this._streamData = bindFunction(function(chunk) {\n            try {\n                queue.push(typeof chunk === \"string\" ? chunk : chunk.toString(this._config.encoding));\n                if (parseOnData) {\n                    parseOnData = false;\n                    this._checkIsFinished();\n                    this.parseChunk(queue.shift());\n                }\n            } catch (error) {\n                this._streamError(error);\n            }\n        }, this);\n        this._streamError = bindFunction(function(error) {\n            this._streamCleanUp();\n            this._sendError(error);\n        }, this);\n        this._streamEnd = bindFunction(function() {\n            this._streamCleanUp();\n            streamHasEnded = true;\n            this._streamData(\"\");\n        }, this);\n        this._streamCleanUp = bindFunction(function() {\n            this._input.removeListener(\"data\", this._streamData);\n            this._input.removeListener(\"end\", this._streamEnd);\n            this._input.removeListener(\"error\", this._streamError);\n        }, this);\n    }\n    ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n    function DuplexStreamStreamer(_config) {\n        var Duplex = (__webpack_require__(/*! stream */ \"stream\").Duplex);\n        var config = copy(_config);\n        var parseOnWrite = true;\n        var writeStreamHasFinished = false;\n        var parseCallbackQueue = [];\n        var stream = null;\n        this._onCsvData = function(results) {\n            var data = results.data;\n            if (!stream.push(data) && !this._handle.paused()) {\n                // the writeable consumer buffer has filled up\n                // so we need to pause until more items\n                // can be processed\n                this._handle.pause();\n            }\n        };\n        this._onCsvComplete = function() {\n            // node will finish the read stream when\n            // null is pushed\n            stream.push(null);\n        };\n        config.step = bindFunction(this._onCsvData, this);\n        config.complete = bindFunction(this._onCsvComplete, this);\n        ChunkStreamer.call(this, config);\n        this._nextChunk = function() {\n            if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n                this._finished = true;\n            }\n            if (parseCallbackQueue.length) {\n                parseCallbackQueue.shift()();\n            } else {\n                parseOnWrite = true;\n            }\n        };\n        this._addToParseQueue = function(chunk, callback) {\n            // add to queue so that we can indicate\n            // completion via callback\n            // node will automatically pause the incoming stream\n            // when too many items have been added without their\n            // callback being invoked\n            parseCallbackQueue.push(bindFunction(function() {\n                this.parseChunk(typeof chunk === \"string\" ? chunk : chunk.toString(config.encoding));\n                if (isFunction(callback)) {\n                    return callback();\n                }\n            }, this));\n            if (parseOnWrite) {\n                parseOnWrite = false;\n                this._nextChunk();\n            }\n        };\n        this._onRead = function() {\n            if (this._handle.paused()) {\n                // the writeable consumer can handle more data\n                // so resume the chunk parsing\n                this._handle.resume();\n            }\n        };\n        this._onWrite = function(chunk, encoding, callback) {\n            this._addToParseQueue(chunk, callback);\n        };\n        this._onWriteComplete = function() {\n            writeStreamHasFinished = true;\n            // have to write empty string\n            // so parser knows its done\n            this._addToParseQueue(\"\");\n        };\n        this.getStream = function() {\n            return stream;\n        };\n        stream = new Duplex({\n            readableObjectMode: true,\n            decodeStrings: false,\n            read: bindFunction(this._onRead, this),\n            write: bindFunction(this._onWrite, this)\n        });\n        stream.once(\"finish\", bindFunction(this._onWriteComplete, this));\n    }\n    if (typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n        DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n        DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n    }\n    // Use one ParserHandle per entire CSV file or string\n    function ParserHandle(_config) {\n        // One goal is to minimize the use of regular expressions...\n        var MAX_FLOAT = Math.pow(2, 53);\n        var MIN_FLOAT = -MAX_FLOAT;\n        var FLOAT = /^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/;\n        var ISO_DATE = /^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/;\n        var self1 = this;\n        var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n        var _rowCounter = 0; // Number of rows that have been parsed so far\n        var _input; // The input being parsed\n        var _parser; // The core parser being used\n        var _paused = false; // Whether we are paused or not\n        var _aborted = false; // Whether the parser has aborted or not\n        var _delimiterError; // Temporary state between delimiter detection and processing results\n        var _fields = []; // Fields are from the header row of the input, if there is one\n        var _results = {\n            data: [],\n            errors: [],\n            meta: {}\n        };\n        if (isFunction(_config.step)) {\n            var userStep = _config.step;\n            _config.step = function(results) {\n                _results = results;\n                if (needsHeaderRow()) processResults();\n                else {\n                    processResults();\n                    // It's possbile that this line was empty and there's no row here after all\n                    if (_results.data.length === 0) return;\n                    _stepCounter += results.data.length;\n                    if (_config.preview && _stepCounter > _config.preview) _parser.abort();\n                    else {\n                        _results.data = _results.data[0];\n                        userStep(_results, self1);\n                    }\n                }\n            };\n        }\n        /**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */ this.parse = function(input, baseIndex, ignoreLastRow) {\n            var quoteChar = _config.quoteChar || '\"';\n            if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);\n            _delimiterError = false;\n            if (!_config.delimiter) {\n                var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n                if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;\n                else {\n                    _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n                    _config.delimiter = Papa.DefaultDelimiter;\n                }\n                _results.meta.delimiter = _config.delimiter;\n            } else if (isFunction(_config.delimiter)) {\n                _config.delimiter = _config.delimiter(input);\n                _results.meta.delimiter = _config.delimiter;\n            }\n            var parserConfig = copy(_config);\n            if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n            _input = input;\n            _parser = new Parser(parserConfig);\n            _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n            processResults();\n            return _paused ? {\n                meta: {\n                    paused: true\n                }\n            } : _results || {\n                meta: {\n                    paused: false\n                }\n            };\n        };\n        this.paused = function() {\n            return _paused;\n        };\n        this.pause = function() {\n            _paused = true;\n            _parser.abort();\n            // If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n            // otherwise we can get duplicate content within a row\n            _input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n        };\n        this.resume = function() {\n            if (self1.streamer._halted) {\n                _paused = false;\n                self1.streamer.parseChunk(_input, true);\n            } else {\n                // Bugfix: #636 In case the processing hasn't halted yet\n                // wait for it to halt in order to resume\n                setTimeout(self1.resume, 3);\n            }\n        };\n        this.aborted = function() {\n            return _aborted;\n        };\n        this.abort = function() {\n            _aborted = true;\n            _parser.abort();\n            _results.meta.aborted = true;\n            if (isFunction(_config.complete)) _config.complete(_results);\n            _input = \"\";\n        };\n        function testEmptyLine(s) {\n            return _config.skipEmptyLines === \"greedy\" ? s.join(\"\").trim() === \"\" : s.length === 1 && s[0].length === 0;\n        }\n        function testFloat(s) {\n            if (FLOAT.test(s)) {\n                var floatValue = parseFloat(s);\n                if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function processResults() {\n            if (_results && _delimiterError) {\n                addError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\");\n                _delimiterError = false;\n            }\n            if (_config.skipEmptyLines) {\n                _results.data = _results.data.filter(function(d) {\n                    return !testEmptyLine(d);\n                });\n            }\n            if (needsHeaderRow()) fillHeaderFields();\n            return applyHeaderAndDynamicTypingAndTransformation();\n        }\n        function needsHeaderRow() {\n            return _config.header && _fields.length === 0;\n        }\n        function fillHeaderFields() {\n            if (!_results) return;\n            function addHeader(header, i) {\n                if (isFunction(_config.transformHeader)) header = _config.transformHeader(header, i);\n                _fields.push(header);\n            }\n            if (Array.isArray(_results.data[0])) {\n                for(var i = 0; needsHeaderRow() && i < _results.data.length; i++)_results.data[i].forEach(addHeader);\n                _results.data.splice(0, 1);\n            } else _results.data.forEach(addHeader);\n        }\n        function shouldApplyDynamicTyping(field) {\n            // Cache function values to avoid calling it for each row\n            if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n                _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n            }\n            return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n        }\n        function parseDynamic(field, value) {\n            if (shouldApplyDynamicTyping(field)) {\n                if (value === \"true\" || value === \"TRUE\") return true;\n                else if (value === \"false\" || value === \"FALSE\") return false;\n                else if (testFloat(value)) return parseFloat(value);\n                else if (ISO_DATE.test(value)) return new Date(value);\n                else return value === \"\" ? null : value;\n            }\n            return value;\n        }\n        function applyHeaderAndDynamicTypingAndTransformation() {\n            if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;\n            function processRow(rowSource, i) {\n                var row = _config.header ? {} : [];\n                var j;\n                for(j = 0; j < rowSource.length; j++){\n                    var field = j;\n                    var value = rowSource[j];\n                    if (_config.header) field = j >= _fields.length ? \"__parsed_extra\" : _fields[j];\n                    if (_config.transform) value = _config.transform(value, field);\n                    value = parseDynamic(field, value);\n                    if (field === \"__parsed_extra\") {\n                        row[field] = row[field] || [];\n                        row[field].push(value);\n                    } else row[field] = value;\n                }\n                if (_config.header) {\n                    if (j > _fields.length) addError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, _rowCounter + i);\n                    else if (j < _fields.length) addError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, _rowCounter + i);\n                }\n                return row;\n            }\n            var incrementBy = 1;\n            if (!_results.data.length || Array.isArray(_results.data[0])) {\n                _results.data = _results.data.map(processRow);\n                incrementBy = _results.data.length;\n            } else _results.data = processRow(_results.data, 0);\n            if (_config.header && _results.meta) _results.meta.fields = _fields;\n            _rowCounter += incrementBy;\n            return _results;\n        }\n        function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n            var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n            delimitersToGuess = delimitersToGuess || [\n                \",\",\n                \"\t\",\n                \"|\",\n                \";\",\n                Papa.RECORD_SEP,\n                Papa.UNIT_SEP\n            ];\n            for(var i = 0; i < delimitersToGuess.length; i++){\n                var delim = delimitersToGuess[i];\n                var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n                fieldCountPrevRow = undefined;\n                var preview = new Parser({\n                    comments: comments,\n                    delimiter: delim,\n                    newline: newline,\n                    preview: 10\n                }).parse(input);\n                for(var j = 0; j < preview.data.length; j++){\n                    if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n                        emptyLinesCount++;\n                        continue;\n                    }\n                    var fieldCount = preview.data[j].length;\n                    avgFieldCount += fieldCount;\n                    if (typeof fieldCountPrevRow === \"undefined\") {\n                        fieldCountPrevRow = fieldCount;\n                        continue;\n                    } else if (fieldCount > 0) {\n                        delta += Math.abs(fieldCount - fieldCountPrevRow);\n                        fieldCountPrevRow = fieldCount;\n                    }\n                }\n                if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n                if ((typeof bestDelta === \"undefined\" || delta <= bestDelta) && (typeof maxFieldCount === \"undefined\" || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n                    bestDelta = delta;\n                    bestDelim = delim;\n                    maxFieldCount = avgFieldCount;\n                }\n            }\n            _config.delimiter = bestDelim;\n            return {\n                successful: !!bestDelim,\n                bestDelimiter: bestDelim\n            };\n        }\n        function guessLineEndings(input, quoteChar) {\n            input = input.substring(0, 1024 * 1024); // max length 1 MB\n            // Replace all the text inside quotes\n            var re = new RegExp(escapeRegExp(quoteChar) + \"([^]*?)\" + escapeRegExp(quoteChar), \"gm\");\n            input = input.replace(re, \"\");\n            var r = input.split(\"\\r\");\n            var n = input.split(\"\\n\");\n            var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n            if (r.length === 1 || nAppearsFirst) return \"\\n\";\n            var numWithN = 0;\n            for(var i = 0; i < r.length; i++){\n                if (r[i][0] === \"\\n\") numWithN++;\n            }\n            return numWithN >= r.length / 2 ? \"\\r\\n\" : \"\\r\";\n        }\n        function addError(type, code, msg, row) {\n            var error = {\n                type: type,\n                code: code,\n                message: msg\n            };\n            if (row !== undefined) {\n                error.row = row;\n            }\n            _results.errors.push(error);\n        }\n    }\n    /** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */ function escapeRegExp(string) {\n        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n    }\n    /** The core parser implements speedy and correct CSV parsing */ function Parser(config) {\n        // Unpack the config object\n        config = config || {};\n        var delim = config.delimiter;\n        var newline = config.newline;\n        var comments = config.comments;\n        var step = config.step;\n        var preview = config.preview;\n        var fastMode = config.fastMode;\n        var quoteChar;\n        if (config.quoteChar === undefined || config.quoteChar === null) {\n            quoteChar = '\"';\n        } else {\n            quoteChar = config.quoteChar;\n        }\n        var escapeChar = quoteChar;\n        if (config.escapeChar !== undefined) {\n            escapeChar = config.escapeChar;\n        }\n        // Delimiter must be valid\n        if (typeof delim !== \"string\" || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = \",\";\n        // Comment character must be valid\n        if (comments === delim) throw new Error(\"Comment character same as delimiter\");\n        else if (comments === true) comments = \"#\";\n        else if (typeof comments !== \"string\" || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false;\n        // Newline must be valid: \\r, \\n, or \\r\\n\n        if (newline !== \"\\n\" && newline !== \"\\r\" && newline !== \"\\r\\n\") newline = \"\\n\";\n        // We're gonna need these at the Parser scope\n        var cursor = 0;\n        var aborted = false;\n        this.parse = function(input, baseIndex, ignoreLastRow) {\n            // For some reason, in Chrome, this speeds things up (!?)\n            if (typeof input !== \"string\") throw new Error(\"Input must be a string\");\n            // We don't need to compute some of these every time parse() is called,\n            // but having them in a more local scope seems to perform better\n            var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;\n            var stepIsFunction = isFunction(step);\n            // Establish starting state\n            cursor = 0;\n            var data = [], errors = [], row = [], lastCursor = 0;\n            if (!input) return returnable();\n            // Rename headers if there are duplicates\n            if (config.header && !baseIndex) {\n                var firstLine = input.split(newline)[0];\n                var headers = firstLine.split(delim);\n                var separator = \"_\";\n                var headerMap = [];\n                var headerCount = {};\n                var duplicateHeaders = false;\n                for(var j in headers){\n                    var header = headers[j];\n                    if (isFunction(config.transformHeader)) header = config.transformHeader(header, j);\n                    var headerName = header;\n                    var count = headerCount[header] || 0;\n                    if (count > 0) {\n                        duplicateHeaders = true;\n                        headerName = header + separator + count;\n                    }\n                    headerCount[header] = count + 1;\n                    // In case it already exists, we add more separtors\n                    while(headerMap.includes(headerName)){\n                        headerName = headerName + separator + count;\n                    }\n                    headerMap.push(headerName);\n                }\n                if (duplicateHeaders) {\n                    var editedInput = input.split(newline);\n                    editedInput[0] = headerMap.join(delim);\n                    input = editedInput.join(newline);\n                }\n            }\n            if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {\n                var rows = input.split(newline);\n                for(var i = 0; i < rows.length; i++){\n                    row = rows[i];\n                    cursor += row.length;\n                    if (i !== rows.length - 1) cursor += newline.length;\n                    else if (ignoreLastRow) return returnable();\n                    if (comments && row.substring(0, commentsLen) === comments) continue;\n                    if (stepIsFunction) {\n                        data = [];\n                        pushRow(row.split(delim));\n                        doStep();\n                        if (aborted) return returnable();\n                    } else pushRow(row.split(delim));\n                    if (preview && i >= preview) {\n                        data = data.slice(0, preview);\n                        return returnable(true);\n                    }\n                }\n                return returnable();\n            }\n            var nextDelim = input.indexOf(delim, cursor);\n            var nextNewline = input.indexOf(newline, cursor);\n            var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), \"g\");\n            var quoteSearch = input.indexOf(quoteChar, cursor);\n            // Parser loop\n            for(;;){\n                // Field has opening quote\n                if (input[cursor] === quoteChar) {\n                    // Start our search for the closing quote where the cursor is\n                    quoteSearch = cursor;\n                    // Skip the opening quote\n                    cursor++;\n                    for(;;){\n                        // Find closing quote\n                        quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n                        //No other quotes are found - no other delimiters\n                        if (quoteSearch === -1) {\n                            if (!ignoreLastRow) {\n                                // No closing quote... what a pity\n                                errors.push({\n                                    type: \"Quotes\",\n                                    code: \"MissingQuotes\",\n                                    message: \"Quoted field unterminated\",\n                                    row: data.length,\n                                    index: cursor\n                                });\n                            }\n                            return finish();\n                        }\n                        // Closing quote at EOF\n                        if (quoteSearch === inputLen - 1) {\n                            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n                            return finish(value);\n                        }\n                        // If this quote is escaped, it's part of the data; skip it\n                        // If the quote character is the escape character, then check if the next character is the escape character\n                        if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n                            quoteSearch++;\n                            continue;\n                        }\n                        // If the quote character is not the escape character, then check if the previous character was the escape character\n                        if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {\n                            continue;\n                        }\n                        if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {\n                            nextDelim = input.indexOf(delim, quoteSearch + 1);\n                        }\n                        if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {\n                            nextNewline = input.indexOf(newline, quoteSearch + 1);\n                        }\n                        // Check up to nextDelim or nextNewline, whichever is closest\n                        var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n                        var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n                        // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n                        if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim) {\n                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n                            // If char after following delimiter is not quoteChar, we find next quote char position\n                            if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {\n                                quoteSearch = input.indexOf(quoteChar, cursor);\n                            }\n                            nextDelim = input.indexOf(delim, cursor);\n                            nextNewline = input.indexOf(newline, cursor);\n                            break;\n                        }\n                        var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n                        // Closing quote followed by newline or 'unnecessary spaces + newLine'\n                        if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {\n                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n                            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n                            quoteSearch = input.indexOf(quoteChar, cursor); // we search for first quote in next line\n                            if (stepIsFunction) {\n                                doStep();\n                                if (aborted) return returnable();\n                            }\n                            if (preview && data.length >= preview) return returnable(true);\n                            break;\n                        }\n                        // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n                        errors.push({\n                            type: \"Quotes\",\n                            code: \"InvalidQuotes\",\n                            message: \"Trailing quote on quoted field is malformed\",\n                            row: data.length,\n                            index: cursor\n                        });\n                        quoteSearch++;\n                        continue;\n                    }\n                    continue;\n                }\n                // Comment found at start of new line\n                if (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {\n                    if (nextNewline === -1) return returnable();\n                    cursor = nextNewline + newlineLen;\n                    nextNewline = input.indexOf(newline, cursor);\n                    nextDelim = input.indexOf(delim, cursor);\n                    continue;\n                }\n                // Next delimiter comes before next newline, so we've reached end of field\n                if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n                    row.push(input.substring(cursor, nextDelim));\n                    cursor = nextDelim + delimLen;\n                    // we look for next delimiter char\n                    nextDelim = input.indexOf(delim, cursor);\n                    continue;\n                }\n                // End of row\n                if (nextNewline !== -1) {\n                    row.push(input.substring(cursor, nextNewline));\n                    saveRow(nextNewline + newlineLen);\n                    if (stepIsFunction) {\n                        doStep();\n                        if (aborted) return returnable();\n                    }\n                    if (preview && data.length >= preview) return returnable(true);\n                    continue;\n                }\n                break;\n            }\n            return finish();\n            function pushRow(row) {\n                data.push(row);\n                lastCursor = cursor;\n            }\n            /**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */ function extraSpaces(index) {\n                var spaceLength = 0;\n                if (index !== -1) {\n                    var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n                    if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === \"\") {\n                        spaceLength = textBetweenClosingQuoteAndIndex.length;\n                    }\n                }\n                return spaceLength;\n            }\n            /**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */ function finish(value) {\n                if (ignoreLastRow) return returnable();\n                if (typeof value === \"undefined\") value = input.substring(cursor);\n                row.push(value);\n                cursor = inputLen; // important in case parsing is paused\n                pushRow(row);\n                if (stepIsFunction) doStep();\n                return returnable();\n            }\n            /**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */ function saveRow(newCursor) {\n                cursor = newCursor;\n                pushRow(row);\n                row = [];\n                nextNewline = input.indexOf(newline, cursor);\n            }\n            /** Returns an object with the results, errors, and meta. */ function returnable(stopped) {\n                return {\n                    data: data,\n                    errors: errors,\n                    meta: {\n                        delimiter: delim,\n                        linebreak: newline,\n                        aborted: aborted,\n                        truncated: !!stopped,\n                        cursor: lastCursor + (baseIndex || 0)\n                    }\n                };\n            }\n            /** Executes the user's step function and resets data & errors. */ function doStep() {\n                step(returnable());\n                data = [];\n                errors = [];\n            }\n        };\n        /** Sets the abort flag */ this.abort = function() {\n            aborted = true;\n        };\n        /** Gets the cursor position */ this.getCharIndex = function() {\n            return cursor;\n        };\n    }\n    function newWorker() {\n        if (!Papa.WORKERS_SUPPORTED) return false;\n        var workerUrl = getWorkerBlob();\n        var w = new global.Worker(workerUrl);\n        w.onmessage = mainThreadReceivedMessage;\n        w.id = workerIdCounter++;\n        workers[w.id] = w;\n        return w;\n    }\n    /** Callback when main thread receives a message */ function mainThreadReceivedMessage(e) {\n        var msg = e.data;\n        var worker = workers[msg.workerId];\n        var aborted = false;\n        if (msg.error) worker.userError(msg.error, msg.file);\n        else if (msg.results && msg.results.data) {\n            var abort = function() {\n                aborted = true;\n                completeWorker(msg.workerId, {\n                    data: [],\n                    errors: [],\n                    meta: {\n                        aborted: true\n                    }\n                });\n            };\n            var handle = {\n                abort: abort,\n                pause: notImplemented,\n                resume: notImplemented\n            };\n            if (isFunction(worker.userStep)) {\n                for(var i = 0; i < msg.results.data.length; i++){\n                    worker.userStep({\n                        data: msg.results.data[i],\n                        errors: msg.results.errors,\n                        meta: msg.results.meta\n                    }, handle);\n                    if (aborted) break;\n                }\n                delete msg.results; // free memory ASAP\n            } else if (isFunction(worker.userChunk)) {\n                worker.userChunk(msg.results, handle, msg.file);\n                delete msg.results;\n            }\n        }\n        if (msg.finished && !aborted) completeWorker(msg.workerId, msg.results);\n    }\n    function completeWorker(workerId, results) {\n        var worker = workers[workerId];\n        if (isFunction(worker.userComplete)) worker.userComplete(results);\n        worker.terminate();\n        delete workers[workerId];\n    }\n    function notImplemented() {\n        throw new Error(\"Not implemented.\");\n    }\n    /** Callback when worker thread receives a message */ function workerThreadReceivedMessage(e) {\n        var msg = e.data;\n        if (typeof Papa.WORKER_ID === \"undefined\" && msg) Papa.WORKER_ID = msg.workerId;\n        if (typeof msg.input === \"string\") {\n            global.postMessage({\n                workerId: Papa.WORKER_ID,\n                results: Papa.parse(msg.input, msg.config),\n                finished: true\n            });\n        } else if (global.File && msg.input instanceof File || msg.input instanceof Object) {\n            var results = Papa.parse(msg.input, msg.config);\n            if (results) global.postMessage({\n                workerId: Papa.WORKER_ID,\n                results: results,\n                finished: true\n            });\n        }\n    }\n    /** Makes a deep copy of an array or object (mostly) */ function copy(obj) {\n        if (typeof obj !== \"object\" || obj === null) return obj;\n        var cpy = Array.isArray(obj) ? [] : {};\n        for(var key in obj)cpy[key] = copy(obj[key]);\n        return cpy;\n    }\n    function bindFunction(f, self1) {\n        return function() {\n            f.apply(self1, arguments);\n        };\n    }\n    function isFunction(func) {\n        return typeof func === \"function\";\n    }\n    return Papa;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFwYXBhcnNlL3BhcGFwYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQSxHQUVDLFVBQVNBLElBQUksRUFBRUMsT0FBTztJQUV0QixrQkFBa0IsR0FDbEIsSUFBSSxJQUEwQyxFQUM5QztRQUNDLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxvQ0FBRUQsT0FBT0E7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3BCLE9BQ0ssRUFXSjtBQUNELG9GQUFvRjtBQUNwRixtREFBbUQ7QUFDbkQscUNBQXFDO0FBQ3RDLEdBQUUsSUFBSSxFQUFFLFNBQVNNO0lBRWhCO0lBRUEsSUFBSUMsU0FBUztRQUNaLDZEQUE2RDtRQUM3RCxtREFBbUQ7UUFDbkQsa0NBQWtDO1FBRWxDLElBQUksT0FBT0MsU0FBUyxhQUFhO1lBQUUsT0FBT0E7UUFBTTtRQUNoRCxJQUFJLEtBQWtCLEVBQWEsRUFBa0I7UUFDckQsSUFBSSxPQUFPRCxXQUFXLGFBQWE7WUFBRSxPQUFPQTtRQUFRO1FBRXBELHlEQUF5RDtRQUN6RCxPQUFPLENBQUM7SUFDVDtJQUdBLFNBQVNHO1FBQ1IsSUFBSUMsTUFBTUosT0FBT0ksR0FBRyxJQUFJSixPQUFPSyxTQUFTLElBQUk7UUFDNUMsSUFBSUMsT0FBT1AsY0FBY1EsUUFBUTtRQUNqQyxPQUFPVCxLQUFLVSxRQUFRLElBQUtWLENBQUFBLEtBQUtVLFFBQVEsR0FBR0osSUFBSUssZUFBZSxDQUFDLElBQUlDLEtBQUs7WUFBQztZQUEwTztZQUFLSjtZQUFNO1NBQU8sRUFBRTtZQUFDSyxNQUFNO1FBQWlCLEdBQUU7SUFDaFc7SUFFQSxJQUFJQyxZQUFZLENBQUNaLE9BQU9hLFFBQVEsSUFBSSxDQUFDLENBQUNiLE9BQU9jLFdBQVcsRUFDdkRDLGlCQUFpQmYsT0FBT2UsY0FBYyxJQUFJO0lBRTNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHQyxrQkFBa0I7SUFFcEMsSUFBSW5CLE9BQU8sQ0FBQztJQUVaQSxLQUFLb0Is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QUk3UyxNQUFNO1lBQzlDLElBQUk2QixTQUNIM0UsT0FBT2MsV0FBVyxDQUFDO2dCQUNsQmtGLFVBQVVsRyxLQUFLeU0sU0FBUztnQkFDeEI1SCxTQUFTQTtnQkFDVDZILFVBQVU7WUFDWDtRQUNGO0lBQ0Q7SUFFQSxxREFBcUQsR0FDckQsU0FBU0ksS0FBSzJMLEdBQUc7UUFFaEIsSUFBSSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsTUFDdEMsT0FBT0E7UUFDUixJQUFJQyxNQUFNM1EsTUFBTUMsT0FBTyxDQUFDeVEsT0FBTyxFQUFFLEdBQUcsQ0FBQztRQUNyQyxJQUFLLElBQUlFLE9BQU9GLElBQ2ZDLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHN0wsS0FBSzJMLEdBQUcsQ0FBQ0UsSUFBSTtRQUN6QixPQUFPRDtJQUNSO0lBRUEsU0FBU2xMLGFBQWFuSixDQUFDLEVBQUVsRSxLQUFJO1FBRTVCLE9BQU87WUFBYWtFLEVBQUUrTCxLQUFLLENBQUNqUSxPQUFNa1E7UUFBWTtJQUMvQztJQUVBLFNBQVNsTSxXQUFXeVUsSUFBSTtRQUV2QixPQUFPLE9BQU9BLFNBQVM7SUFDeEI7SUFFQSxPQUFPNVk7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL21lcmtsZS8uL25vZGVfbW9kdWxlcy9wYXBhcGFyc2UvcGFwYXBhcnNlLmpzPzliZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQGxpY2Vuc2VcblBhcGEgUGFyc2VcbnY1LjQuMVxuaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZVxuTGljZW5zZTogTUlUXG4qL1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSlcbntcblx0LyogZ2xvYmFscyBkZWZpbmUgKi9cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0e1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJylcblx0e1xuXHRcdC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuXHRcdC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuXHRcdC8vIGxpa2UgTm9kZS5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuXHRcdHJvb3QuUGFwYSA9IGZhY3RvcnkoKTtcblx0fVxuXHQvLyBpbiBzdHJpY3QgbW9kZSB3ZSBjYW5ub3QgYWNjZXNzIGFyZ3VtZW50cy5jYWxsZWUsIHNvIHdlIG5lZWQgYSBuYW1lZCByZWZlcmVuY2UgdG9cblx0Ly8gc3RyaW5naWZ5IHRoZSBmYWN0b3J5IG1ldGhvZCBmb3IgdGhlIGJsb2Igd29ya2VyXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVcbn0odGhpcywgZnVuY3Rpb24gbW9kdWxlRmFjdG9yeSgpXG57XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkge1xuXHRcdC8vIGFsdGVybmF0aXZlIG1ldGhvZCwgc2ltaWxhciB0byBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0XHQvLyBidXQgd2l0aG91dCB1c2luZyBgZXZhbGAgKHdoaWNoIGlzIGRpc2FibGVkIHdoZW5cblx0XHQvLyB1c2luZyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG5cblx0XHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0XHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXG5cdFx0Ly8gV2hlbiBydW5uaW5nIHRlc3RzIG5vbmUgb2YgdGhlIGFib3ZlIGhhdmUgYmVlbiBkZWZpbmVkXG5cdFx0cmV0dXJuIHt9O1xuXHR9KSgpO1xuXG5cblx0ZnVuY3Rpb24gZ2V0V29ya2VyQmxvYigpIHtcblx0XHR2YXIgVVJMID0gZ2xvYmFsLlVSTCB8fCBnbG9iYWwud2Via2l0VVJMIHx8IG51bGw7XG5cdFx0dmFyIGNvZGUgPSBtb2R1bGVGYWN0b3J5LnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuIFBhcGEuQkxPQl9VUkwgfHwgKFBhcGEuQkxPQl9VUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtcInZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH0gaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH0gaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH0gcmV0dXJuIHt9OyB9KSgpOyBnbG9iYWwuSVNfUEFQQV9XT1JLRVI9dHJ1ZTsgXCIsICcoJywgY29kZSwgJykoKTsnXSwge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSkpKTtcblx0fVxuXG5cdHZhciBJU19XT1JLRVIgPSAhZ2xvYmFsLmRvY3VtZW50ICYmICEhZ2xvYmFsLnBvc3RNZXNzYWdlLFxuXHRcdElTX1BBUEFfV09SS0VSID0gZ2xvYmFsLklTX1BBUEFfV09SS0VSIHx8IGZhbHNlO1xuXG5cdHZhciB3b3JrZXJzID0ge30sIHdvcmtlcklkQ291bnRlciA9IDA7XG5cblx0dmFyIFBhcGEgPSB7fTtcblxuXHRQYXBhLnBhcnNlID0gQ3N2VG9Kc29uO1xuXHRQYXBhLnVucGFyc2UgPSBKc29uVG9Dc3Y7XG5cblx0UGFwYS5SRUNPUkRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7XG5cdFBhcGEuVU5JVF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMxKTtcblx0UGFwYS5CWVRFX09SREVSX01BUksgPSAnXFx1ZmVmZic7XG5cdFBhcGEuQkFEX0RFTElNSVRFUlMgPSBbJ1xccicsICdcXG4nLCAnXCInLCBQYXBhLkJZVEVfT1JERVJfTUFSS107XG5cdFBhcGEuV09SS0VSU19TVVBQT1JURUQgPSAhSVNfV09SS0VSICYmICEhZ2xvYmFsLldvcmtlcjtcblx0UGFwYS5OT0RFX1NUUkVBTV9JTlBVVCA9IDE7XG5cblx0Ly8gQ29uZmlndXJhYmxlIGNodW5rIHNpemVzIGZvciBsb2NhbCBhbmQgcmVtb3RlIGZpbGVzLCByZXNwZWN0aXZlbHlcblx0UGFwYS5Mb2NhbENodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogMTA7XHQvLyAxMCBNQlxuXHRQYXBhLlJlbW90ZUNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogNTtcdC8vIDUgTUJcblx0UGFwYS5EZWZhdWx0RGVsaW1pdGVyID0gJywnO1x0XHRcdC8vIFVzZWQgaWYgbm90IHNwZWNpZmllZCBhbmQgZGV0ZWN0aW9uIGZhaWxzXG5cblx0Ly8gRXhwb3NlZCBmb3IgdGVzdGluZyBhbmQgZGV2ZWxvcG1lbnQgb25seVxuXHRQYXBhLlBhcnNlciA9IFBhcnNlcjtcblx0UGFwYS5QYXJzZXJIYW5kbGUgPSBQYXJzZXJIYW5kbGU7XG5cdFBhcGEuTmV0d29ya1N0cmVhbWVyID0gTmV0d29ya1N0cmVhbWVyO1xuXHRQYXBhLkZpbGVTdHJlYW1lciA9IEZpbGVTdHJlYW1lcjtcblx0UGFwYS5TdHJpbmdTdHJlYW1lciA9IFN0cmluZ1N0cmVhbWVyO1xuXHRQYXBhLlJlYWRhYmxlU3RyZWFtU3RyZWFtZXIgPSBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyO1xuXHRpZiAodHlwZW9mIFBBUEFfQlJPV1NFUl9DT05URVhUID09PSAndW5kZWZpbmVkJykge1xuXHRcdFBhcGEuRHVwbGV4U3RyZWFtU3RyZWFtZXIgPSBEdXBsZXhTdHJlYW1TdHJlYW1lcjtcblx0fVxuXG5cdGlmIChnbG9iYWwualF1ZXJ5KVxuXHR7XG5cdFx0dmFyICQgPSBnbG9iYWwualF1ZXJ5O1xuXHRcdCQuZm4ucGFyc2UgPSBmdW5jdGlvbihvcHRpb25zKVxuXHRcdHtcblx0XHRcdHZhciBjb25maWcgPSBvcHRpb25zLmNvbmZpZyB8fCB7fTtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oaWR4KVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgc3VwcG9ydGVkID0gJCh0aGlzKS5wcm9wKCd0YWdOYW1lJykudG9VcHBlckNhc2UoKSA9PT0gJ0lOUFVUJ1xuXHRcdFx0XHRcdFx0XHRcdCYmICQodGhpcykuYXR0cigndHlwZScpLnRvTG93ZXJDYXNlKCkgPT09ICdmaWxlJ1xuXHRcdFx0XHRcdFx0XHRcdCYmIGdsb2JhbC5GaWxlUmVhZGVyO1xuXG5cdFx0XHRcdGlmICghc3VwcG9ydGVkIHx8ICF0aGlzLmZpbGVzIHx8IHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1x0Ly8gY29udGludWUgdG8gbmV4dCBpbnB1dCBlbGVtZW50XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0XHRmaWxlOiB0aGlzLmZpbGVzW2ldLFxuXHRcdFx0XHRcdFx0aW5wdXRFbGVtOiB0aGlzLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2VDb25maWc6ICQuZXh0ZW5kKHt9LCBjb25maWcpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRwYXJzZU5leHRGaWxlKCk7XHQvLyBiZWdpbiBwYXJzaW5nXG5cdFx0XHRyZXR1cm4gdGhpcztcdFx0Ly8gbWFpbnRhaW5zIGNoYWluYWJpbGl0eVxuXG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlTmV4dEZpbGUoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocXVldWUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jb21wbGV0ZSkpXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGYgPSBxdWV1ZVswXTtcblxuXHRcdFx0XHRpZiAoaXNGdW5jdGlvbihvcHRpb25zLmJlZm9yZSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBvcHRpb25zLmJlZm9yZShmLmZpbGUsIGYuaW5wdXRFbGVtKTtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcmV0dXJuZWQgPT09ICdvYmplY3QnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChyZXR1cm5lZC5hY3Rpb24gPT09ICdhYm9ydCcpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVycm9yKCdBYm9ydEVycm9yJywgZi5maWxlLCBmLmlucHV0RWxlbSwgcmV0dXJuZWQucmVhc29uKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1x0Ly8gQWJvcnRzIGFsbCBxdWV1ZWQgZmlsZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJldHVybmVkLmFjdGlvbiA9PT0gJ3NraXAnKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmaWxlQ29tcGxldGUoKTtcdC8vIHBhcnNlIHRoZSBuZXh0IGZpbGUgaW4gdGhlIHF1ZXVlLCBpZiBhbnlcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIHJldHVybmVkLmNvbmZpZyA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdFx0XHRcdGYuaW5zdGFuY2VDb25maWcgPSAkLmV4dGVuZChmLmluc3RhbmNlQ29uZmlnLCByZXR1cm5lZC5jb25maWcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChyZXR1cm5lZCA9PT0gJ3NraXAnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZpbGVDb21wbGV0ZSgpO1x0Ly8gcGFyc2UgdGhlIG5leHQgZmlsZSBpbiB0aGUgcXVldWUsIGlmIGFueVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdyYXAgdXAgdGhlIHVzZXIncyBjb21wbGV0ZSBjYWxsYmFjaywgaWYgYW55LCBzbyB0aGF0IG91cnMgYWxzbyBnZXRzIGV4ZWN1dGVkXG5cdFx0XHRcdHZhciB1c2VyQ29tcGxldGVGdW5jID0gZi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZTtcblx0XHRcdFx0Zi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZSA9IGZ1bmN0aW9uKHJlc3VsdHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaXNGdW5jdGlvbih1c2VyQ29tcGxldGVGdW5jKSlcblx0XHRcdFx0XHRcdHVzZXJDb21wbGV0ZUZ1bmMocmVzdWx0cywgZi5maWxlLCBmLmlucHV0RWxlbSk7XG5cdFx0XHRcdFx0ZmlsZUNvbXBsZXRlKCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0UGFwYS5wYXJzZShmLmZpbGUsIGYuaW5zdGFuY2VDb25maWcpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBlcnJvcihuYW1lLCBmaWxlLCBlbGVtLCByZWFzb24pXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuZXJyb3IpKVxuXHRcdFx0XHRcdG9wdGlvbnMuZXJyb3Ioe25hbWU6IG5hbWV9LCBmaWxlLCBlbGVtLCByZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBmaWxlQ29tcGxldGUoKVxuXHRcdFx0e1xuXHRcdFx0XHRxdWV1ZS5zcGxpY2UoMCwgMSk7XG5cdFx0XHRcdHBhcnNlTmV4dEZpbGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblxuXHRpZiAoSVNfUEFQQV9XT1JLRVIpXG5cdHtcblx0XHRnbG9iYWwub25tZXNzYWdlID0gd29ya2VyVGhyZWFkUmVjZWl2ZWRNZXNzYWdlO1xuXHR9XG5cblxuXG5cblx0ZnVuY3Rpb24gQ3N2VG9Kc29uKF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdF9jb25maWcgPSBfY29uZmlnIHx8IHt9O1xuXHRcdHZhciBkeW5hbWljVHlwaW5nID0gX2NvbmZpZy5keW5hbWljVHlwaW5nIHx8IGZhbHNlO1xuXHRcdGlmIChpc0Z1bmN0aW9uKGR5bmFtaWNUeXBpbmcpKSB7XG5cdFx0XHRfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiA9IGR5bmFtaWNUeXBpbmc7XG5cdFx0XHQvLyBXaWxsIGJlIGZpbGxlZCBvbiBmaXJzdCByb3cgY2FsbFxuXHRcdFx0ZHluYW1pY1R5cGluZyA9IHt9O1xuXHRcdH1cblx0XHRfY29uZmlnLmR5bmFtaWNUeXBpbmcgPSBkeW5hbWljVHlwaW5nO1xuXG5cdFx0X2NvbmZpZy50cmFuc2Zvcm0gPSBpc0Z1bmN0aW9uKF9jb25maWcudHJhbnNmb3JtKSA/IF9jb25maWcudHJhbnNmb3JtIDogZmFsc2U7XG5cblx0XHRpZiAoX2NvbmZpZy53b3JrZXIgJiYgUGFwYS5XT1JLRVJTX1NVUFBPUlRFRClcblx0XHR7XG5cdFx0XHR2YXIgdyA9IG5ld1dvcmtlcigpO1xuXG5cdFx0XHR3LnVzZXJTdGVwID0gX2NvbmZpZy5zdGVwO1xuXHRcdFx0dy51c2VyQ2h1bmsgPSBfY29uZmlnLmNodW5rO1xuXHRcdFx0dy51c2VyQ29tcGxldGUgPSBfY29uZmlnLmNvbXBsZXRlO1xuXHRcdFx0dy51c2VyRXJyb3IgPSBfY29uZmlnLmVycm9yO1xuXG5cdFx0XHRfY29uZmlnLnN0ZXAgPSBpc0Z1bmN0aW9uKF9jb25maWcuc3RlcCk7XG5cdFx0XHRfY29uZmlnLmNodW5rID0gaXNGdW5jdGlvbihfY29uZmlnLmNodW5rKTtcblx0XHRcdF9jb25maWcuY29tcGxldGUgPSBpc0Z1bmN0aW9uKF9jb25maWcuY29tcGxldGUpO1xuXHRcdFx0X2NvbmZpZy5lcnJvciA9IGlzRnVuY3Rpb24oX2NvbmZpZy5lcnJvcik7XG5cdFx0XHRkZWxldGUgX2NvbmZpZy53b3JrZXI7XHQvLyBwcmV2ZW50IGluZmluaXRlIGxvb3BcblxuXHRcdFx0dy5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdGlucHV0OiBfaW5wdXQsXG5cdFx0XHRcdGNvbmZpZzogX2NvbmZpZyxcblx0XHRcdFx0d29ya2VySWQ6IHcuaWRcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHN0cmVhbWVyID0gbnVsbDtcblx0XHRpZiAoX2lucHV0ID09PSBQYXBhLk5PREVfU1RSRUFNX0lOUFVUICYmIHR5cGVvZiBQQVBBX0JST1dTRVJfQ09OVEVYVCA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0e1xuXHRcdFx0Ly8gY3JlYXRlIGEgbm9kZSBEdXBsZXggc3RyZWFtIGZvciB1c2Vcblx0XHRcdC8vIHdpdGggLnBpcGVcblx0XHRcdHN0cmVhbWVyID0gbmV3IER1cGxleFN0cmVhbVN0cmVhbWVyKF9jb25maWcpO1xuXHRcdFx0cmV0dXJuIHN0cmVhbWVyLmdldFN0cmVhbSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJylcblx0XHR7XG5cdFx0XHRfaW5wdXQgPSBzdHJpcEJvbShfaW5wdXQpO1xuXHRcdFx0aWYgKF9jb25maWcuZG93bmxvYWQpXG5cdFx0XHRcdHN0cmVhbWVyID0gbmV3IE5ldHdvcmtTdHJlYW1lcihfY29uZmlnKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c3RyZWFtZXIgPSBuZXcgU3RyaW5nU3RyZWFtZXIoX2NvbmZpZyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKF9pbnB1dC5yZWFkYWJsZSA9PT0gdHJ1ZSAmJiBpc0Z1bmN0aW9uKF9pbnB1dC5yZWFkKSAmJiBpc0Z1bmN0aW9uKF9pbnB1dC5vbikpXG5cdFx0e1xuXHRcdFx0c3RyZWFtZXIgPSBuZXcgUmVhZGFibGVTdHJlYW1TdHJlYW1lcihfY29uZmlnKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGdsb2JhbC5GaWxlICYmIF9pbnB1dCBpbnN0YW5jZW9mIEZpbGUpIHx8IF9pbnB1dCBpbnN0YW5jZW9mIE9iamVjdClcdC8vIC4uLlNhZmFyaS4gKHNlZSBpc3N1ZSAjMTA2KVxuXHRcdFx0c3RyZWFtZXIgPSBuZXcgRmlsZVN0cmVhbWVyKF9jb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0cmVhbWVyLnN0cmVhbShfaW5wdXQpO1xuXG5cdFx0Ly8gU3RyaXAgY2hhcmFjdGVyIGZyb20gVVRGLTggQk9NIGVuY29kZWQgZmlsZXMgdGhhdCBjYXVzZSBpc3N1ZSBwYXJzaW5nIHRoZSBmaWxlXG5cdFx0ZnVuY3Rpb24gc3RyaXBCb20oc3RyaW5nKSB7XG5cdFx0XHRpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDB4ZmVmZikge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5nLnNsaWNlKDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHR9XG5cdH1cblxuXG5cblxuXG5cblx0ZnVuY3Rpb24gSnNvblRvQ3N2KF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdC8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuXG5cdFx0LyoqIHdoZXRoZXIgdG8gc3Vycm91bmQgZXZlcnkgZGF0dW0gd2l0aCBxdW90ZXMgKi9cblx0XHR2YXIgX3F1b3RlcyA9IGZhbHNlO1xuXG5cdFx0LyoqIHdoZXRoZXIgdG8gd3JpdGUgaGVhZGVycyAqL1xuXHRcdHZhciBfd3JpdGVIZWFkZXIgPSB0cnVlO1xuXG5cdFx0LyoqIGRlbGltaXRpbmcgY2hhcmFjdGVyKHMpICovXG5cdFx0dmFyIF9kZWxpbWl0ZXIgPSAnLCc7XG5cblx0XHQvKiogbmV3bGluZSBjaGFyYWN0ZXIocykgKi9cblx0XHR2YXIgX25ld2xpbmUgPSAnXFxyXFxuJztcblxuXHRcdC8qKiBxdW90ZSBjaGFyYWN0ZXIgKi9cblx0XHR2YXIgX3F1b3RlQ2hhciA9ICdcIic7XG5cblx0XHQvKiogZXNjYXBlZCBxdW90ZSBjaGFyYWN0ZXIsIGVpdGhlciBcIlwiIG9yIDxjb25maWcuZXNjYXBlQ2hhcj5cIiAqL1xuXHRcdHZhciBfZXNjYXBlZFF1b3RlID0gX3F1b3RlQ2hhciArIF9xdW90ZUNoYXI7XG5cblx0XHQvKiogd2hldGhlciB0byBza2lwIGVtcHR5IGxpbmVzICovXG5cdFx0dmFyIF9za2lwRW1wdHlMaW5lcyA9IGZhbHNlO1xuXG5cdFx0LyoqIHRoZSBjb2x1bW5zIChrZXlzKSB3ZSBleHBlY3Qgd2hlbiB3ZSB1bnBhcnNlIG9iamVjdHMgKi9cblx0XHR2YXIgX2NvbHVtbnMgPSBudWxsO1xuXG5cdFx0LyoqIHdoZXRoZXIgdG8gcHJldmVudCBvdXRwdXR0aW5nIGNlbGxzIHRoYXQgY2FuIGJlIHBhcnNlZCBhcyBmb3JtdWxhZSBieSBzcHJlYWRzaGVldCBzb2Z0d2FyZSAoRXhjZWwgYW5kIExpYnJlT2ZmaWNlKSAqL1xuXHRcdHZhciBfZXNjYXBlRm9ybXVsYWUgPSBmYWxzZTtcblxuXHRcdHVucGFja0NvbmZpZygpO1xuXG5cdFx0dmFyIHF1b3RlQ2hhclJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoX3F1b3RlQ2hhciksICdnJyk7XG5cblx0XHRpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ3N0cmluZycpXG5cdFx0XHRfaW5wdXQgPSBKU09OLnBhcnNlKF9pbnB1dCk7XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShfaW5wdXQpKVxuXHRcdHtcblx0XHRcdGlmICghX2lucHV0Lmxlbmd0aCB8fCBBcnJheS5pc0FycmF5KF9pbnB1dFswXSkpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUobnVsbCwgX2lucHV0LCBfc2tpcEVtcHR5TGluZXMpO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIF9pbnB1dFswXSA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUoX2NvbHVtbnMgfHwgT2JqZWN0LmtleXMoX2lucHV0WzBdKSwgX2lucHV0LCBfc2tpcEVtcHR5TGluZXMpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0ID09PSAnb2JqZWN0Jylcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIF9pbnB1dC5kYXRhID09PSAnc3RyaW5nJylcblx0XHRcdFx0X2lucHV0LmRhdGEgPSBKU09OLnBhcnNlKF9pbnB1dC5kYXRhKTtcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGEpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIV9pbnB1dC5maWVsZHMpXG5cdFx0XHRcdFx0X2lucHV0LmZpZWxkcyA9IF9pbnB1dC5tZXRhICYmIF9pbnB1dC5tZXRhLmZpZWxkcyB8fCBfY29sdW1ucztcblxuXHRcdFx0XHRpZiAoIV9pbnB1dC5maWVsZHMpXG5cdFx0XHRcdFx0X2lucHV0LmZpZWxkcyA9ICBBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhWzBdKVxuXHRcdFx0XHRcdFx0PyBfaW5wdXQuZmllbGRzXG5cdFx0XHRcdFx0XHQ6IHR5cGVvZiBfaW5wdXQuZGF0YVswXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0XHRcdFx0PyBPYmplY3Qua2V5cyhfaW5wdXQuZGF0YVswXSlcblx0XHRcdFx0XHRcdFx0OiBbXTtcblxuXHRcdFx0XHRpZiAoIShBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhWzBdKSkgJiYgdHlwZW9mIF9pbnB1dC5kYXRhWzBdICE9PSAnb2JqZWN0Jylcblx0XHRcdFx0XHRfaW5wdXQuZGF0YSA9IFtfaW5wdXQuZGF0YV07XHQvLyBoYW5kbGVzIGlucHV0IGxpa2UgWzEsMiwzXSBvciBbJ2FzZGYnXVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2VyaWFsaXplKF9pbnB1dC5maWVsZHMgfHwgW10sIF9pbnB1dC5kYXRhIHx8IFtdLCBfc2tpcEVtcHR5TGluZXMpO1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgKGFueSB2YWxpZCBwYXRocyBzaG91bGQgcmV0dXJuIGJlZm9yZSB0aGlzKVxuXHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNlcmlhbGl6ZSB1bnJlY29nbml6ZWQgaW5wdXQnKTtcblxuXG5cdFx0ZnVuY3Rpb24gdW5wYWNrQ29uZmlnKClcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcgIT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgJiYgIVBhcGEuQkFEX0RFTElNSVRFUlMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBfY29uZmlnLmRlbGltaXRlci5pbmRleE9mKHZhbHVlKSAhPT0gLTE7IH0pLmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0X2RlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcucXVvdGVzID09PSAnYm9vbGVhbidcblx0XHRcdFx0fHwgdHlwZW9mIF9jb25maWcucXVvdGVzID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoX2NvbmZpZy5xdW90ZXMpKVxuXHRcdFx0XHRfcXVvdGVzID0gX2NvbmZpZy5xdW90ZXM7XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5za2lwRW1wdHlMaW5lcyA9PT0gJ2Jvb2xlYW4nXG5cdFx0XHRcdHx8IHR5cGVvZiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnc3RyaW5nJylcblx0XHRcdFx0X3NraXBFbXB0eUxpbmVzID0gX2NvbmZpZy5za2lwRW1wdHlMaW5lcztcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLm5ld2xpbmUgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfbmV3bGluZSA9IF9jb25maWcubmV3bGluZTtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLnF1b3RlQ2hhciA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdF9xdW90ZUNoYXIgPSBfY29uZmlnLnF1b3RlQ2hhcjtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLmhlYWRlciA9PT0gJ2Jvb2xlYW4nKVxuXHRcdFx0XHRfd3JpdGVIZWFkZXIgPSBfY29uZmlnLmhlYWRlcjtcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoX2NvbmZpZy5jb2x1bW5zKSkge1xuXG5cdFx0XHRcdGlmIChfY29uZmlnLmNvbHVtbnMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBjb2x1bW5zIGlzIGVtcHR5Jyk7XG5cblx0XHRcdFx0X2NvbHVtbnMgPSBfY29uZmlnLmNvbHVtbnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfY29uZmlnLmVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfZXNjYXBlZFF1b3RlID0gX2NvbmZpZy5lc2NhcGVDaGFyICsgX3F1b3RlQ2hhcjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLmVzY2FwZUZvcm11bGFlID09PSAnYm9vbGVhbicgfHwgX2NvbmZpZy5lc2NhcGVGb3JtdWxhZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRfZXNjYXBlRm9ybXVsYWUgPSBfY29uZmlnLmVzY2FwZUZvcm11bGFlIGluc3RhbmNlb2YgUmVnRXhwID8gX2NvbmZpZy5lc2NhcGVGb3JtdWxhZSA6IC9eWz0rXFwtQFxcdFxccl0uKiQvO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKiBUaGUgZG91YmxlIGZvciBsb29wIHRoYXQgaXRlcmF0ZXMgdGhlIGRhdGEgYW5kIHdyaXRlcyBvdXQgYSBDU1Ygc3RyaW5nIGluY2x1ZGluZyBoZWFkZXIgcm93ICovXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcywgZGF0YSwgc2tpcEVtcHR5TGluZXMpXG5cdFx0e1xuXHRcdFx0dmFyIGNzdiA9ICcnO1xuXG5cdFx0XHRpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGZpZWxkcyA9IEpTT04ucGFyc2UoZmllbGRzKTtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG5cdFx0XHR2YXIgaGFzSGVhZGVyID0gQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIGZpZWxkcy5sZW5ndGggPiAwO1xuXHRcdFx0dmFyIGRhdGFLZXllZEJ5RmllbGQgPSAhKEFycmF5LmlzQXJyYXkoZGF0YVswXSkpO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhIGhlYWRlciByb3csIHdyaXRlIGl0IGZpcnN0XG5cdFx0XHRpZiAoaGFzSGVhZGVyICYmIF93cml0ZUhlYWRlcilcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaSA+IDApXG5cdFx0XHRcdFx0XHRjc3YgKz0gX2RlbGltaXRlcjtcblx0XHRcdFx0XHRjc3YgKz0gc2FmZShmaWVsZHNbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkYXRhLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0Y3N2ICs9IF9uZXdsaW5lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVuIHdyaXRlIG91dCB0aGUgZGF0YVxuXHRcdFx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgZGF0YS5sZW5ndGg7IHJvdysrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbWF4Q29sID0gaGFzSGVhZGVyID8gZmllbGRzLmxlbmd0aCA6IGRhdGFbcm93XS5sZW5ndGg7XG5cblx0XHRcdFx0dmFyIGVtcHR5TGluZSA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgbnVsbExpbmUgPSBoYXNIZWFkZXIgPyBPYmplY3Qua2V5cyhkYXRhW3Jvd10pLmxlbmd0aCA9PT0gMCA6IGRhdGFbcm93XS5sZW5ndGggPT09IDA7XG5cdFx0XHRcdGlmIChza2lwRW1wdHlMaW5lcyAmJiAhaGFzSGVhZGVyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW1wdHlMaW5lID0gc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknID8gZGF0YVtyb3ddLmpvaW4oJycpLnRyaW0oKSA9PT0gJycgOiBkYXRhW3Jvd10ubGVuZ3RoID09PSAxICYmIGRhdGFbcm93XVswXS5sZW5ndGggPT09IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5JyAmJiBoYXNIZWFkZXIpIHtcblx0XHRcdFx0XHR2YXIgbGluZSA9IFtdO1xuXHRcdFx0XHRcdGZvciAodmFyIGMgPSAwOyBjIDwgbWF4Q29sOyBjKyspIHtcblx0XHRcdFx0XHRcdHZhciBjeCA9IGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY10gOiBjO1xuXHRcdFx0XHRcdFx0bGluZS5wdXNoKGRhdGFbcm93XVtjeF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbXB0eUxpbmUgPSBsaW5lLmpvaW4oJycpLnRyaW0oKSA9PT0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFlbXB0eUxpbmUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtYXhDb2w7IGNvbCsrKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChjb2wgPiAwICYmICFudWxsTGluZSlcblx0XHRcdFx0XHRcdFx0Y3N2ICs9IF9kZWxpbWl0ZXI7XG5cdFx0XHRcdFx0XHR2YXIgY29sSWR4ID0gaGFzSGVhZGVyICYmIGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY29sXSA6IGNvbDtcblx0XHRcdFx0XHRcdGNzdiArPSBzYWZlKGRhdGFbcm93XVtjb2xJZHhdLCBjb2wpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocm93IDwgZGF0YS5sZW5ndGggLSAxICYmICghc2tpcEVtcHR5TGluZXMgfHwgKG1heENvbCA+IDAgJiYgIW51bGxMaW5lKSkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y3N2ICs9IF9uZXdsaW5lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNzdjtcblx0XHR9XG5cblx0XHQvKiogRW5jbG9zZXMgYSB2YWx1ZSBhcm91bmQgcXVvdGVzIGlmIG5lZWRlZCAobWFrZXMgYSB2YWx1ZSBzYWZlIGZvciBDU1YgaW5zZXJ0aW9uKSAqL1xuXHRcdGZ1bmN0aW9uIHNhZmUoc3RyLCBjb2wpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnIHx8IHN0ciA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0XHRpZiAoc3RyLmNvbnN0cnVjdG9yID09PSBEYXRlKVxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKS5zbGljZSgxLCAyNSk7XG5cblx0XHRcdHZhciBuZWVkc1F1b3RlcyA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoX2VzY2FwZUZvcm11bGFlICYmIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgX2VzY2FwZUZvcm11bGFlLnRlc3Qoc3RyKSkge1xuXHRcdFx0XHRzdHIgPSBcIidcIiArIHN0cjtcblx0XHRcdFx0bmVlZHNRdW90ZXMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXNjYXBlZFF1b3RlU3RyID0gc3RyLnRvU3RyaW5nKCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgX2VzY2FwZWRRdW90ZSk7XG5cblx0XHRcdG5lZWRzUXVvdGVzID0gbmVlZHNRdW90ZXNcblx0XHRcdFx0XHRcdFx0fHwgX3F1b3RlcyA9PT0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHR8fCAodHlwZW9mIF9xdW90ZXMgPT09ICdmdW5jdGlvbicgJiYgX3F1b3RlcyhzdHIsIGNvbCkpXG5cdFx0XHRcdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KF9xdW90ZXMpICYmIF9xdW90ZXNbY29sXSlcblx0XHRcdFx0XHRcdFx0fHwgaGFzQW55KGVzY2FwZWRRdW90ZVN0ciwgUGFwYS5CQURfREVMSU1JVEVSUylcblx0XHRcdFx0XHRcdFx0fHwgZXNjYXBlZFF1b3RlU3RyLmluZGV4T2YoX2RlbGltaXRlcikgPiAtMVxuXHRcdFx0XHRcdFx0XHR8fCBlc2NhcGVkUXVvdGVTdHIuY2hhckF0KDApID09PSAnICdcblx0XHRcdFx0XHRcdFx0fHwgZXNjYXBlZFF1b3RlU3RyLmNoYXJBdChlc2NhcGVkUXVvdGVTdHIubGVuZ3RoIC0gMSkgPT09ICcgJztcblxuXHRcdFx0cmV0dXJuIG5lZWRzUXVvdGVzID8gX3F1b3RlQ2hhciArIGVzY2FwZWRRdW90ZVN0ciArIF9xdW90ZUNoYXIgOiBlc2NhcGVkUXVvdGVTdHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFzQW55KHN0ciwgc3Vic3RyaW5ncylcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGlmIChzdHIuaW5kZXhPZihzdWJzdHJpbmdzW2ldKSA+IC0xKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBDaHVua1N0cmVhbWVyIGlzIHRoZSBiYXNlIHByb3RvdHlwZSBmb3IgdmFyaW91cyBzdHJlYW1lciBpbXBsZW1lbnRhdGlvbnMuICovXG5cdGZ1bmN0aW9uIENodW5rU3RyZWFtZXIoY29uZmlnKVxuXHR7XG5cdFx0dGhpcy5faGFuZGxlID0gbnVsbDtcblx0XHR0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhbHRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2lucHV0ID0gbnVsbDtcblx0XHR0aGlzLl9iYXNlSW5kZXggPSAwO1xuXHRcdHRoaXMuX3BhcnRpYWxMaW5lID0gJyc7XG5cdFx0dGhpcy5fcm93Q291bnQgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0ID0gMDtcblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBudWxsO1xuXHRcdHRoaXMuaXNGaXJzdENodW5rID0gdHJ1ZTtcblx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMgPSB7XG5cdFx0XHRkYXRhOiBbXSxcblx0XHRcdGVycm9yczogW10sXG5cdFx0XHRtZXRhOiB7fVxuXHRcdH07XG5cdFx0cmVwbGFjZUNvbmZpZy5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR0aGlzLnBhcnNlQ2h1bmsgPSBmdW5jdGlvbihjaHVuaywgaXNGYWtlQ2h1bmspXG5cdFx0e1xuXHRcdFx0Ly8gRmlyc3QgY2h1bmsgcHJlLXByb2Nlc3Npbmdcblx0XHRcdGlmICh0aGlzLmlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIG1vZGlmaWVkQ2h1bmsgPSB0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuayhjaHVuayk7XG5cdFx0XHRcdGlmIChtb2RpZmllZENodW5rICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0Y2h1bmsgPSBtb2RpZmllZENodW5rO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2hhbHRlZCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBSZWpvaW4gdGhlIGxpbmUgd2UgbGlrZWx5IGp1c3Qgc3BsaXQgaW4gdHdvIGJ5IGNodW5raW5nIHRoZSBmaWxlXG5cdFx0XHR2YXIgYWdncmVnYXRlID0gdGhpcy5fcGFydGlhbExpbmUgKyBjaHVuaztcblx0XHRcdHRoaXMuX3BhcnRpYWxMaW5lID0gJyc7XG5cblx0XHRcdHZhciByZXN1bHRzID0gdGhpcy5faGFuZGxlLnBhcnNlKGFnZ3JlZ2F0ZSwgdGhpcy5fYmFzZUluZGV4LCAhdGhpcy5fZmluaXNoZWQpO1xuXG5cdFx0XHRpZiAodGhpcy5faGFuZGxlLnBhdXNlZCgpIHx8IHRoaXMuX2hhbmRsZS5hYm9ydGVkKCkpIHtcblx0XHRcdFx0dGhpcy5faGFsdGVkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGFzdEluZGV4ID0gcmVzdWx0cy5tZXRhLmN1cnNvcjtcblxuXHRcdFx0aWYgKCF0aGlzLl9maW5pc2hlZClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fcGFydGlhbExpbmUgPSBhZ2dyZWdhdGUuc3Vic3RyaW5nKGxhc3RJbmRleCAtIHRoaXMuX2Jhc2VJbmRleCk7XG5cdFx0XHRcdHRoaXMuX2Jhc2VJbmRleCA9IGxhc3RJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5kYXRhKVxuXHRcdFx0XHR0aGlzLl9yb3dDb3VudCArPSByZXN1bHRzLmRhdGEubGVuZ3RoO1xuXG5cdFx0XHR2YXIgZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3ID0gdGhpcy5fZmluaXNoZWQgfHwgKHRoaXMuX2NvbmZpZy5wcmV2aWV3ICYmIHRoaXMuX3Jvd0NvdW50ID49IHRoaXMuX2NvbmZpZy5wcmV2aWV3KTtcblxuXHRcdFx0aWYgKElTX1BBUEFfV09SS0VSKVxuXHRcdFx0e1xuXHRcdFx0XHRnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRcdHJlc3VsdHM6IHJlc3VsdHMsXG5cdFx0XHRcdFx0d29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuXHRcdFx0XHRcdGZpbmlzaGVkOiBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5jaHVuaykgJiYgIWlzRmFrZUNodW5rKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9jb25maWcuY2h1bmsocmVzdWx0cywgdGhpcy5faGFuZGxlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2hhbmRsZS5wYXVzZWQoKSB8fCB0aGlzLl9oYW5kbGUuYWJvcnRlZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5faGFsdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0cyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0dGhpcy5fY29tcGxldGVSZXN1bHRzID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2NvbmZpZy5zdGVwICYmICF0aGlzLl9jb25maWcuY2h1bmspIHtcblx0XHRcdFx0dGhpcy5fY29tcGxldGVSZXN1bHRzLmRhdGEgPSB0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YS5jb25jYXQocmVzdWx0cy5kYXRhKTtcblx0XHRcdFx0dGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycyA9IHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5lcnJvcnMuY29uY2F0KHJlc3VsdHMuZXJyb3JzKTtcblx0XHRcdFx0dGhpcy5fY29tcGxldGVSZXN1bHRzLm1ldGEgPSByZXN1bHRzLm1ldGE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fY29tcGxldGVkICYmIGZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyAmJiBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb21wbGV0ZSkgJiYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLm1ldGEuYWJvcnRlZCkpIHtcblx0XHRcdFx0dGhpcy5fY29uZmlnLmNvbXBsZXRlKHRoaXMuX2NvbXBsZXRlUmVzdWx0cywgdGhpcy5faW5wdXQpO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyAmJiAoIXJlc3VsdHMgfHwgIXJlc3VsdHMubWV0YS5wYXVzZWQpKVxuXHRcdFx0XHR0aGlzLl9uZXh0Q2h1bmsoKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHRcdHRoaXMuX3NlbmRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKVxuXHRcdHtcblx0XHRcdGlmIChpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5lcnJvcikpXG5cdFx0XHRcdHRoaXMuX2NvbmZpZy5lcnJvcihlcnJvcik7XG5cdFx0XHRlbHNlIGlmIChJU19QQVBBX1dPUktFUiAmJiB0aGlzLl9jb25maWcuZXJyb3IpXG5cdFx0XHR7XG5cdFx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdFx0d29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuXHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHRmaW5pc2hlZDogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlcGxhY2VDb25maWcoY29uZmlnKVxuXHRcdHtcblx0XHRcdC8vIERlZXAtY29weSB0aGUgY29uZmlnIHNvIHdlIGNhbiBlZGl0IGl0XG5cdFx0XHR2YXIgY29uZmlnQ29weSA9IGNvcHkoY29uZmlnKTtcblx0XHRcdGNvbmZpZ0NvcHkuY2h1bmtTaXplID0gcGFyc2VJbnQoY29uZmlnQ29weS5jaHVua1NpemUpO1x0Ly8gcGFyc2VJbnQgVkVSWSBpbXBvcnRhbnQgc28gd2UgZG9uJ3QgY29uY2F0ZW5hdGUgc3RyaW5ncyFcblx0XHRcdGlmICghY29uZmlnLnN0ZXAgJiYgIWNvbmZpZy5jaHVuaylcblx0XHRcdFx0Y29uZmlnQ29weS5jaHVua1NpemUgPSBudWxsOyAgLy8gZGlzYWJsZSBSYW5nZSBoZWFkZXIgaWYgbm90IHN0cmVhbWluZzsgYmFkIHZhbHVlcyBicmVhayBJSVMgLSBzZWUgaXNzdWUgIzE5NlxuXHRcdFx0dGhpcy5faGFuZGxlID0gbmV3IFBhcnNlckhhbmRsZShjb25maWdDb3B5KTtcblx0XHRcdHRoaXMuX2hhbmRsZS5zdHJlYW1lciA9IHRoaXM7XG5cdFx0XHR0aGlzLl9jb25maWcgPSBjb25maWdDb3B5O1x0Ly8gcGVyc2lzdCB0aGUgY29weSB0byB0aGUgY2FsbGVyXG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBOZXR3b3JrU3RyZWFtZXIoY29uZmlnKVxuXHR7XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXHRcdGlmICghY29uZmlnLmNodW5rU2l6ZSlcblx0XHRcdGNvbmZpZy5jaHVua1NpemUgPSBQYXBhLlJlbW90ZUNodW5rU2l6ZTtcblx0XHRDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHZhciB4aHI7XG5cblx0XHRpZiAoSVNfV09SS0VSKVxuXHRcdHtcblx0XHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fcmVhZENodW5rKCk7XG5cdFx0XHRcdHRoaXMuX2NodW5rTG9hZGVkKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9yZWFkQ2h1bmsoKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpcy5zdHJlYW0gPSBmdW5jdGlvbih1cmwpXG5cdFx0e1xuXHRcdFx0dGhpcy5faW5wdXQgPSB1cmw7XG5cdFx0XHR0aGlzLl9uZXh0Q2h1bmsoKTtcdC8vIFN0YXJ0cyBzdHJlYW1pbmdcblx0XHR9O1xuXG5cdFx0dGhpcy5fcmVhZENodW5rID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9maW5pc2hlZClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fY2h1bmtMb2FkZWQoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdFx0aWYgKHRoaXMuX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMpXG5cdFx0XHR7XG5cdFx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLl9jb25maWcud2l0aENyZWRlbnRpYWxzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIUlTX1dPUktFUilcblx0XHRcdHtcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGJpbmRGdW5jdGlvbih0aGlzLl9jaHVua0xvYWRlZCwgdGhpcyk7XG5cdFx0XHRcdHhoci5vbmVycm9yID0gYmluZEZ1bmN0aW9uKHRoaXMuX2NodW5rRXJyb3IsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHR4aHIub3Blbih0aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0Qm9keSA/ICdQT1NUJyA6ICdHRVQnLCB0aGlzLl9pbnB1dCwgIUlTX1dPUktFUik7XG5cdFx0XHQvLyBIZWFkZXJzIGNhbiBvbmx5IGJlIHNldCB3aGVuIG9uY2UgdGhlIHJlcXVlc3Qgc3RhdGUgaXMgT1BFTkVEXG5cdFx0XHRpZiAodGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEhlYWRlcnMpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBoZWFkZXJzID0gdGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEhlYWRlcnM7XG5cblx0XHRcdFx0Zm9yICh2YXIgaGVhZGVyTmFtZSBpbiBoZWFkZXJzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyc1toZWFkZXJOYW1lXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2NvbmZpZy5jaHVua1NpemUpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLl9zdGFydCArIHRoaXMuX2NvbmZpZy5jaHVua1NpemUgLSAxO1x0Ly8gbWludXMgb25lIGJlY2F1c2UgYnl0ZSByYW5nZSBpcyBpbmNsdXNpdmVcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyB0aGlzLl9zdGFydCArICctJyArIGVuZCk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHhoci5zZW5kKHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RCb2R5KTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dGhpcy5fY2h1bmtFcnJvcihlcnIubWVzc2FnZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChJU19XT1JLRVIgJiYgeGhyLnN0YXR1cyA9PT0gMClcblx0XHRcdFx0dGhpcy5fY2h1bmtFcnJvcigpO1xuXHRcdH07XG5cblx0XHR0aGlzLl9jaHVua0xvYWRlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0aWYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+PSA0MDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2NodW5rRXJyb3IoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgY2h1bmNrU2l6ZSBhcyBpdCBtYXkgYmUgYSBkaWZlcmVuY2Ugb24gcmVwb25zZSBsZW50Z2ggZHVlIHRvIGNoYXJhY3RlcnMgd2l0aCBtb3JlIHRoYW4gMSBieXRlXG5cdFx0XHR0aGlzLl9zdGFydCArPSB0aGlzLl9jb25maWcuY2h1bmtTaXplID8gdGhpcy5fY29uZmlnLmNodW5rU2l6ZSA6IHhoci5yZXNwb25zZVRleHQubGVuZ3RoO1xuXHRcdFx0dGhpcy5fZmluaXNoZWQgPSAhdGhpcy5fY29uZmlnLmNodW5rU2l6ZSB8fCB0aGlzLl9zdGFydCA+PSBnZXRGaWxlU2l6ZSh4aHIpO1xuXHRcdFx0dGhpcy5wYXJzZUNodW5rKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdH07XG5cblx0XHR0aGlzLl9jaHVua0Vycm9yID0gZnVuY3Rpb24oZXJyb3JNZXNzYWdlKVxuXHRcdHtcblx0XHRcdHZhciBlcnJvclRleHQgPSB4aHIuc3RhdHVzVGV4dCB8fCBlcnJvck1lc3NhZ2U7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IobmV3IEVycm9yKGVycm9yVGV4dCkpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRGaWxlU2l6ZSh4aHIpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbnRlbnRSYW5nZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1SYW5nZScpO1xuXHRcdFx0aWYgKGNvbnRlbnRSYW5nZSA9PT0gbnVsbCkgeyAvLyBubyBjb250ZW50IHJhbmdlLCB0aGVuIGZpbmlzaCFcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KGNvbnRlbnRSYW5nZS5zdWJzdHJpbmcoY29udGVudFJhbmdlLmxhc3RJbmRleE9mKCcvJykgKyAxKSk7XG5cdFx0fVxuXHR9XG5cdE5ldHdvcmtTdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENodW5rU3RyZWFtZXIucHJvdG90eXBlKTtcblx0TmV0d29ya1N0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5ldHdvcmtTdHJlYW1lcjtcblxuXG5cdGZ1bmN0aW9uIEZpbGVTdHJlYW1lcihjb25maWcpXG5cdHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0aWYgKCFjb25maWcuY2h1bmtTaXplKVxuXHRcdFx0Y29uZmlnLmNodW5rU2l6ZSA9IFBhcGEuTG9jYWxDaHVua1NpemU7XG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR2YXIgcmVhZGVyLCBzbGljZTtcblxuXHRcdC8vIEZpbGVSZWFkZXIgaXMgYmV0dGVyIHRoYW4gRmlsZVJlYWRlclN5bmMgKGV2ZW4gaW4gd29ya2VyKSAtIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yNDcwODY0OS8xMDQ4ODYyXG5cdFx0Ly8gQnV0IEZpcmVmb3ggaXMgYSBwaWxsLCB0b28gLSBzZWUgaXNzdWUgIzc2OiBodHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlL2lzc3Vlcy83NlxuXHRcdHZhciB1c2luZ0FzeW5jUmVhZGVyID0gdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnO1x0Ly8gU2FmYXJpIGRvZXNuJ3QgY29uc2lkZXIgaXQgYSBmdW5jdGlvbiAtIHNlZSBpc3N1ZSAjMTA1XG5cblx0XHR0aGlzLnN0cmVhbSA9IGZ1bmN0aW9uKGZpbGUpXG5cdFx0e1xuXHRcdFx0dGhpcy5faW5wdXQgPSBmaWxlO1xuXHRcdFx0c2xpY2UgPSBmaWxlLnNsaWNlIHx8IGZpbGUud2Via2l0U2xpY2UgfHwgZmlsZS5tb3pTbGljZTtcblxuXHRcdFx0aWYgKHVzaW5nQXN5bmNSZWFkZXIpXG5cdFx0XHR7XG5cdFx0XHRcdHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHRcdC8vIFByZWZlcnJlZCBtZXRob2Qgb2YgcmVhZGluZyBmaWxlcywgZXZlbiBpbiB3b3JrZXJzXG5cdFx0XHRcdHJlYWRlci5vbmxvYWQgPSBiaW5kRnVuY3Rpb24odGhpcy5fY2h1bmtMb2FkZWQsIHRoaXMpO1xuXHRcdFx0XHRyZWFkZXIub25lcnJvciA9IGJpbmRGdW5jdGlvbih0aGlzLl9jaHVua0Vycm9yLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVhZGVyID0gbmV3IEZpbGVSZWFkZXJTeW5jKCk7XHQvLyBIYWNrIGZvciBydW5uaW5nIGluIGEgd2ViIHdvcmtlciBpbiBGaXJlZm94XG5cblx0XHRcdHRoaXMuX25leHRDaHVuaygpO1x0Ly8gU3RhcnRzIHN0cmVhbWluZ1xuXHRcdH07XG5cblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLl9maW5pc2hlZCAmJiAoIXRoaXMuX2NvbmZpZy5wcmV2aWV3IHx8IHRoaXMuX3Jvd0NvdW50IDwgdGhpcy5fY29uZmlnLnByZXZpZXcpKVxuXHRcdFx0XHR0aGlzLl9yZWFkQ2h1bmsoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5fcmVhZENodW5rID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuXHRcdFx0aWYgKHRoaXMuX2NvbmZpZy5jaHVua1NpemUpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBlbmQgPSBNYXRoLm1pbih0aGlzLl9zdGFydCArIHRoaXMuX2NvbmZpZy5jaHVua1NpemUsIHRoaXMuX2lucHV0LnNpemUpO1xuXHRcdFx0XHRpbnB1dCA9IHNsaWNlLmNhbGwoaW5wdXQsIHRoaXMuX3N0YXJ0LCBlbmQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHR4dCA9IHJlYWRlci5yZWFkQXNUZXh0KGlucHV0LCB0aGlzLl9jb25maWcuZW5jb2RpbmcpO1xuXHRcdFx0aWYgKCF1c2luZ0FzeW5jUmVhZGVyKVxuXHRcdFx0XHR0aGlzLl9jaHVua0xvYWRlZCh7IHRhcmdldDogeyByZXN1bHQ6IHR4dCB9IH0pO1x0Ly8gbWltaWMgdGhlIGFzeW5jIHNpZ25hdHVyZVxuXHRcdH07XG5cblx0XHR0aGlzLl9jaHVua0xvYWRlZCA9IGZ1bmN0aW9uKGV2ZW50KVxuXHRcdHtcblx0XHRcdC8vIFZlcnkgaW1wb3J0YW50IHRvIGluY3JlbWVudCBzdGFydCBlYWNoIHRpbWUgYmVmb3JlIGhhbmRsaW5nIHJlc3VsdHNcblx0XHRcdHRoaXMuX3N0YXJ0ICs9IHRoaXMuX2NvbmZpZy5jaHVua1NpemU7XG5cdFx0XHR0aGlzLl9maW5pc2hlZCA9ICF0aGlzLl9jb25maWcuY2h1bmtTaXplIHx8IHRoaXMuX3N0YXJ0ID49IHRoaXMuX2lucHV0LnNpemU7XG5cdFx0XHR0aGlzLnBhcnNlQ2h1bmsoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX2NodW5rRXJyb3IgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKHJlYWRlci5lcnJvcik7XG5cdFx0fTtcblxuXHR9XG5cdEZpbGVTdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENodW5rU3RyZWFtZXIucHJvdG90eXBlKTtcblx0RmlsZVN0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbGVTdHJlYW1lcjtcblxuXG5cdGZ1bmN0aW9uIFN0cmluZ1N0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHZhciByZW1haW5pbmc7XG5cdFx0dGhpcy5zdHJlYW0gPSBmdW5jdGlvbihzKVxuXHRcdHtcblx0XHRcdHJlbWFpbmluZyA9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmV4dENodW5rKCk7XG5cdFx0fTtcblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHRoaXMuX2NvbmZpZy5jaHVua1NpemU7XG5cdFx0XHR2YXIgY2h1bms7XG5cdFx0XHRpZihzaXplKSB7XG5cdFx0XHRcdGNodW5rID0gcmVtYWluaW5nLnN1YnN0cmluZygwLCBzaXplKTtcblx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhzaXplKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNodW5rID0gcmVtYWluaW5nO1xuXHRcdFx0XHRyZW1haW5pbmcgPSAnJztcblx0XHRcdH1cblx0XHRcdHRoaXMuX2ZpbmlzaGVkID0gIXJlbWFpbmluZztcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ2h1bmsoY2h1bmspO1xuXHRcdH07XG5cdH1cblx0U3RyaW5nU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJpbmdTdHJlYW1lci5wcm90b3R5cGUpO1xuXHRTdHJpbmdTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdHJpbmdTdHJlYW1lcjtcblxuXG5cdGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtU3RyZWFtZXIoY29uZmlnKVxuXHR7XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHR2YXIgcGFyc2VPbkRhdGEgPSB0cnVlO1xuXHRcdHZhciBzdHJlYW1IYXNFbmRlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5wYXVzZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRDaHVua1N0cmVhbWVyLnByb3RvdHlwZS5wYXVzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5faW5wdXQucGF1c2UoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0Q2h1bmtTdHJlYW1lci5wcm90b3R5cGUucmVzdW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9pbnB1dC5yZXN1bWUoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pXG5cdFx0e1xuXHRcdFx0dGhpcy5faW5wdXQgPSBzdHJlYW07XG5cblx0XHRcdHRoaXMuX2lucHV0Lm9uKCdkYXRhJywgdGhpcy5fc3RyZWFtRGF0YSk7XG5cdFx0XHR0aGlzLl9pbnB1dC5vbignZW5kJywgdGhpcy5fc3RyZWFtRW5kKTtcblx0XHRcdHRoaXMuX2lucHV0Lm9uKCdlcnJvcicsIHRoaXMuX3N0cmVhbUVycm9yKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5fY2hlY2tJc0ZpbmlzaGVkID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmIChzdHJlYW1IYXNFbmRlZCAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0dGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY2hlY2tJc0ZpbmlzaGVkKCk7XG5cdFx0XHRpZiAocXVldWUubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnBhcnNlQ2h1bmsocXVldWUuc2hpZnQoKSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHBhcnNlT25EYXRhID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fc3RyZWFtRGF0YSA9IGJpbmRGdW5jdGlvbihmdW5jdGlvbihjaHVuaylcblx0XHR7XG5cdFx0XHR0cnlcblx0XHRcdHtcblx0XHRcdFx0cXVldWUucHVzaCh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnID8gY2h1bmsgOiBjaHVuay50b1N0cmluZyh0aGlzLl9jb25maWcuZW5jb2RpbmcpKTtcblxuXHRcdFx0XHRpZiAocGFyc2VPbkRhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZU9uRGF0YSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuX2NoZWNrSXNGaW5pc2hlZCgpO1xuXHRcdFx0XHRcdHRoaXMucGFyc2VDaHVuayhxdWV1ZS5zaGlmdCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9zdHJlYW1FcnJvcihlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9zdHJlYW1FcnJvciA9IGJpbmRGdW5jdGlvbihmdW5jdGlvbihlcnJvcilcblx0XHR7XG5cdFx0XHR0aGlzLl9zdHJlYW1DbGVhblVwKCk7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXJyb3IpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fc3RyZWFtRW5kID0gYmluZEZ1bmN0aW9uKGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLl9zdHJlYW1DbGVhblVwKCk7XG5cdFx0XHRzdHJlYW1IYXNFbmRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zdHJlYW1EYXRhKCcnKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX3N0cmVhbUNsZWFuVXAgPSBiaW5kRnVuY3Rpb24oZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lucHV0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgdGhpcy5fc3RyZWFtRGF0YSk7XG5cdFx0XHR0aGlzLl9pbnB1dC5yZW1vdmVMaXN0ZW5lcignZW5kJywgdGhpcy5fc3RyZWFtRW5kKTtcblx0XHRcdHRoaXMuX2lucHV0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMuX3N0cmVhbUVycm9yKTtcblx0XHR9LCB0aGlzKTtcblx0fVxuXHRSZWFkYWJsZVN0cmVhbVN0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2h1bmtTdHJlYW1lci5wcm90b3R5cGUpO1xuXHRSZWFkYWJsZVN0cmVhbVN0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWRhYmxlU3RyZWFtU3RyZWFtZXI7XG5cblxuXHRmdW5jdGlvbiBEdXBsZXhTdHJlYW1TdHJlYW1lcihfY29uZmlnKSB7XG5cdFx0dmFyIER1cGxleCA9IHJlcXVpcmUoJ3N0cmVhbScpLkR1cGxleDtcblx0XHR2YXIgY29uZmlnID0gY29weShfY29uZmlnKTtcblx0XHR2YXIgcGFyc2VPbldyaXRlID0gdHJ1ZTtcblx0XHR2YXIgd3JpdGVTdHJlYW1IYXNGaW5pc2hlZCA9IGZhbHNlO1xuXHRcdHZhciBwYXJzZUNhbGxiYWNrUXVldWUgPSBbXTtcblx0XHR2YXIgc3RyZWFtID0gbnVsbDtcblxuXHRcdHRoaXMuX29uQ3N2RGF0YSA9IGZ1bmN0aW9uKHJlc3VsdHMpXG5cdFx0e1xuXHRcdFx0dmFyIGRhdGEgPSByZXN1bHRzLmRhdGE7XG5cdFx0XHRpZiAoIXN0cmVhbS5wdXNoKGRhdGEpICYmICF0aGlzLl9oYW5kbGUucGF1c2VkKCkpIHtcblx0XHRcdFx0Ly8gdGhlIHdyaXRlYWJsZSBjb25zdW1lciBidWZmZXIgaGFzIGZpbGxlZCB1cFxuXHRcdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIHBhdXNlIHVudGlsIG1vcmUgaXRlbXNcblx0XHRcdFx0Ly8gY2FuIGJlIHByb2Nlc3NlZFxuXHRcdFx0XHR0aGlzLl9oYW5kbGUucGF1c2UoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fb25Dc3ZDb21wbGV0ZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHQvLyBub2RlIHdpbGwgZmluaXNoIHRoZSByZWFkIHN0cmVhbSB3aGVuXG5cdFx0XHQvLyBudWxsIGlzIHB1c2hlZFxuXHRcdFx0c3RyZWFtLnB1c2gobnVsbCk7XG5cdFx0fTtcblxuXHRcdGNvbmZpZy5zdGVwID0gYmluZEZ1bmN0aW9uKHRoaXMuX29uQ3N2RGF0YSwgdGhpcyk7XG5cdFx0Y29uZmlnLmNvbXBsZXRlID0gYmluZEZ1bmN0aW9uKHRoaXMuX29uQ3N2Q29tcGxldGUsIHRoaXMpO1xuXHRcdENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdFx0dGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh3cml0ZVN0cmVhbUhhc0ZpbmlzaGVkICYmIHBhcnNlQ2FsbGJhY2tRdWV1ZS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0dGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhcnNlQ2FsbGJhY2tRdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0cGFyc2VDYWxsYmFja1F1ZXVlLnNoaWZ0KCkoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcnNlT25Xcml0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuX2FkZFRvUGFyc2VRdWV1ZSA9IGZ1bmN0aW9uKGNodW5rLCBjYWxsYmFjaylcblx0XHR7XG5cdFx0XHQvLyBhZGQgdG8gcXVldWUgc28gdGhhdCB3ZSBjYW4gaW5kaWNhdGVcblx0XHRcdC8vIGNvbXBsZXRpb24gdmlhIGNhbGxiYWNrXG5cdFx0XHQvLyBub2RlIHdpbGwgYXV0b21hdGljYWxseSBwYXVzZSB0aGUgaW5jb21pbmcgc3RyZWFtXG5cdFx0XHQvLyB3aGVuIHRvbyBtYW55IGl0ZW1zIGhhdmUgYmVlbiBhZGRlZCB3aXRob3V0IHRoZWlyXG5cdFx0XHQvLyBjYWxsYmFjayBiZWluZyBpbnZva2VkXG5cdFx0XHRwYXJzZUNhbGxiYWNrUXVldWUucHVzaChiaW5kRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGFyc2VDaHVuayh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnID8gY2h1bmsgOiBjaHVuay50b1N0cmluZyhjb25maWcuZW5jb2RpbmcpKTtcblx0XHRcdFx0aWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdGlmIChwYXJzZU9uV3JpdGUpIHtcblx0XHRcdFx0cGFyc2VPbldyaXRlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX25leHRDaHVuaygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLl9vblJlYWQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2hhbmRsZS5wYXVzZWQoKSkge1xuXHRcdFx0XHQvLyB0aGUgd3JpdGVhYmxlIGNvbnN1bWVyIGNhbiBoYW5kbGUgbW9yZSBkYXRhXG5cdFx0XHRcdC8vIHNvIHJlc3VtZSB0aGUgY2h1bmsgcGFyc2luZ1xuXHRcdFx0XHR0aGlzLl9oYW5kbGUucmVzdW1lKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuX29uV3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKVxuXHRcdHtcblx0XHRcdHRoaXMuX2FkZFRvUGFyc2VRdWV1ZShjaHVuaywgY2FsbGJhY2spO1xuXHRcdH07XG5cblx0XHR0aGlzLl9vbldyaXRlQ29tcGxldGUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0d3JpdGVTdHJlYW1IYXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0XHQvLyBoYXZlIHRvIHdyaXRlIGVtcHR5IHN0cmluZ1xuXHRcdFx0Ly8gc28gcGFyc2VyIGtub3dzIGl0cyBkb25lXG5cdFx0XHR0aGlzLl9hZGRUb1BhcnNlUXVldWUoJycpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldFN0cmVhbSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gc3RyZWFtO1xuXHRcdH07XG5cdFx0c3RyZWFtID0gbmV3IER1cGxleCh7XG5cdFx0XHRyZWFkYWJsZU9iamVjdE1vZGU6IHRydWUsXG5cdFx0XHRkZWNvZGVTdHJpbmdzOiBmYWxzZSxcblx0XHRcdHJlYWQ6IGJpbmRGdW5jdGlvbih0aGlzLl9vblJlYWQsIHRoaXMpLFxuXHRcdFx0d3JpdGU6IGJpbmRGdW5jdGlvbih0aGlzLl9vbldyaXRlLCB0aGlzKVxuXHRcdH0pO1xuXHRcdHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBiaW5kRnVuY3Rpb24odGhpcy5fb25Xcml0ZUNvbXBsZXRlLCB0aGlzKSk7XG5cdH1cblx0aWYgKHR5cGVvZiBQQVBBX0JST1dTRVJfQ09OVEVYVCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHREdXBsZXhTdHJlYW1TdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENodW5rU3RyZWFtZXIucHJvdG90eXBlKTtcblx0XHREdXBsZXhTdHJlYW1TdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEdXBsZXhTdHJlYW1TdHJlYW1lcjtcblx0fVxuXG5cblx0Ly8gVXNlIG9uZSBQYXJzZXJIYW5kbGUgcGVyIGVudGlyZSBDU1YgZmlsZSBvciBzdHJpbmdcblx0ZnVuY3Rpb24gUGFyc2VySGFuZGxlKF9jb25maWcpXG5cdHtcblx0XHQvLyBPbmUgZ29hbCBpcyB0byBtaW5pbWl6ZSB0aGUgdXNlIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMuLi5cblx0XHR2YXIgTUFYX0ZMT0FUID0gTWF0aC5wb3coMiwgNTMpO1xuXHRcdHZhciBNSU5fRkxPQVQgPSAtTUFYX0ZMT0FUO1xuXHRcdHZhciBGTE9BVCA9IC9eXFxzKi0/KFxcZCtcXC4/fFxcLlxcZCt8XFxkK1xcLlxcZCspKFtlRV1bLStdP1xcZCspP1xccyokLztcblx0XHR2YXIgSVNPX0RBVEUgPSAvXigoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGRcXC5cXGQrKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSkpJC87XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBfc3RlcENvdW50ZXIgPSAwO1x0Ly8gTnVtYmVyIG9mIHRpbWVzIHN0ZXAgd2FzIGNhbGxlZCAobnVtYmVyIG9mIHJvd3MgcGFyc2VkKVxuXHRcdHZhciBfcm93Q291bnRlciA9IDA7XHQvLyBOdW1iZXIgb2Ygcm93cyB0aGF0IGhhdmUgYmVlbiBwYXJzZWQgc28gZmFyXG5cdFx0dmFyIF9pbnB1dDtcdFx0XHRcdC8vIFRoZSBpbnB1dCBiZWluZyBwYXJzZWRcblx0XHR2YXIgX3BhcnNlcjtcdFx0XHQvLyBUaGUgY29yZSBwYXJzZXIgYmVpbmcgdXNlZFxuXHRcdHZhciBfcGF1c2VkID0gZmFsc2U7XHQvLyBXaGV0aGVyIHdlIGFyZSBwYXVzZWQgb3Igbm90XG5cdFx0dmFyIF9hYm9ydGVkID0gZmFsc2U7XHQvLyBXaGV0aGVyIHRoZSBwYXJzZXIgaGFzIGFib3J0ZWQgb3Igbm90XG5cdFx0dmFyIF9kZWxpbWl0ZXJFcnJvcjtcdC8vIFRlbXBvcmFyeSBzdGF0ZSBiZXR3ZWVuIGRlbGltaXRlciBkZXRlY3Rpb24gYW5kIHByb2Nlc3NpbmcgcmVzdWx0c1xuXHRcdHZhciBfZmllbGRzID0gW107XHRcdC8vIEZpZWxkcyBhcmUgZnJvbSB0aGUgaGVhZGVyIHJvdyBvZiB0aGUgaW5wdXQsIGlmIHRoZXJlIGlzIG9uZVxuXHRcdHZhciBfcmVzdWx0cyA9IHtcdFx0Ly8gVGhlIGxhc3QgcmVzdWx0cyByZXR1cm5lZCBmcm9tIHRoZSBwYXJzZXJcblx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdG1ldGE6IHt9XG5cdFx0fTtcblxuXHRcdGlmIChpc0Z1bmN0aW9uKF9jb25maWcuc3RlcCkpXG5cdFx0e1xuXHRcdFx0dmFyIHVzZXJTdGVwID0gX2NvbmZpZy5zdGVwO1xuXHRcdFx0X2NvbmZpZy5zdGVwID0gZnVuY3Rpb24ocmVzdWx0cylcblx0XHRcdHtcblx0XHRcdFx0X3Jlc3VsdHMgPSByZXN1bHRzO1xuXG5cdFx0XHRcdGlmIChuZWVkc0hlYWRlclJvdygpKVxuXHRcdFx0XHRcdHByb2Nlc3NSZXN1bHRzKCk7XG5cdFx0XHRcdGVsc2VcdC8vIG9ubHkgY2FsbCB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhZnRlciBoZWFkZXIgcm93XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwcm9jZXNzUmVzdWx0cygpO1xuXG5cdFx0XHRcdFx0Ly8gSXQncyBwb3NzYmlsZSB0aGF0IHRoaXMgbGluZSB3YXMgZW1wdHkgYW5kIHRoZXJlJ3Mgbm8gcm93IGhlcmUgYWZ0ZXIgYWxsXG5cdFx0XHRcdFx0aWYgKF9yZXN1bHRzLmRhdGEubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0X3N0ZXBDb3VudGVyICs9IHJlc3VsdHMuZGF0YS5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKF9jb25maWcucHJldmlldyAmJiBfc3RlcENvdW50ZXIgPiBfY29uZmlnLnByZXZpZXcpXG5cdFx0XHRcdFx0XHRfcGFyc2VyLmFib3J0KCk7XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhID0gX3Jlc3VsdHMuZGF0YVswXTtcblx0XHRcdFx0XHRcdHVzZXJTdGVwKF9yZXN1bHRzLCBzZWxmKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUGFyc2VzIGlucHV0LiBNb3N0IHVzZXJzIHdvbid0IG5lZWQsIGFuZCBzaG91bGRuJ3QgbWVzcyB3aXRoLCB0aGUgYmFzZUluZGV4XG5cdFx0ICogYW5kIGlnbm9yZUxhc3RSb3cgcGFyYW1ldGVycy4gVGhleSBhcmUgdXNlZCBieSBzdHJlYW1lcnMgKHdyYXBwZXIgZnVuY3Rpb25zKVxuXHRcdCAqIHdoZW4gYW4gaW5wdXQgY29tZXMgaW4gbXVsdGlwbGUgY2h1bmtzLCBsaWtlIGZyb20gYSBmaWxlLlxuXHRcdCAqL1xuXHRcdHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KVxuXHRcdHtcblx0XHRcdHZhciBxdW90ZUNoYXIgPSBfY29uZmlnLnF1b3RlQ2hhciB8fCAnXCInO1xuXHRcdFx0aWYgKCFfY29uZmlnLm5ld2xpbmUpXG5cdFx0XHRcdF9jb25maWcubmV3bGluZSA9IGd1ZXNzTGluZUVuZGluZ3MoaW5wdXQsIHF1b3RlQ2hhcik7XG5cblx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0aWYgKCFfY29uZmlnLmRlbGltaXRlcilcblx0XHRcdHtcblx0XHRcdFx0dmFyIGRlbGltR3Vlc3MgPSBndWVzc0RlbGltaXRlcihpbnB1dCwgX2NvbmZpZy5uZXdsaW5lLCBfY29uZmlnLnNraXBFbXB0eUxpbmVzLCBfY29uZmlnLmNvbW1lbnRzLCBfY29uZmlnLmRlbGltaXRlcnNUb0d1ZXNzKTtcblx0XHRcdFx0aWYgKGRlbGltR3Vlc3Muc3VjY2Vzc2Z1bClcblx0XHRcdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IGRlbGltR3Vlc3MuYmVzdERlbGltaXRlcjtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2RlbGltaXRlckVycm9yID0gdHJ1ZTtcdC8vIGFkZCBlcnJvciBhZnRlciBwYXJzaW5nIChvdGhlcndpc2UgaXQgd291bGQgYmUgb3ZlcndyaXR0ZW4pXG5cdFx0XHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBQYXBhLkRlZmF1bHREZWxpbWl0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoaXNGdW5jdGlvbihfY29uZmlnLmRlbGltaXRlcikpXG5cdFx0XHR7XG5cdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXIoaW5wdXQpO1xuXHRcdFx0XHRfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyc2VyQ29uZmlnID0gY29weShfY29uZmlnKTtcblx0XHRcdGlmIChfY29uZmlnLnByZXZpZXcgJiYgX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdHBhcnNlckNvbmZpZy5wcmV2aWV3Kys7XHQvLyB0byBjb21wZW5zYXRlIGZvciBoZWFkZXIgcm93XG5cblx0XHRcdF9pbnB1dCA9IGlucHV0O1xuXHRcdFx0X3BhcnNlciA9IG5ldyBQYXJzZXIocGFyc2VyQ29uZmlnKTtcblx0XHRcdF9yZXN1bHRzID0gX3BhcnNlci5wYXJzZShfaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdyk7XG5cdFx0XHRwcm9jZXNzUmVzdWx0cygpO1xuXHRcdFx0cmV0dXJuIF9wYXVzZWQgPyB7IG1ldGE6IHsgcGF1c2VkOiB0cnVlIH0gfSA6IChfcmVzdWx0cyB8fCB7IG1ldGE6IHsgcGF1c2VkOiBmYWxzZSB9IH0pO1xuXHRcdH07XG5cblx0XHR0aGlzLnBhdXNlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX3BhdXNlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5wYXVzZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfcGF1c2VkID0gdHJ1ZTtcblx0XHRcdF9wYXJzZXIuYWJvcnQoKTtcblxuXHRcdFx0Ly8gSWYgaXQgaXMgc3RyZWFtaW5nIHZpYSBcImNodW5raW5nXCIsIHRoZSByZWFkZXIgd2lsbCBzdGFydCBhcHBlbmRpbmcgY29ycmVjdGx5IGFscmVhZHkgc28gbm8gbmVlZCB0byBzdWJzdHJpbmcsXG5cdFx0XHQvLyBvdGhlcndpc2Ugd2UgY2FuIGdldCBkdXBsaWNhdGUgY29udGVudCB3aXRoaW4gYSByb3dcblx0XHRcdF9pbnB1dCA9IGlzRnVuY3Rpb24oX2NvbmZpZy5jaHVuaykgPyBcIlwiIDogX2lucHV0LnN1YnN0cmluZyhfcGFyc2VyLmdldENoYXJJbmRleCgpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYoc2VsZi5zdHJlYW1lci5faGFsdGVkKSB7XG5cdFx0XHRcdF9wYXVzZWQgPSBmYWxzZTtcblx0XHRcdFx0c2VsZi5zdHJlYW1lci5wYXJzZUNodW5rKF9pbnB1dCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBCdWdmaXg6ICM2MzYgSW4gY2FzZSB0aGUgcHJvY2Vzc2luZyBoYXNuJ3QgaGFsdGVkIHlldFxuXHRcdFx0XHQvLyB3YWl0IGZvciBpdCB0byBoYWx0IGluIG9yZGVyIHRvIHJlc3VtZVxuXHRcdFx0XHRzZXRUaW1lb3V0KHNlbGYucmVzdW1lLCAzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5hYm9ydGVkID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBfYWJvcnRlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5hYm9ydCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfYWJvcnRlZCA9IHRydWU7XG5cdFx0XHRfcGFyc2VyLmFib3J0KCk7XG5cdFx0XHRfcmVzdWx0cy5tZXRhLmFib3J0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5jb21wbGV0ZSkpXG5cdFx0XHRcdF9jb25maWcuY29tcGxldGUoX3Jlc3VsdHMpO1xuXHRcdFx0X2lucHV0ID0gJyc7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRlc3RFbXB0eUxpbmUocykge1xuXHRcdFx0cmV0dXJuIF9jb25maWcuc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknID8gcy5qb2luKCcnKS50cmltKCkgPT09ICcnIDogcy5sZW5ndGggPT09IDEgJiYgc1swXS5sZW5ndGggPT09IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGVzdEZsb2F0KHMpIHtcblx0XHRcdGlmIChGTE9BVC50ZXN0KHMpKSB7XG5cdFx0XHRcdHZhciBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChzKTtcblx0XHRcdFx0aWYgKGZsb2F0VmFsdWUgPiBNSU5fRkxPQVQgJiYgZmxvYXRWYWx1ZSA8IE1BWF9GTE9BVCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdHMoKVxuXHRcdHtcblx0XHRcdGlmIChfcmVzdWx0cyAmJiBfZGVsaW1pdGVyRXJyb3IpXG5cdFx0XHR7XG5cdFx0XHRcdGFkZEVycm9yKCdEZWxpbWl0ZXInLCAnVW5kZXRlY3RhYmxlRGVsaW1pdGVyJywgJ1VuYWJsZSB0byBhdXRvLWRldGVjdCBkZWxpbWl0aW5nIGNoYXJhY3RlcjsgZGVmYXVsdGVkIHRvIFxcJycgKyBQYXBhLkRlZmF1bHREZWxpbWl0ZXIgKyAnXFwnJyk7XG5cdFx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2NvbmZpZy5za2lwRW1wdHlMaW5lcylcblx0XHRcdHtcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YSA9IF9yZXN1bHRzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRyZXR1cm4gIXRlc3RFbXB0eUxpbmUoZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVlZHNIZWFkZXJSb3coKSlcblx0XHRcdFx0ZmlsbEhlYWRlckZpZWxkcygpO1xuXG5cdFx0XHRyZXR1cm4gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24oKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZWVkc0hlYWRlclJvdygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9jb25maWcuaGVhZGVyICYmIF9maWVsZHMubGVuZ3RoID09PSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbGxIZWFkZXJGaWVsZHMoKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0ZnVuY3Rpb24gYWRkSGVhZGVyKGhlYWRlciwgaSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy50cmFuc2Zvcm1IZWFkZXIpKVxuXHRcdFx0XHRcdGhlYWRlciA9IF9jb25maWcudHJhbnNmb3JtSGVhZGVyKGhlYWRlciwgaSk7XG5cblx0XHRcdFx0X2ZpZWxkcy5wdXNoKGhlYWRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KF9yZXN1bHRzLmRhdGFbMF0pKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgbmVlZHNIZWFkZXJSb3coKSAmJiBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldLmZvckVhY2goYWRkSGVhZGVyKTtcblxuXHRcdFx0XHRfcmVzdWx0cy5kYXRhLnNwbGljZSgwLCAxKTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIF9yZXN1bHRzLmRhdGFbMF0gaXMgbm90IGFuIGFycmF5LCB3ZSBhcmUgaW4gYSBzdGVwIHdoZXJlIF9yZXN1bHRzLmRhdGEgaXMgdGhlIHJvdy5cblx0XHRcdGVsc2Vcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YS5mb3JFYWNoKGFkZEhlYWRlcik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2hvdWxkQXBwbHlEeW5hbWljVHlwaW5nKGZpZWxkKSB7XG5cdFx0XHQvLyBDYWNoZSBmdW5jdGlvbiB2YWx1ZXMgdG8gYXZvaWQgY2FsbGluZyBpdCBmb3IgZWFjaCByb3dcblx0XHRcdGlmIChfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiAmJiBfY29uZmlnLmR5bmFtaWNUeXBpbmdbZmllbGRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0X2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSA9IF9jb25maWcuZHluYW1pY1R5cGluZ0Z1bmN0aW9uKGZpZWxkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoX2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSB8fCBfY29uZmlnLmR5bmFtaWNUeXBpbmcpID09PSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRHluYW1pYyhmaWVsZCwgdmFsdWUpXG5cdFx0e1xuXHRcdFx0aWYgKHNob3VsZEFwcGx5RHluYW1pY1R5cGluZyhmaWVsZCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnVFJVRScpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAnRkFMU0UnKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0ZWxzZSBpZiAodGVzdEZsb2F0KHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdFx0XHRcdGVsc2UgaWYgKElTT19EQVRFLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gKHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24oKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMgfHwgKCFfY29uZmlnLmhlYWRlciAmJiAhX2NvbmZpZy5keW5hbWljVHlwaW5nICYmICFfY29uZmlnLnRyYW5zZm9ybSkpXG5cdFx0XHRcdHJldHVybiBfcmVzdWx0cztcblxuXHRcdFx0ZnVuY3Rpb24gcHJvY2Vzc1Jvdyhyb3dTb3VyY2UsIGkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByb3cgPSBfY29uZmlnLmhlYWRlciA/IHt9IDogW107XG5cblx0XHRcdFx0dmFyIGo7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCByb3dTb3VyY2UubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZmllbGQgPSBqO1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHJvd1NvdXJjZVtqXTtcblxuXHRcdFx0XHRcdGlmIChfY29uZmlnLmhlYWRlcilcblx0XHRcdFx0XHRcdGZpZWxkID0gaiA+PSBfZmllbGRzLmxlbmd0aCA/ICdfX3BhcnNlZF9leHRyYScgOiBfZmllbGRzW2pdO1xuXG5cdFx0XHRcdFx0aWYgKF9jb25maWcudHJhbnNmb3JtKVxuXHRcdFx0XHRcdFx0dmFsdWUgPSBfY29uZmlnLnRyYW5zZm9ybSh2YWx1ZSxmaWVsZCk7XG5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlRHluYW1pYyhmaWVsZCwgdmFsdWUpO1xuXG5cdFx0XHRcdFx0aWYgKGZpZWxkID09PSAnX19wYXJzZWRfZXh0cmEnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJvd1tmaWVsZF0gPSByb3dbZmllbGRdIHx8IFtdO1xuXHRcdFx0XHRcdFx0cm93W2ZpZWxkXS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cm93W2ZpZWxkXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaiA+IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoJ0ZpZWxkTWlzbWF0Y2gnLCAnVG9vTWFueUZpZWxkcycsICdUb28gbWFueSBmaWVsZHM6IGV4cGVjdGVkICcgKyBfZmllbGRzLmxlbmd0aCArICcgZmllbGRzIGJ1dCBwYXJzZWQgJyArIGosIF9yb3dDb3VudGVyICsgaSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaiA8IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoJ0ZpZWxkTWlzbWF0Y2gnLCAnVG9vRmV3RmllbGRzJywgJ1RvbyBmZXcgZmllbGRzOiBleHBlY3RlZCAnICsgX2ZpZWxkcy5sZW5ndGggKyAnIGZpZWxkcyBidXQgcGFyc2VkICcgKyBqLCBfcm93Q291bnRlciArIGkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJvdztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluY3JlbWVudEJ5ID0gMTtcblx0XHRcdGlmICghX3Jlc3VsdHMuZGF0YS5sZW5ndGggfHwgQXJyYXkuaXNBcnJheShfcmVzdWx0cy5kYXRhWzBdKSlcblx0XHRcdHtcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YSA9IF9yZXN1bHRzLmRhdGEubWFwKHByb2Nlc3NSb3cpO1xuXHRcdFx0XHRpbmNyZW1lbnRCeSA9IF9yZXN1bHRzLmRhdGEubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfcmVzdWx0cy5kYXRhID0gcHJvY2Vzc1JvdyhfcmVzdWx0cy5kYXRhLCAwKTtcblxuXG5cdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIgJiYgX3Jlc3VsdHMubWV0YSlcblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5maWVsZHMgPSBfZmllbGRzO1xuXG5cdFx0XHRfcm93Q291bnRlciArPSBpbmNyZW1lbnRCeTtcblx0XHRcdHJldHVybiBfcmVzdWx0cztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBndWVzc0RlbGltaXRlcihpbnB1dCwgbmV3bGluZSwgc2tpcEVtcHR5TGluZXMsIGNvbW1lbnRzLCBkZWxpbWl0ZXJzVG9HdWVzcykge1xuXHRcdFx0dmFyIGJlc3REZWxpbSwgYmVzdERlbHRhLCBmaWVsZENvdW50UHJldlJvdywgbWF4RmllbGRDb3VudDtcblxuXHRcdFx0ZGVsaW1pdGVyc1RvR3Vlc3MgPSBkZWxpbWl0ZXJzVG9HdWVzcyB8fCBbJywnLCAnXFx0JywgJ3wnLCAnOycsIFBhcGEuUkVDT1JEX1NFUCwgUGFwYS5VTklUX1NFUF07XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVsaW1pdGVyc1RvR3Vlc3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGRlbGltID0gZGVsaW1pdGVyc1RvR3Vlc3NbaV07XG5cdFx0XHRcdHZhciBkZWx0YSA9IDAsIGF2Z0ZpZWxkQ291bnQgPSAwLCBlbXB0eUxpbmVzQ291bnQgPSAwO1xuXHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR2YXIgcHJldmlldyA9IG5ldyBQYXJzZXIoe1xuXHRcdFx0XHRcdGNvbW1lbnRzOiBjb21tZW50cyxcblx0XHRcdFx0XHRkZWxpbWl0ZXI6IGRlbGltLFxuXHRcdFx0XHRcdG5ld2xpbmU6IG5ld2xpbmUsXG5cdFx0XHRcdFx0cHJldmlldzogMTBcblx0XHRcdFx0fSkucGFyc2UoaW5wdXQpO1xuXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcHJldmlldy5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKHNraXBFbXB0eUxpbmVzICYmIHRlc3RFbXB0eUxpbmUocHJldmlldy5kYXRhW2pdKSkge1xuXHRcdFx0XHRcdFx0ZW1wdHlMaW5lc0NvdW50Kys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGZpZWxkQ291bnQgPSBwcmV2aWV3LmRhdGFbal0ubGVuZ3RoO1xuXHRcdFx0XHRcdGF2Z0ZpZWxkQ291bnQgKz0gZmllbGRDb3VudDtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZmllbGRDb3VudFByZXZSb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZmllbGRDb3VudCA+IDApIHtcblx0XHRcdFx0XHRcdGRlbHRhICs9IE1hdGguYWJzKGZpZWxkQ291bnQgLSBmaWVsZENvdW50UHJldlJvdyk7XG5cdFx0XHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByZXZpZXcuZGF0YS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGF2Z0ZpZWxkQ291bnQgLz0gKHByZXZpZXcuZGF0YS5sZW5ndGggLSBlbXB0eUxpbmVzQ291bnQpO1xuXG5cdFx0XHRcdGlmICgodHlwZW9mIGJlc3REZWx0YSA9PT0gJ3VuZGVmaW5lZCcgfHwgZGVsdGEgPD0gYmVzdERlbHRhKVxuXHRcdFx0XHRcdCYmICh0eXBlb2YgbWF4RmllbGRDb3VudCA9PT0gJ3VuZGVmaW5lZCcgfHwgYXZnRmllbGRDb3VudCA+IG1heEZpZWxkQ291bnQpICYmIGF2Z0ZpZWxkQ291bnQgPiAxLjk5KSB7XG5cdFx0XHRcdFx0YmVzdERlbHRhID0gZGVsdGE7XG5cdFx0XHRcdFx0YmVzdERlbGltID0gZGVsaW07XG5cdFx0XHRcdFx0bWF4RmllbGRDb3VudCA9IGF2Z0ZpZWxkQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBiZXN0RGVsaW07XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3NmdWw6ICEhYmVzdERlbGltLFxuXHRcdFx0XHRiZXN0RGVsaW1pdGVyOiBiZXN0RGVsaW1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ3Vlc3NMaW5lRW5kaW5ncyhpbnB1dCwgcXVvdGVDaGFyKVxuXHRcdHtcblx0XHRcdGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIDEwMjQgKiAxMDI0KTtcdC8vIG1heCBsZW5ndGggMSBNQlxuXHRcdFx0Ly8gUmVwbGFjZSBhbGwgdGhlIHRleHQgaW5zaWRlIHF1b3Rlc1xuXHRcdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAocXVvdGVDaGFyKSArICcoW15dKj8pJyArIGVzY2FwZVJlZ0V4cChxdW90ZUNoYXIpLCAnZ20nKTtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShyZSwgJycpO1xuXG5cdFx0XHR2YXIgciA9IGlucHV0LnNwbGl0KCdcXHInKTtcblxuXHRcdFx0dmFyIG4gPSBpbnB1dC5zcGxpdCgnXFxuJyk7XG5cblx0XHRcdHZhciBuQXBwZWFyc0ZpcnN0ID0gKG4ubGVuZ3RoID4gMSAmJiBuWzBdLmxlbmd0aCA8IHJbMF0ubGVuZ3RoKTtcblxuXHRcdFx0aWYgKHIubGVuZ3RoID09PSAxIHx8IG5BcHBlYXJzRmlyc3QpXG5cdFx0XHRcdHJldHVybiAnXFxuJztcblxuXHRcdFx0dmFyIG51bVdpdGhOID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHJbaV1bMF0gPT09ICdcXG4nKVxuXHRcdFx0XHRcdG51bVdpdGhOKys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudW1XaXRoTiA+PSByLmxlbmd0aCAvIDIgPyAnXFxyXFxuJyA6ICdcXHInO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEVycm9yKHR5cGUsIGNvZGUsIG1zZywgcm93KVxuXHRcdHtcblx0XHRcdHZhciBlcnJvciA9IHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Y29kZTogY29kZSxcblx0XHRcdFx0bWVzc2FnZTogbXNnXG5cdFx0XHR9O1xuXHRcdFx0aWYocm93ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZXJyb3Iucm93ID0gcm93O1xuXHRcdFx0fVxuXHRcdFx0X3Jlc3VsdHMuZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMgKi9cblx0ZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZylcblx0e1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG5cdH1cblxuXHQvKiogVGhlIGNvcmUgcGFyc2VyIGltcGxlbWVudHMgc3BlZWR5IGFuZCBjb3JyZWN0IENTViBwYXJzaW5nICovXG5cdGZ1bmN0aW9uIFBhcnNlcihjb25maWcpXG5cdHtcblx0XHQvLyBVbnBhY2sgdGhlIGNvbmZpZyBvYmplY3Rcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0dmFyIGRlbGltID0gY29uZmlnLmRlbGltaXRlcjtcblx0XHR2YXIgbmV3bGluZSA9IGNvbmZpZy5uZXdsaW5lO1xuXHRcdHZhciBjb21tZW50cyA9IGNvbmZpZy5jb21tZW50cztcblx0XHR2YXIgc3RlcCA9IGNvbmZpZy5zdGVwO1xuXHRcdHZhciBwcmV2aWV3ID0gY29uZmlnLnByZXZpZXc7XG5cdFx0dmFyIGZhc3RNb2RlID0gY29uZmlnLmZhc3RNb2RlO1xuXHRcdHZhciBxdW90ZUNoYXI7XG5cdFx0aWYgKGNvbmZpZy5xdW90ZUNoYXIgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucXVvdGVDaGFyID09PSBudWxsKSB7XG5cdFx0XHRxdW90ZUNoYXIgPSAnXCInO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxdW90ZUNoYXIgPSBjb25maWcucXVvdGVDaGFyO1xuXHRcdH1cblx0XHR2YXIgZXNjYXBlQ2hhciA9IHF1b3RlQ2hhcjtcblx0XHRpZiAoY29uZmlnLmVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZXNjYXBlQ2hhciA9IGNvbmZpZy5lc2NhcGVDaGFyO1xuXHRcdH1cblxuXHRcdC8vIERlbGltaXRlciBtdXN0IGJlIHZhbGlkXG5cdFx0aWYgKHR5cGVvZiBkZWxpbSAhPT0gJ3N0cmluZydcblx0XHRcdHx8IFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihkZWxpbSkgPiAtMSlcblx0XHRcdGRlbGltID0gJywnO1xuXG5cdFx0Ly8gQ29tbWVudCBjaGFyYWN0ZXIgbXVzdCBiZSB2YWxpZFxuXHRcdGlmIChjb21tZW50cyA9PT0gZGVsaW0pXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvbW1lbnQgY2hhcmFjdGVyIHNhbWUgYXMgZGVsaW1pdGVyJyk7XG5cdFx0ZWxzZSBpZiAoY29tbWVudHMgPT09IHRydWUpXG5cdFx0XHRjb21tZW50cyA9ICcjJztcblx0XHRlbHNlIGlmICh0eXBlb2YgY29tbWVudHMgIT09ICdzdHJpbmcnXG5cdFx0XHR8fCBQYXBhLkJBRF9ERUxJTUlURVJTLmluZGV4T2YoY29tbWVudHMpID4gLTEpXG5cdFx0XHRjb21tZW50cyA9IGZhbHNlO1xuXG5cdFx0Ly8gTmV3bGluZSBtdXN0IGJlIHZhbGlkOiBcXHIsIFxcbiwgb3IgXFxyXFxuXG5cdFx0aWYgKG5ld2xpbmUgIT09ICdcXG4nICYmIG5ld2xpbmUgIT09ICdcXHInICYmIG5ld2xpbmUgIT09ICdcXHJcXG4nKVxuXHRcdFx0bmV3bGluZSA9ICdcXG4nO1xuXG5cdFx0Ly8gV2UncmUgZ29ubmEgbmVlZCB0aGVzZSBhdCB0aGUgUGFyc2VyIHNjb3BlXG5cdFx0dmFyIGN1cnNvciA9IDA7XG5cdFx0dmFyIGFib3J0ZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KVxuXHRcdHtcblx0XHRcdC8vIEZvciBzb21lIHJlYXNvbiwgaW4gQ2hyb21lLCB0aGlzIHNwZWVkcyB0aGluZ3MgdXAgKCE/KVxuXHRcdFx0aWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0XHQvLyBXZSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgc29tZSBvZiB0aGVzZSBldmVyeSB0aW1lIHBhcnNlKCkgaXMgY2FsbGVkLFxuXHRcdFx0Ly8gYnV0IGhhdmluZyB0aGVtIGluIGEgbW9yZSBsb2NhbCBzY29wZSBzZWVtcyB0byBwZXJmb3JtIGJldHRlclxuXHRcdFx0dmFyIGlucHV0TGVuID0gaW5wdXQubGVuZ3RoLFxuXHRcdFx0XHRkZWxpbUxlbiA9IGRlbGltLmxlbmd0aCxcblx0XHRcdFx0bmV3bGluZUxlbiA9IG5ld2xpbmUubGVuZ3RoLFxuXHRcdFx0XHRjb21tZW50c0xlbiA9IGNvbW1lbnRzLmxlbmd0aDtcblx0XHRcdHZhciBzdGVwSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oc3RlcCk7XG5cblx0XHRcdC8vIEVzdGFibGlzaCBzdGFydGluZyBzdGF0ZVxuXHRcdFx0Y3Vyc29yID0gMDtcblx0XHRcdHZhciBkYXRhID0gW10sIGVycm9ycyA9IFtdLCByb3cgPSBbXSwgbGFzdEN1cnNvciA9IDA7XG5cblx0XHRcdGlmICghaW5wdXQpXG5cdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cblx0XHRcdC8vIFJlbmFtZSBoZWFkZXJzIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoY29uZmlnLmhlYWRlciAmJiAhYmFzZUluZGV4KVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZmlyc3RMaW5lID0gaW5wdXQuc3BsaXQobmV3bGluZSlbMF07XG5cdFx0XHRcdHZhciBoZWFkZXJzID0gZmlyc3RMaW5lLnNwbGl0KGRlbGltKTtcblx0XHRcdFx0dmFyIHNlcGFyYXRvciA9ICdfJztcblx0XHRcdFx0dmFyIGhlYWRlck1hcCA9IFtdO1xuXHRcdFx0XHR2YXIgaGVhZGVyQ291bnQgPSB7fTtcblx0XHRcdFx0dmFyIGR1cGxpY2F0ZUhlYWRlcnMgPSBmYWxzZTtcblxuXHRcdFx0XHRmb3IgKHZhciBqIGluIGhlYWRlcnMpIHtcblx0XHRcdFx0XHR2YXIgaGVhZGVyID0gaGVhZGVyc1tqXTtcblx0XHRcdFx0XHRpZiAoaXNGdW5jdGlvbihjb25maWcudHJhbnNmb3JtSGVhZGVyKSlcblx0XHRcdFx0XHRcdGhlYWRlciA9IGNvbmZpZy50cmFuc2Zvcm1IZWFkZXIoaGVhZGVyLCBqKTtcblx0XHRcdFx0XHR2YXIgaGVhZGVyTmFtZSA9IGhlYWRlcjtcblxuXHRcdFx0XHRcdHZhciBjb3VudCA9IGhlYWRlckNvdW50W2hlYWRlcl0gfHwgMDtcblx0XHRcdFx0XHRpZiAoY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRkdXBsaWNhdGVIZWFkZXJzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGhlYWRlck5hbWUgPSBoZWFkZXIgKyBzZXBhcmF0b3IgKyBjb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aGVhZGVyQ291bnRbaGVhZGVyXSA9IGNvdW50ICsgMTtcblx0XHRcdFx0XHQvLyBJbiBjYXNlIGl0IGFscmVhZHkgZXhpc3RzLCB3ZSBhZGQgbW9yZSBzZXBhcnRvcnNcblx0XHRcdFx0XHR3aGlsZSAoaGVhZGVyTWFwLmluY2x1ZGVzKGhlYWRlck5hbWUpKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJOYW1lID0gaGVhZGVyTmFtZSArIHNlcGFyYXRvciArIGNvdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRoZWFkZXJNYXAucHVzaChoZWFkZXJOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVwbGljYXRlSGVhZGVycykge1xuXHRcdFx0XHRcdHZhciBlZGl0ZWRJbnB1dCA9IGlucHV0LnNwbGl0KG5ld2xpbmUpO1xuXHRcdFx0XHRcdGVkaXRlZElucHV0WzBdID0gaGVhZGVyTWFwLmpvaW4oZGVsaW0pO1xuXHRcdFx0XHRcdGlucHV0ID0gZWRpdGVkSW5wdXQuam9pbihuZXdsaW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGZhc3RNb2RlIHx8IChmYXN0TW9kZSAhPT0gZmFsc2UgJiYgaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIpID09PSAtMSkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByb3dzID0gaW5wdXQuc3BsaXQobmV3bGluZSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cdFx0XHRcdFx0Y3Vyc29yICs9IHJvdy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGkgIT09IHJvd3MubGVuZ3RoIC0gMSlcblx0XHRcdFx0XHRcdGN1cnNvciArPSBuZXdsaW5lLmxlbmd0aDtcblx0XHRcdFx0XHRlbHNlIGlmIChpZ25vcmVMYXN0Um93KVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRpZiAoY29tbWVudHMgJiYgcm93LnN1YnN0cmluZygwLCBjb21tZW50c0xlbikgPT09IGNvbW1lbnRzKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0XHRcdHB1c2hSb3cocm93LnNwbGl0KGRlbGltKSk7XG5cdFx0XHRcdFx0XHRkb1N0ZXAoKTtcblx0XHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRwdXNoUm93KHJvdy5zcGxpdChkZWxpbSkpO1xuXHRcdFx0XHRcdGlmIChwcmV2aWV3ICYmIGkgPj0gcHJldmlldylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YS5zbGljZSgwLCBwcmV2aWV3KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdHZhciBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdHZhciBxdW90ZUNoYXJSZWdleCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGVzY2FwZUNoYXIpICsgZXNjYXBlUmVnRXhwKHF1b3RlQ2hhciksICdnJyk7XG5cdFx0XHR2YXIgcXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgY3Vyc29yKTtcblxuXHRcdFx0Ly8gUGFyc2VyIGxvb3Bcblx0XHRcdGZvciAoOzspXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEZpZWxkIGhhcyBvcGVuaW5nIHF1b3RlXG5cdFx0XHRcdGlmIChpbnB1dFtjdXJzb3JdID09PSBxdW90ZUNoYXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBTdGFydCBvdXIgc2VhcmNoIGZvciB0aGUgY2xvc2luZyBxdW90ZSB3aGVyZSB0aGUgY3Vyc29yIGlzXG5cdFx0XHRcdFx0cXVvdGVTZWFyY2ggPSBjdXJzb3I7XG5cblx0XHRcdFx0XHQvLyBTa2lwIHRoZSBvcGVuaW5nIHF1b3RlXG5cdFx0XHRcdFx0Y3Vyc29yKys7XG5cblx0XHRcdFx0XHRmb3IgKDs7KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIEZpbmQgY2xvc2luZyBxdW90ZVxuXHRcdFx0XHRcdFx0cXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgcXVvdGVTZWFyY2ggKyAxKTtcblxuXHRcdFx0XHRcdFx0Ly9ObyBvdGhlciBxdW90ZXMgYXJlIGZvdW5kIC0gbm8gb3RoZXIgZGVsaW1pdGVyc1xuXHRcdFx0XHRcdFx0aWYgKHF1b3RlU2VhcmNoID09PSAtMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCFpZ25vcmVMYXN0Um93KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm8gY2xvc2luZyBxdW90ZS4uLiB3aGF0IGEgcGl0eVxuXHRcdFx0XHRcdFx0XHRcdGVycm9ycy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29kZTogJ01pc3NpbmdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ1F1b3RlZCBmaWVsZCB1bnRlcm1pbmF0ZWQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm93OiBkYXRhLmxlbmd0aCxcdC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleDogY3Vyc29yXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZpbmlzaCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHF1b3RlIGF0IEVPRlxuXHRcdFx0XHRcdFx0aWYgKHF1b3RlU2VhcmNoID09PSBpbnB1dExlbiAtIDEpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmluaXNoKHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBxdW90ZSBpcyBlc2NhcGVkLCBpdCdzIHBhcnQgb2YgdGhlIGRhdGE7IHNraXAgaXRcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBxdW90ZSBjaGFyYWN0ZXIgaXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXIsIHRoZW4gY2hlY2sgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG5cdFx0XHRcdFx0XHRpZiAocXVvdGVDaGFyID09PSBlc2NhcGVDaGFyICYmICBpbnB1dFtxdW90ZVNlYXJjaCArIDFdID09PSBlc2NhcGVDaGFyKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRxdW90ZVNlYXJjaCsrO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHF1b3RlIGNoYXJhY3RlciBpcyBub3QgdGhlIGVzY2FwZSBjaGFyYWN0ZXIsIHRoZW4gY2hlY2sgaWYgdGhlIHByZXZpb3VzIGNoYXJhY3RlciB3YXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHRcdGlmIChxdW90ZUNoYXIgIT09IGVzY2FwZUNoYXIgJiYgcXVvdGVTZWFyY2ggIT09IDAgJiYgaW5wdXRbcXVvdGVTZWFyY2ggLSAxXSA9PT0gZXNjYXBlQ2hhcilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmKG5leHREZWxpbSAhPT0gLTEgJiYgbmV4dERlbGltIDwgKHF1b3RlU2VhcmNoICsgMSkpIHtcblx0XHRcdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgKHF1b3RlU2VhcmNoICsgMSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYobmV4dE5ld2xpbmUgIT09IC0xICYmIG5leHROZXdsaW5lIDwgKHF1b3RlU2VhcmNoICsgMSkpIHtcblx0XHRcdFx0XHRcdFx0bmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIChxdW90ZVNlYXJjaCArIDEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENoZWNrIHVwIHRvIG5leHREZWxpbSBvciBuZXh0TmV3bGluZSwgd2hpY2hldmVyIGlzIGNsb3Nlc3Rcblx0XHRcdFx0XHRcdHZhciBjaGVja1VwVG8gPSBuZXh0TmV3bGluZSA9PT0gLTEgPyBuZXh0RGVsaW0gOiBNYXRoLm1pbihuZXh0RGVsaW0sIG5leHROZXdsaW5lKTtcblx0XHRcdFx0XHRcdHZhciBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgPSBleHRyYVNwYWNlcyhjaGVja1VwVG8pO1xuXG5cdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHF1b3RlIGZvbGxvd2VkIGJ5IGRlbGltaXRlciBvciAndW5uZWNlc3Nhcnkgc3BhY2VzICsgZGVsaW1pdGVyJ1xuXHRcdFx0XHRcdFx0aWYgKGlucHV0LnN1YnN0cihxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIsIGRlbGltTGVuKSA9PT0gZGVsaW0pXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpKTtcblx0XHRcdFx0XHRcdFx0Y3Vyc29yID0gcXVvdGVTZWFyY2ggKyAxICsgc3BhY2VzQmV0d2VlblF1b3RlQW5kRGVsaW1pdGVyICsgZGVsaW1MZW47XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgY2hhciBhZnRlciBmb2xsb3dpbmcgZGVsaW1pdGVyIGlzIG5vdCBxdW90ZUNoYXIsIHdlIGZpbmQgbmV4dCBxdW90ZSBjaGFyIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdGlmIChpbnB1dFtxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgKyBkZWxpbUxlbl0gIT09IHF1b3RlQ2hhcilcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHF1b3RlU2VhcmNoID0gaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIsIGN1cnNvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRcdFx0bmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgc3BhY2VzQmV0d2VlblF1b3RlQW5kTmV3TGluZSA9IGV4dHJhU3BhY2VzKG5leHROZXdsaW5lKTtcblxuXHRcdFx0XHRcdFx0Ly8gQ2xvc2luZyBxdW90ZSBmb2xsb3dlZCBieSBuZXdsaW5lIG9yICd1bm5lY2Vzc2FyeSBzcGFjZXMgKyBuZXdMaW5lJ1xuXHRcdFx0XHRcdFx0aWYgKGlucHV0LnN1YnN0cmluZyhxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lLCBxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lICsgbmV3bGluZUxlbikgPT09IG5ld2xpbmUpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpKTtcblx0XHRcdFx0XHRcdFx0c2F2ZVJvdyhxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lICsgbmV3bGluZUxlbik7XG5cdFx0XHRcdFx0XHRcdG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XHQvLyBiZWNhdXNlIHdlIG1heSBoYXZlIHNraXBwZWQgdGhlIG5leHREZWxpbSBpbiB0aGUgcXVvdGVkIGZpZWxkXG5cdFx0XHRcdFx0XHRcdHF1b3RlU2VhcmNoID0gaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIsIGN1cnNvcik7XHQvLyB3ZSBzZWFyY2ggZm9yIGZpcnN0IHF1b3RlIGluIG5leHQgbGluZVxuXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwSXNGdW5jdGlvbilcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2tzIGZvciB2YWxpZCBjbG9zaW5nIHF1b3RlcyBhcmUgY29tcGxldGUgKGVzY2FwZWQgcXVvdGVzIG9yIHF1b3RlIGZvbGxvd2VkIGJ5IEVPRi9kZWxpbWl0ZXIvbmV3bGluZSkgLS0gYXNzdW1lIHRoZXNlIHF1b3RlcyBhcmUgcGFydCBvZiBhbiBpbnZhbGlkIHRleHQgc3RyaW5nXG5cdFx0XHRcdFx0XHRlcnJvcnMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRjb2RlOiAnSW52YWxpZFF1b3RlcycsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdUcmFpbGluZyBxdW90ZSBvbiBxdW90ZWQgZmllbGQgaXMgbWFsZm9ybWVkJyxcblx0XHRcdFx0XHRcdFx0cm93OiBkYXRhLmxlbmd0aCxcdC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBjdXJzb3Jcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRxdW90ZVNlYXJjaCsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbW1lbnQgZm91bmQgYXQgc3RhcnQgb2YgbmV3IGxpbmVcblx0XHRcdFx0aWYgKGNvbW1lbnRzICYmIHJvdy5sZW5ndGggPT09IDAgJiYgaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgY3Vyc29yICsgY29tbWVudHNMZW4pID09PSBjb21tZW50cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChuZXh0TmV3bGluZSA9PT0gLTEpXHQvLyBDb21tZW50IGVuZHMgYXQgRU9GXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdGN1cnNvciA9IG5leHROZXdsaW5lICsgbmV3bGluZUxlbjtcblx0XHRcdFx0XHRuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdFx0XHRuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTmV4dCBkZWxpbWl0ZXIgY29tZXMgYmVmb3JlIG5leHQgbmV3bGluZSwgc28gd2UndmUgcmVhY2hlZCBlbmQgb2YgZmllbGRcblx0XHRcdFx0aWYgKG5leHREZWxpbSAhPT0gLTEgJiYgKG5leHREZWxpbSA8IG5leHROZXdsaW5lIHx8IG5leHROZXdsaW5lID09PSAtMSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyb3cucHVzaChpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBuZXh0RGVsaW0pKTtcblx0XHRcdFx0XHRjdXJzb3IgPSBuZXh0RGVsaW0gKyBkZWxpbUxlbjtcblx0XHRcdFx0XHQvLyB3ZSBsb29rIGZvciBuZXh0IGRlbGltaXRlciBjaGFyXG5cdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuZCBvZiByb3dcblx0XHRcdFx0aWYgKG5leHROZXdsaW5lICE9PSAtMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIG5leHROZXdsaW5lKSk7XG5cdFx0XHRcdFx0c2F2ZVJvdyhuZXh0TmV3bGluZSArIG5ld2xpbmVMZW4pO1xuXG5cdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0aWYgKGFib3J0ZWQpXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldylcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXG5cdFx0XHRyZXR1cm4gZmluaXNoKCk7XG5cblxuXHRcdFx0ZnVuY3Rpb24gcHVzaFJvdyhyb3cpXG5cdFx0XHR7XG5cdFx0XHRcdGRhdGEucHVzaChyb3cpO1xuXHRcdFx0XHRsYXN0Q3Vyc29yID0gY3Vyc29yO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcbiAgICAgICAgICAgICAqIGNoZWNrcyBpZiB0aGVyZSBhcmUgZXh0cmEgc3BhY2VzIGFmdGVyIGNsb3NpbmcgcXVvdGUgYW5kIGdpdmVuIGluZGV4IHdpdGhvdXQgYW55IHRleHRcbiAgICAgICAgICAgICAqIGlmIFllcywgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHNwYWNlc1xuICAgICAgICAgICAgICovXG5cdFx0XHRmdW5jdGlvbiBleHRyYVNwYWNlcyhpbmRleCkge1xuXHRcdFx0XHR2YXIgc3BhY2VMZW5ndGggPSAwO1xuXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0dmFyIHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXggPSBpbnB1dC5zdWJzdHJpbmcocXVvdGVTZWFyY2ggKyAxLCBpbmRleCk7XG5cdFx0XHRcdFx0aWYgKHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXggJiYgdGV4dEJldHdlZW5DbG9zaW5nUXVvdGVBbmRJbmRleC50cmltKCkgPT09ICcnKSB7XG5cdFx0XHRcdFx0XHRzcGFjZUxlbmd0aCA9IHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXgubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3BhY2VMZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwZW5kcyB0aGUgcmVtYWluaW5nIGlucHV0IGZyb20gY3Vyc29yIHRvIHRoZSBlbmQgaW50b1xuXHRcdFx0ICogcm93LCBzYXZlcyB0aGUgcm93LCBjYWxscyBzdGVwLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gZmluaXNoKHZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoaWdub3JlTGFzdFJvdylcblx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcblx0XHRcdFx0XHR2YWx1ZSA9IGlucHV0LnN1YnN0cmluZyhjdXJzb3IpO1xuXHRcdFx0XHRyb3cucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGN1cnNvciA9IGlucHV0TGVuO1x0Ly8gaW1wb3J0YW50IGluIGNhc2UgcGFyc2luZyBpcyBwYXVzZWRcblx0XHRcdFx0cHVzaFJvdyhyb3cpO1xuXHRcdFx0XHRpZiAoc3RlcElzRnVuY3Rpb24pXG5cdFx0XHRcdFx0ZG9TdGVwKCk7XG5cdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwZW5kcyB0aGUgY3VycmVudCByb3cgdG8gdGhlIHJlc3VsdHMuIEl0IHNldHMgdGhlIGN1cnNvclxuXHRcdFx0ICogdG8gbmV3Q3Vyc29yIGFuZCBmaW5kcyB0aGUgbmV4dE5ld2xpbmUuIFRoZSBjYWxsZXIgc2hvdWxkXG5cdFx0XHQgKiB0YWtlIGNhcmUgdG8gZXhlY3V0ZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhbmQgY2hlY2sgZm9yXG5cdFx0XHQgKiBwcmV2aWV3IGFuZCBlbmQgcGFyc2luZyBpZiBuZWNlc3NhcnkuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHNhdmVSb3cobmV3Q3Vyc29yKVxuXHRcdFx0e1xuXHRcdFx0XHRjdXJzb3IgPSBuZXdDdXJzb3I7XG5cdFx0XHRcdHB1c2hSb3cocm93KTtcblx0XHRcdFx0cm93ID0gW107XG5cdFx0XHRcdG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcmVzdWx0cywgZXJyb3JzLCBhbmQgbWV0YS4gKi9cblx0XHRcdGZ1bmN0aW9uIHJldHVybmFibGUoc3RvcHBlZClcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRcdGVycm9yczogZXJyb3JzLFxuXHRcdFx0XHRcdG1ldGE6IHtcblx0XHRcdFx0XHRcdGRlbGltaXRlcjogZGVsaW0sXG5cdFx0XHRcdFx0XHRsaW5lYnJlYWs6IG5ld2xpbmUsXG5cdFx0XHRcdFx0XHRhYm9ydGVkOiBhYm9ydGVkLFxuXHRcdFx0XHRcdFx0dHJ1bmNhdGVkOiAhIXN0b3BwZWQsXG5cdFx0XHRcdFx0XHRjdXJzb3I6IGxhc3RDdXJzb3IgKyAoYmFzZUluZGV4IHx8IDApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvKiogRXhlY3V0ZXMgdGhlIHVzZXIncyBzdGVwIGZ1bmN0aW9uIGFuZCByZXNldHMgZGF0YSAmIGVycm9ycy4gKi9cblx0XHRcdGZ1bmN0aW9uIGRvU3RlcCgpXG5cdFx0XHR7XG5cdFx0XHRcdHN0ZXAocmV0dXJuYWJsZSgpKTtcblx0XHRcdFx0ZGF0YSA9IFtdO1xuXHRcdFx0XHRlcnJvcnMgPSBbXTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqIFNldHMgdGhlIGFib3J0IGZsYWcgKi9cblx0XHR0aGlzLmFib3J0ID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGFib3J0ZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHQvKiogR2V0cyB0aGUgY3Vyc29yIHBvc2l0aW9uICovXG5cdFx0dGhpcy5nZXRDaGFySW5kZXggPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGN1cnNvcjtcblx0XHR9O1xuXHR9XG5cblxuXHRmdW5jdGlvbiBuZXdXb3JrZXIoKVxuXHR7XG5cdFx0aWYgKCFQYXBhLldPUktFUlNfU1VQUE9SVEVEKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIHdvcmtlclVybCA9IGdldFdvcmtlckJsb2IoKTtcblx0XHR2YXIgdyA9IG5ldyBnbG9iYWwuV29ya2VyKHdvcmtlclVybCk7XG5cdFx0dy5vbm1lc3NhZ2UgPSBtYWluVGhyZWFkUmVjZWl2ZWRNZXNzYWdlO1xuXHRcdHcuaWQgPSB3b3JrZXJJZENvdW50ZXIrKztcblx0XHR3b3JrZXJzW3cuaWRdID0gdztcblx0XHRyZXR1cm4gdztcblx0fVxuXG5cdC8qKiBDYWxsYmFjayB3aGVuIG1haW4gdGhyZWFkIHJlY2VpdmVzIGEgbWVzc2FnZSAqL1xuXHRmdW5jdGlvbiBtYWluVGhyZWFkUmVjZWl2ZWRNZXNzYWdlKGUpXG5cdHtcblx0XHR2YXIgbXNnID0gZS5kYXRhO1xuXHRcdHZhciB3b3JrZXIgPSB3b3JrZXJzW21zZy53b3JrZXJJZF07XG5cdFx0dmFyIGFib3J0ZWQgPSBmYWxzZTtcblxuXHRcdGlmIChtc2cuZXJyb3IpXG5cdFx0XHR3b3JrZXIudXNlckVycm9yKG1zZy5lcnJvciwgbXNnLmZpbGUpO1xuXHRcdGVsc2UgaWYgKG1zZy5yZXN1bHRzICYmIG1zZy5yZXN1bHRzLmRhdGEpXG5cdFx0e1xuXHRcdFx0dmFyIGFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRjb21wbGV0ZVdvcmtlcihtc2cud29ya2VySWQsIHsgZGF0YTogW10sIGVycm9yczogW10sIG1ldGE6IHsgYWJvcnRlZDogdHJ1ZSB9IH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGhhbmRsZSA9IHtcblx0XHRcdFx0YWJvcnQ6IGFib3J0LFxuXHRcdFx0XHRwYXVzZTogbm90SW1wbGVtZW50ZWQsXG5cdFx0XHRcdHJlc3VtZTogbm90SW1wbGVtZW50ZWRcblx0XHRcdH07XG5cblx0XHRcdGlmIChpc0Z1bmN0aW9uKHdvcmtlci51c2VyU3RlcCkpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLnJlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHdvcmtlci51c2VyU3RlcCh7XG5cdFx0XHRcdFx0XHRkYXRhOiBtc2cucmVzdWx0cy5kYXRhW2ldLFxuXHRcdFx0XHRcdFx0ZXJyb3JzOiBtc2cucmVzdWx0cy5lcnJvcnMsXG5cdFx0XHRcdFx0XHRtZXRhOiBtc2cucmVzdWx0cy5tZXRhXG5cdFx0XHRcdFx0fSwgaGFuZGxlKTtcblx0XHRcdFx0XHRpZiAoYWJvcnRlZClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBtc2cucmVzdWx0cztcdC8vIGZyZWUgbWVtb3J5IEFTQVBcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzRnVuY3Rpb24od29ya2VyLnVzZXJDaHVuaykpXG5cdFx0XHR7XG5cdFx0XHRcdHdvcmtlci51c2VyQ2h1bmsobXNnLnJlc3VsdHMsIGhhbmRsZSwgbXNnLmZpbGUpO1xuXHRcdFx0XHRkZWxldGUgbXNnLnJlc3VsdHM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1zZy5maW5pc2hlZCAmJiAhYWJvcnRlZClcblx0XHRcdGNvbXBsZXRlV29ya2VyKG1zZy53b3JrZXJJZCwgbXNnLnJlc3VsdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGxldGVXb3JrZXIod29ya2VySWQsIHJlc3VsdHMpIHtcblx0XHR2YXIgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF07XG5cdFx0aWYgKGlzRnVuY3Rpb24od29ya2VyLnVzZXJDb21wbGV0ZSkpXG5cdFx0XHR3b3JrZXIudXNlckNvbXBsZXRlKHJlc3VsdHMpO1xuXHRcdHdvcmtlci50ZXJtaW5hdGUoKTtcblx0XHRkZWxldGUgd29ya2Vyc1t3b3JrZXJJZF07XG5cdH1cblxuXHRmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcblx0fVxuXG5cdC8qKiBDYWxsYmFjayB3aGVuIHdvcmtlciB0aHJlYWQgcmVjZWl2ZXMgYSBtZXNzYWdlICovXG5cdGZ1bmN0aW9uIHdvcmtlclRocmVhZFJlY2VpdmVkTWVzc2FnZShlKVxuXHR7XG5cdFx0dmFyIG1zZyA9IGUuZGF0YTtcblxuXHRcdGlmICh0eXBlb2YgUGFwYS5XT1JLRVJfSUQgPT09ICd1bmRlZmluZWQnICYmIG1zZylcblx0XHRcdFBhcGEuV09SS0VSX0lEID0gbXNnLndvcmtlcklkO1xuXG5cdFx0aWYgKHR5cGVvZiBtc2cuaW5wdXQgPT09ICdzdHJpbmcnKVxuXHRcdHtcblx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcblx0XHRcdFx0cmVzdWx0czogUGFwYS5wYXJzZShtc2cuaW5wdXQsIG1zZy5jb25maWcpLFxuXHRcdFx0XHRmaW5pc2hlZDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChnbG9iYWwuRmlsZSAmJiBtc2cuaW5wdXQgaW5zdGFuY2VvZiBGaWxlKSB8fCBtc2cuaW5wdXQgaW5zdGFuY2VvZiBPYmplY3QpXHQvLyB0aGFuayB5b3UsIFNhZmFyaSAoc2VlIGlzc3VlICMxMDYpXG5cdFx0e1xuXHRcdFx0dmFyIHJlc3VsdHMgPSBQYXBhLnBhcnNlKG1zZy5pbnB1dCwgbXNnLmNvbmZpZyk7XG5cdFx0XHRpZiAocmVzdWx0cylcblx0XHRcdFx0Z2xvYmFsLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0XHR3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG5cdFx0XHRcdFx0cmVzdWx0czogcmVzdWx0cyxcblx0XHRcdFx0XHRmaW5pc2hlZDogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKiogTWFrZXMgYSBkZWVwIGNvcHkgb2YgYW4gYXJyYXkgb3Igb2JqZWN0IChtb3N0bHkpICovXG5cdGZ1bmN0aW9uIGNvcHkob2JqKVxuXHR7XG5cdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbClcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0dmFyIGNweSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG5cdFx0Zm9yICh2YXIga2V5IGluIG9iailcblx0XHRcdGNweVtrZXldID0gY29weShvYmpba2V5XSk7XG5cdFx0cmV0dXJuIGNweTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJpbmRGdW5jdGlvbihmLCBzZWxmKVxuXHR7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyBmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7IH07XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmMpXG5cdHtcblx0XHRyZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG5cdH1cblxuXHRyZXR1cm4gUGFwYTtcbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJQYXBhIiwibW9kdWxlRmFjdG9yeSIsImdsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJnZXRXb3JrZXJCbG9iIiwiVVJMIiwid2Via2l0VVJMIiwiY29kZSIsInRvU3RyaW5nIiwiQkxPQl9VUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwidHlwZSIsIklTX1dPUktFUiIsImRvY3VtZW50IiwicG9zdE1lc3NhZ2UiLCJJU19QQVBBX1dPUktFUiIsIndvcmtlcnMiLCJ3b3JrZXJJZENvdW50ZXIiLCJwYXJzZSIsIkNzdlRvSnNvbiIsInVucGFyc2UiLCJKc29uVG9Dc3YiLCJSRUNPUkRfU0VQIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiVU5JVF9TRVAiLCJCWVRFX09SREVSX01BUksiLCJCQURfREVMSU1JVEVSUyIsIldPUktFUlNfU1VQUE9SVEVEIiwiV29ya2VyIiwiTk9ERV9TVFJFQU1fSU5QVVQiLCJMb2NhbENodW5rU2l6ZSIsIlJlbW90ZUNodW5rU2l6ZSIsIkRlZmF1bHREZWxpbWl0ZXIiLCJQYXJzZXIiLCJQYXJzZXJIYW5kbGUiLCJOZXR3b3JrU3RyZWFtZXIiLCJGaWxlU3RyZWFtZXIiLCJTdHJpbmdTdHJlYW1lciIsIlJlYWRhYmxlU3RyZWFtU3RyZWFtZXIiLCJQQVBBX0JST1dTRVJfQ09OVEVYVCIsIkR1cGxleFN0cmVhbVN0cmVhbWVyIiwialF1ZXJ5IiwiJCIsImZuIiwib3B0aW9ucyIsImNvbmZpZyIsInF1ZXVlIiwiZWFjaCIsImlkeCIsInN1cHBvcnRlZCIsInByb3AiLCJ0b1VwcGVyQ2FzZSIsImF0dHIiLCJ0b0xvd2VyQ2FzZSIsIkZpbGVSZWFkZXIiLCJmaWxlcyIsImxlbmd0aCIsImkiLCJwdXNoIiwiZmlsZSIsImlucHV0RWxlbSIsImluc3RhbmNlQ29uZmlnIiwiZXh0ZW5kIiwicGFyc2VOZXh0RmlsZSIsImlzRnVuY3Rpb24iLCJjb21wbGV0ZSIsImYiLCJiZWZvcmUiLCJyZXR1cm5lZCIsImFjdGlvbiIsImVycm9yIiwicmVhc29uIiwiZmlsZUNvbXBsZXRlIiwidXNlckNvbXBsZXRlRnVuYyIsInJlc3VsdHMiLCJuYW1lIiwiZWxlbSIsInNwbGljZSIsIm9ubWVzc2FnZSIsIndvcmtlclRocmVhZFJlY2VpdmVkTWVzc2FnZSIsIl9pbnB1dCIsIl9jb25maWciLCJkeW5hbWljVHlwaW5nIiwiZHluYW1pY1R5cGluZ0Z1bmN0aW9uIiwidHJhbnNmb3JtIiwid29ya2VyIiwidyIsIm5ld1dvcmtlciIsInVzZXJTdGVwIiwic3RlcCIsInVzZXJDaHVuayIsImNodW5rIiwidXNlckNvbXBsZXRlIiwidXNlckVycm9yIiwiaW5wdXQiLCJ3b3JrZXJJZCIsImlkIiwic3RyZWFtZXIiLCJnZXRTdHJlYW0iLCJzdHJpcEJvbSIsImRvd25sb2FkIiwicmVhZGFibGUiLCJyZWFkIiwib24iLCJGaWxlIiwiT2JqZWN0Iiwic3RyZWFtIiwic3RyaW5nIiwiY2hhckNvZGVBdCIsInNsaWNlIiwiX3F1b3RlcyIsIl93cml0ZUhlYWRlciIsIl9kZWxpbWl0ZXIiLCJfbmV3bGluZSIsIl9xdW90ZUNoYXIiLCJfZXNjYXBlZFF1b3RlIiwiX3NraXBFbXB0eUxpbmVzIiwiX2NvbHVtbnMiLCJfZXNjYXBlRm9ybXVsYWUiLCJ1bnBhY2tDb25maWciLCJxdW90ZUNoYXJSZWdleCIsIlJlZ0V4cCIsImVzY2FwZVJlZ0V4cCIsIkpTT04iLCJBcnJheSIsImlzQXJyYXkiLCJzZXJpYWxpemUiLCJrZXlzIiwiZGF0YSIsImZpZWxkcyIsIm1ldGEiLCJFcnJvciIsImRlbGltaXRlciIsImZpbHRlciIsInZhbHVlIiwiaW5kZXhPZiIsInF1b3RlcyIsInNraXBFbXB0eUxpbmVzIiwibmV3bGluZSIsInF1b3RlQ2hhciIsImhlYWRlciIsImNvbHVtbnMiLCJlc2NhcGVDaGFyIiwidW5kZWZpbmVkIiwiZXNjYXBlRm9ybXVsYWUiLCJjc3YiLCJoYXNIZWFkZXIiLCJkYXRhS2V5ZWRCeUZpZWxkIiwic2FmZSIsInJvdyIsIm1heENvbCIsImVtcHR5TGluZSIsIm51bGxMaW5lIiwiam9pbiIsInRyaW0iLCJsaW5lIiwiYyIsImN4IiwiY29sIiwiY29sSWR4Iiwic3RyIiwiY29uc3RydWN0b3IiLCJEYXRlIiwic3RyaW5naWZ5IiwibmVlZHNRdW90ZXMiLCJ0ZXN0IiwiZXNjYXBlZFF1b3RlU3RyIiwicmVwbGFjZSIsImhhc0FueSIsImNoYXJBdCIsInN1YnN0cmluZ3MiLCJDaHVua1N0cmVhbWVyIiwiX2hhbmRsZSIsIl9maW5pc2hlZCIsIl9jb21wbGV0ZWQiLCJfaGFsdGVkIiwiX2Jhc2VJbmRleCIsIl9wYXJ0aWFsTGluZSIsIl9yb3dDb3VudCIsIl9zdGFydCIsIl9uZXh0Q2h1bmsiLCJpc0ZpcnN0Q2h1bmsiLCJfY29tcGxldGVSZXN1bHRzIiwiZXJyb3JzIiwicmVwbGFjZUNvbmZpZyIsImNhbGwiLCJwYXJzZUNodW5rIiwiaXNGYWtlQ2h1bmsiLCJiZWZvcmVGaXJzdENodW5rIiwibW9kaWZpZWRDaHVuayIsImFnZ3JlZ2F0ZSIsInBhdXNlZCIsImFib3J0ZWQiLCJsYXN0SW5kZXgiLCJjdXJzb3IiLCJzdWJzdHJpbmciLCJmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXciLCJwcmV2aWV3IiwiV09SS0VSX0lEIiwiZmluaXNoZWQiLCJjb25jYXQiLCJfc2VuZEVycm9yIiwiY29uZmlnQ29weSIsImNvcHkiLCJjaHVua1NpemUiLCJwYXJzZUludCIsInhociIsIl9yZWFkQ2h1bmsiLCJfY2h1bmtMb2FkZWQiLCJ1cmwiLCJYTUxIdHRwUmVxdWVzdCIsIndpdGhDcmVkZW50aWFscyIsIm9ubG9hZCIsImJpbmRGdW5jdGlvbiIsIm9uZXJyb3IiLCJfY2h1bmtFcnJvciIsIm9wZW4iLCJkb3dubG9hZFJlcXVlc3RCb2R5IiwiZG93bmxvYWRSZXF1ZXN0SGVhZGVycyIsImhlYWRlcnMiLCJoZWFkZXJOYW1lIiwic2V0UmVxdWVzdEhlYWRlciIsImVuZCIsInNlbmQiLCJlcnIiLCJtZXNzYWdlIiwic3RhdHVzIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVGV4dCIsImdldEZpbGVTaXplIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JUZXh0Iiwic3RhdHVzVGV4dCIsImNvbnRlbnRSYW5nZSIsImdldFJlc3BvbnNlSGVhZGVyIiwibGFzdEluZGV4T2YiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJyZWFkZXIiLCJ1c2luZ0FzeW5jUmVhZGVyIiwid2Via2l0U2xpY2UiLCJtb3pTbGljZSIsIkZpbGVSZWFkZXJTeW5jIiwiTWF0aCIsIm1pbiIsInNpemUiLCJ0eHQiLCJyZWFkQXNUZXh0IiwiZW5jb2RpbmciLCJ0YXJnZXQiLCJyZXN1bHQiLCJldmVudCIsInJlbWFpbmluZyIsInMiLCJwYXJzZU9uRGF0YSIsInN0cmVhbUhhc0VuZGVkIiwicGF1c2UiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlc3VtZSIsIl9zdHJlYW1EYXRhIiwiX3N0cmVhbUVuZCIsIl9zdHJlYW1FcnJvciIsIl9jaGVja0lzRmluaXNoZWQiLCJzaGlmdCIsIl9zdHJlYW1DbGVhblVwIiwicmVtb3ZlTGlzdGVuZXIiLCJEdXBsZXgiLCJyZXF1aXJlIiwicGFyc2VPbldyaXRlIiwid3JpdGVTdHJlYW1IYXNGaW5pc2hlZCIsInBhcnNlQ2FsbGJhY2tRdWV1ZSIsIl9vbkNzdkRhdGEiLCJfb25Dc3ZDb21wbGV0ZSIsIl9hZGRUb1BhcnNlUXVldWUiLCJjYWxsYmFjayIsIl9vblJlYWQiLCJfb25Xcml0ZSIsIl9vbldyaXRlQ29tcGxldGUiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJkZWNvZGVTdHJpbmdzIiwid3JpdGUiLCJvbmNlIiwiTUFYX0ZMT0FUIiwicG93IiwiTUlOX0ZMT0FUIiwiRkxPQVQiLCJJU09fREFURSIsIl9zdGVwQ291bnRlciIsIl9yb3dDb3VudGVyIiwiX3BhcnNlciIsIl9wYXVzZWQiLCJfYWJvcnRlZCIsIl9kZWxpbWl0ZXJFcnJvciIsIl9maWVsZHMiLCJfcmVzdWx0cyIsIm5lZWRzSGVhZGVyUm93IiwicHJvY2Vzc1Jlc3VsdHMiLCJhYm9ydCIsImJhc2VJbmRleCIsImlnbm9yZUxhc3RSb3ciLCJndWVzc0xpbmVFbmRpbmdzIiwiZGVsaW1HdWVzcyIsImd1ZXNzRGVsaW1pdGVyIiwiY29tbWVudHMiLCJkZWxpbWl0ZXJzVG9HdWVzcyIsInN1Y2Nlc3NmdWwiLCJiZXN0RGVsaW1pdGVyIiwicGFyc2VyQ29uZmlnIiwiZ2V0Q2hhckluZGV4Iiwic2V0VGltZW91dCIsInRlc3RFbXB0eUxpbmUiLCJ0ZXN0RmxvYXQiLCJmbG9hdFZhbHVlIiwicGFyc2VGbG9hdCIsImFkZEVycm9yIiwiZCIsImZpbGxIZWFkZXJGaWVsZHMiLCJhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmdBbmRUcmFuc2Zvcm1hdGlvbiIsImFkZEhlYWRlciIsInRyYW5zZm9ybUhlYWRlciIsImZvckVhY2giLCJzaG91bGRBcHBseUR5bmFtaWNUeXBpbmciLCJmaWVsZCIsInBhcnNlRHluYW1pYyIsInByb2Nlc3NSb3ciLCJyb3dTb3VyY2UiLCJqIiwiaW5jcmVtZW50QnkiLCJtYXAiLCJiZXN0RGVsaW0iLCJiZXN0RGVsdGEiLCJmaWVsZENvdW50UHJldlJvdyIsIm1heEZpZWxkQ291bnQiLCJkZWxpbSIsImRlbHRhIiwiYXZnRmllbGRDb3VudCIsImVtcHR5TGluZXNDb3VudCIsImZpZWxkQ291bnQiLCJhYnMiLCJyZSIsInIiLCJzcGxpdCIsIm4iLCJuQXBwZWFyc0ZpcnN0IiwibnVtV2l0aE4iLCJtc2ciLCJmYXN0TW9kZSIsImlucHV0TGVuIiwiZGVsaW1MZW4iLCJuZXdsaW5lTGVuIiwiY29tbWVudHNMZW4iLCJzdGVwSXNGdW5jdGlvbiIsImxhc3RDdXJzb3IiLCJyZXR1cm5hYmxlIiwiZmlyc3RMaW5lIiwic2VwYXJhdG9yIiwiaGVhZGVyTWFwIiwiaGVhZGVyQ291bnQiLCJkdXBsaWNhdGVIZWFkZXJzIiwiY291bnQiLCJpbmNsdWRlcyIsImVkaXRlZElucHV0Iiwicm93cyIsInB1c2hSb3ciLCJkb1N0ZXAiLCJuZXh0RGVsaW0iLCJuZXh0TmV3bGluZSIsInF1b3RlU2VhcmNoIiwiaW5kZXgiLCJmaW5pc2giLCJjaGVja1VwVG8iLCJzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIiLCJleHRyYVNwYWNlcyIsInN1YnN0ciIsInNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUiLCJzYXZlUm93Iiwic3BhY2VMZW5ndGgiLCJ0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4IiwibmV3Q3Vyc29yIiwic3RvcHBlZCIsImxpbmVicmVhayIsInRydW5jYXRlZCIsIndvcmtlclVybCIsIm1haW5UaHJlYWRSZWNlaXZlZE1lc3NhZ2UiLCJlIiwiY29tcGxldGVXb3JrZXIiLCJoYW5kbGUiLCJub3RJbXBsZW1lbnRlZCIsInRlcm1pbmF0ZSIsIm9iaiIsImNweSIsImtleSIsImZ1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/papaparse/papaparse.js\n");

/***/ })

};
;